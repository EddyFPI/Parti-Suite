      PROGRAM HAPHETLN 
C     PROGRAM TO SIMULATE PARTICLE TRAJECTORIES IN PARALLEL PLATE SYSTEM

C     DEFINE ARRAYS FIRST
      DIMENSION IOT(50000)                                            !STEP NUMBER
      DIMENSION XOT(50000),YOT(50000),ROT(50000),ZOT(50000)           !PARTICLE POSITION
      DIMENSION HOT(50000)                                            !SEPARATION DISTANCE
      DIMENSION ETIMEOT(50000),PTIMEFOT(50000)                        !TRAJECTORY TIME, ELAPSED AND REAL
      DIMENSION FCOLLOT(50000),FVDWOT(50000),FEDLOT(50000)            !TOTAL COLLOIDAL, VDW, AND EDL FORCES
      DIMENSION FABOT(50000),FSTEOT(50000),FBORNOT(50000)             !ACID-BASE, STERIC, AND BORN FORCES
      DIMENSION UTOT(50000),UNOT(50000),VTOT(50000),VNOT(50000)       !PARTICLE AND FLUID VELOCITIES, TANGENTIAL AND NORMAL
      DIMENSION FDRGTOT(50000),FDRGNOT(50000)                         !DRAG FORCE, TANGENTIAL AND NORMAL
      DIMENSION FDIFXOT(50000),FDIFYOT(50000),FDIFZOT(50000)          !DIFFUSION FORCE
      DIMENSION FGOT(50000),FLIFTOT(50000)                            !GRAVITY AND LIFT FORCE
      DIMENSION ACONTOT(50000),RZOIOT(50000),AFRACTOT(50000)          !CONTACT RADIUS,RZOI,AND FRACTION OF ZOI OVER HET
      DIMENSION XHET(100),YHET(100),RHET(100)                         !HET LOCATIONS
      DIMENSION XHETP(10000000),YHETP(10000000),ZHETP(10000000)       !HETERODOMAIN LOCATIONS ON COLLOID
      DIMENSION RHETP(10000000)                                       !HETERODOMAIN LOCATIONS ON COLLOID
      DIMENSION PHIP(10000000),THETAP(10000000)                       !HETERODOMAIN LOCATIONS ON COLLOID (SPHERICAL COORDINATES) 
      DIMENSION XPRO(10000000),YPRO(10000000),RPRO(10000000)          !PROJECTION OF HETERODOMAINS ON COLLOID
      DIMENSION seed(8)                                               !RANDOM NUMBER PARAMETER

      INTEGER IOT
      DOUBLE PRECISION XOT,YOT,ROT,ZOT
      DOUBLE PRECISION HOT
      DOUBLE PRECISION ETIMEOT,PTIMEFOT
      DOUBLE PRECISION FCOLLOT,FVDWOT,FEDLOT
      DOUBLE PRECISION FABOT,FSTEOT,FBORNOT
      DOUBLE PRECISION UTOT,UNOT,VTOT,VNOT
      DOUBLE PRECISION FDRGTOT,FDRGNOT
      DOUBLE PRECISION FDIFXOT,FDIFYOT,FDIFZOT
      DOUBLE PRECISION FGOT,FLIFTOT
      DOUBLE PRECISION ACONTOT,RZOIOT,AFRACTOT
      DOUBLE PRECISION XHET,YHET,RHET
      DOUBLE PRECISION XHETP,YHETP,ZHETP
      DOUBLE PRECISION RHETP,PHIP,THETAP
      DOUBLE PRECISION XPRO,YPRO,RPRO
      DOUBLE PRECISION seed

C     DEFINE INPUT VARIABLES (DESCRIBED IN INPUT)
      INTEGER NPART,ATTMODE,CLUSTER,VDWMODE
      DOUBLE PRECISION Q,ZLIM,RPAR,YPAR,REXIT,TTIME
      DOUBLE PRECISION AP,RHOP,RHOW,VISC,ER,T
      DOUBLE PRECISION IS,ZI,ZETAPST,ZETACST
      DOUBLE PRECISION ZETAHET,RHET0,RHET1,RHET2,SCOV
      DOUBLE PRECISION ZETAHETP,RHETP0,RHETP1,SCOVP
      DOUBLE PRECISION A132,LAMBDAVDW,A11,AC1C1,A22,AC2C2,A33,T1,T2
      DOUBLE PRECISION B,ASP,ASP2
      DOUBLE PRECISION GAMMA0AB,LAMBDAAB,GAMMA0STE,LAMBDASTE
      DOUBLE PRECISION KINT,W132,BETA
      DOUBLE PRECISION DIFFSCALE,GRAVFACT
      DOUBLE PRECISION MULTB,MULTNS,MULTC,DFACTNS,DFACTC
      INTEGER NOUT,PRINTMAX,HETMODE,HETMODEP,RMODE

C     DEFINE OTHER VARIABLES
      DOUBLE PRECISION X,Y,Z,H,R,XO,YO,ZO,Xm0,Ym0,Zm0,JX,JY           !SPATIAL COORDINATES
      DOUBLE PRECISION XINIT,YINIT,RINIT,ZINIT,HINIT,ZMAX             !INITIAL COORDINATES
      DOUBLE PRECISION FCOLL,FVDW,FEDL,FAB,FSTE,FBORN                 !COLLOIDAL FORCES
      DOUBLE PRECISION MP,NIO,KAPPA,ZETAP,ZETAC,ERE0                  !MASS AND EDL PARAMETERS
      DOUBLE PRECISION RZOI,RZOIBULK                                  !ZONE OF INFLUENCE
      DOUBLE PRECISION FDRGX,FDRGY,FDRGZ,FDRGR                        !DRAG FORCES
      DOUBLE PRECISION FDIFX,FDIFY,FDIFZ                              !DIFFUSION FORCES
      DOUBLE PRECISION FLIFT,FG,FADH,FREP                             !FORCES
      DOUBLE PRECISION dTMRT,dT,TBULK,TNEAR,TFRIC                     !TIME
      DOUBLE PRECISION TINJ,PTIMEF,ETIME                              !SIMULATION TIME
      DOUBLE PRECISION VR,VZ,UX,UXO,UY,UYO,UR,URO,UZ,UZO,OMEGA        !VELOCITIES
      DOUBLE PRECISION c2R,p0R,q1R,q2R,q3R,q4R                        !CONTINUUM FLOW FIELD PARAMETERS
      DOUBLE PRECISION c2Z,c3Z,p0Z,q1Z,q2Z,q3Z,q4Z                    !CONTINUUM FLOW FIELD PARAMETERS
      DOUBLE PRECISION VM,HBAR,M3                                     !HYDRODYNAMIC RETARDATION
      DOUBLE PRECISION A1,B1,C1,D1,E1,A2,B2,C2,D2,E2,A3,B3,C3,D3,E3   !HYDRODYNAMIC RETARDATION
      DOUBLE PRECISION A4,B4,C4,D4,E4,FUN1,FUN2,FUN3,FUN4             !HYDRODYNAMIC RETARDATION
      DOUBLE PRECISION HFRIC,FBORNFRIC,FSTEFRIC,FABFRIC               !CONTACT SEPARATION DISTANCE VARIABLES
      DOUBLE PRECISION HMIN,ASP0,NASP0                                !MINIMUM SEPARATION DISTANCE VARIABLES
      DOUBLE PRECISION ACONTMAX,ACONT,DELTAMAX,DELTA,ASTE             !DEFORMATION VARIABLES
      DOUBLE PRECISION FEDL_ZH,FEDL_PZ,FEDL_PZH,FEDL_Z                !HETEROGENEITY EDL FORCES
      DOUBLE PRECISION XREF1,YREF1,ZREF1,TREF1,DREF1,DIND1,DCOEF      !SLOW MOTION IN NEAR SURFACE
      DOUBLE PRECISION XREF2,YREF2,ZREF2,TREF2,DREF2,DIND2,DIND3      !SLOW MOTION IN CONTACT
      DOUBLE PRECISION HSUM,HAVE,XENTER,YENTER,NSDIST,NSVEL           !AVERAGE NS SEPARATION AND VELOCITY
      DOUBLE PRECISION NASP,NASPAB,ASPLIM,ASPABLIM,RZOIAB,RLEV        !ROUGHNESS PARAMETERS (# ASPERITIES, TORQUE LEVER ARM)
      DOUBLE PRECISION PI,G,E0,ECHG,KB,NA,H0,SIGMAC                   !CONSTANTS
      DOUBLE PRECISION AFRACT,AFRACT_PZ,AFRACT_ZH,AFRACT_PZH,AFRACT_Z !FRACTIONAL AREAS 
      DOUBLE PRECISION AF_PZ,AF_ZH,AF_PZH,AF_Z                        !FRACTIONAL AREAS
      DOUBLE PRECISION, ALLOCATABLE :: M_PRO(:,:)                     !PROJECTION MATRIX FOR HETERODOMAINS ON COLLOID

C     
      CHARACTER DUMMY*20
      CHARACTER FILESINGLE*25

      INTEGER I,J,K,L                                                 !LOOP PARAMETERS
      INTEGER PCOUNT,OUTCOUNT,OUTMAX,OUTFLAG,NPRINT                   !OUTPUT FILE PARAMETERS
      INTEGER ATTACHK,HFLAG,ARRESTFLAG,NSVISIT,FRICVISIT              !PARTICLE INDICATORS
      INTEGER IREF1,IREF2,HETTYPE,HETFLAG,NPARTLOOP,RMODE0            !MISCELLANEOUS PARAMETERS
      INTEGER nrand,RMULT                                             !RANDOM NUMBER PARAMETERS
      INTEGER NHETP,NPRO,IPRO                                         !HETERODOMAINS ON COLLOID AND PROJECTIONS PARAMETERS

C     MC VARIABLES DECLARATION, THESE ARE NEEDED FOR THE CLUSTER VERSION. DON'T DELETE!
      character*40 argv
      character*40 filenam
      integer ipart,ilen
      character*6 chri
      character*10 date, time, zone
      integer iarray(8)

C     PHYSICAL CONSTANTS
      DATA PI/3.14159265359/                                          !PIE (CHERRY,STRAWBERRY RHUBARB, ETC.)
      DATA G/9.80665/                                                 !ACCELERATION DUE TO GRAVITY (M/S^2)
      DATA E0/8.85418781762E-12/                                      !VACUUM PERMITTIVITY (C^2/N M^2)
      DATA ECHG/1.602176634E-19/                                      !ELEMENTARY CHARGE (C)
      DATA KB/1.380649E-23/                                           !BOLTZMANN CONSTANT (J/K)
      DATA NA/6.02214076E23/                                          !AVOGADRO CONSTANT (-)

C     HARDWIRED VALUES
      DATA H0/0.158E-9/                                               !MINIMUM SEPARATION DISTANCE (M)
      DATA SIGMAC/5.0E-10/                                            !BORN COLLISION DIAMTER (M)
      DATA OUTMAX/50000/                                              !LARGEST OUTPUT ARRAY LENGTH

C     READ INPUT FILE
1000  FORMAT (3/)
      OPEN (UNIT=1,FILE='INPUT.IN',STATUS='OLD')
      DO I=1,6 !SKIP 6 FIRST LINES (HEADER)
          READ (1,*)
      END DO
      READ (1,*) NPART,ATTMODE,CLUSTER
      READ (1,1000)
      READ (1,*) Q,ZLIM,ZMAX,REXIT,RPAR,YPAR,TTIME
      READ (1,1000)
      READ (1,*) AP,RHOP,RHOW,VISC,ER,T
      READ (1,1000)
      READ (1,*) IS,ZI,ZETAPST,ZETACST
      READ (1,1000)
      READ (1,*) ZETAHET,HETMODE,RHET0,RHET1,RHET2,SCOV
      READ (1,1000)
      READ (1,*) ZETAHETP,HETMODEP,RHETP0,RHETP1,SCOVP
      READ (1,1000)
      READ (1,*) A132,LAMBDAVDW,VDWMODE
      READ (1,1000)
      READ (1,*) A11,AC1C1,A22,AC2C2,A33
      READ (1,1000)
      READ (1,*) T1,T2
      READ (1,1000)
      READ (1,*) GAMMA0AB,LAMBDAAB,GAMMA0STE,LAMBDASTE
      READ (1,1000)
      READ (1,*) B,RMODE,ASP,ASP2
      READ (1,1000)
      READ (1,*) KINT,W132,BETA
      READ (1,1000)
      READ (1,*) DIFFSCALE,GRAVFACT
      READ (1,1000)
      READ (1,*) MULTB,MULTNS,MULTC,DFACTNS,DFACTC
      READ (1,1000)
      READ (1,*) NOUT,PRINTMAX

C     SET CENTER OF COLLECTOR
      Xm0 = 0.0
      Ym0 = 0.0
      Zm0 = 0.0
C     SET NULL HETTYPE, NONE=0, LARGE=1, MEDIUM=2, SMALL=3, LARGEANDMEDIUM=4, LARGEANDSMALL=5, MEDIUMANDSMALL=6
      HETTYPE = 0
C     SET NULL HETFLAG, 0=NOT OVER HETERODOMAIN, 1=PASSED OVER HETERODOMAIN
      HETFLAG = 0
C     CALCULATE MASS OF PARTICLE
      MP = (4.0/3.0)*(PI)*(AP**3)*RHOP
C     CALCULATE MOMENTUM RELAXATION TIME
      dTMRT = MP/(6.0*PI*VISC*AP)
C     SET INJECTION TIME
      TINJ = TTIME/6.0
C     SET VIRTUAL MASS COEFFICIENT
      VM = (2.0/3.0)*PI*(AP**3)*RHOW
C     SET DRAG FORCE COEFFICIENT
      M3 = 6.0*PI*VISC*AP
C     CALCULATE KAPPA, NOTE: IS FOR 1:1 ELECTROLYTE ONLY
      ERE0 = ER*E0 !ABSOLUTE PERMITTIVITY
      NIO = IS*2*NA
      KAPPA = ((ECHG**2.0)*NIO*(ZI**2.0)/(ERE0*KB*T))**0.5
C     CALCULATE RZOIBULK: RADIUS OF ZONE OF INFLUENCE WITHOUT DEFORMATION
      RZOIBULK = 2.0*((1/KAPPA)*AP)**0.5
C     CALCULATE ACONTMAX: MAXIMUM RADIUS OF CONTACT USING JKR (NEGATIVE SIGN ADDED TO MAKE CONTACT AREA POSITIVE FOR ATTRACTIVE WORK OF ADHESION, W132<0)
      IF (W132.GT.0.0) THEN
          W132 = 0.0
      ENDIF
      ACONTMAX = (-6.0*PI*W132*(AP**2.0)/KINT)**(1.0/3.0)
C     CALCULATE MAXIMUM VERTICAL DEFORMATION OF THE COLLOID
      DELTAMAX = AP - SQRT(AP**2-ACONTMAX**2)
C     CALCULATE STERIC INTERACTION RADIUS
      ASTE=(ACONTMAX**2+2*LAMBDASTE*(AP+(AP**2-ACONTMAX**2)**0.5))**0.5
C     SET A132=0 FOR LAYERED SYTEMS TO SHOW IN OUTPUT THAT A132 IS NOT USED
      IF (VDWMODE.NE.1) THEN
          A132 = 0.0
      ENDIF
C      
C     CALCULATE HFRIC - SEPARATION AT WHICH WE CONSIDER CONTACT TO OCCUR AND ZERO SLIP. DEFORMATION STARTS TO OCCUR FOR SEPARATION DISTANCES SMALLER
C                       THAN THIS VALUE. WE DEFINE THIS DISTANCE TO BE THAT WHERE EACH OF THE CONTACT FORCES HAVE REACHED 0.01% OF THEIR VALUE AT
C                       VACUUM MINIMUM SEPARATION OF 0.158 NM
      H = H0
      ASP0 = 0.0
      NASP0 = 0.0
      RMODE0 = 0
      CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                    A22,A33,AC1C1,AC2C2,VDWMODE)
      CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
      CALL FORCEAB (PI,AP,ASP0,NASP0,RMODE0,LAMBDAAB,
     &                    GAMMA0AB,H,H0,FAB)
      FBORNFRIC = 0.0001*FBORN
      FSTEFRIC = 0.0001*FSTE
      FABFRIC = 0.0001*FAB
      DO WHILE ((FBORN.GT.FBORNFRIC).OR.(FSTE.GT.FSTEFRIC)
     &              .OR.(ABS(FAB).GT.ABS(FABFRIC)))
          H = H + 1.0E-12
          CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                    A22,A33,AC1C1,AC2C2,VDWMODE)
          CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
          CALL FORCEAB (PI,AP,ASP0,NASP0,RMODE0,LAMBDAAB,
     &                    GAMMA0AB,H,H0,FAB)
          HFRIC = H
      ENDDO

C     CALCULATE HMIN - SEPARATION DISTANCE AT WHICH WE CONSIDER MAXIMUM DEFORMATION TO BE ACHIEVED. SEPARATION DISTANCES SMALLER THAN THIS VALUE CONTINUE
C                      TO HAVE MAXIMUM DEFORMATION. WE DEFINE THIS VALUE TO BE THE LOCATION OF THE ENERGY MINIMUM (CALCULATED FOR SMOOTH SURFACES) FOR ALL
C                      ATTRACTIVE INTERACTIONS WITH BORN AS THE BACKSTOP
      H = H0
      FCOLL = 1.0
      DO WHILE (FCOLL.GT.0.0)
          HMIN = H
          H = H + 1.0E-12
          CALL FORCEVDW (A132,AP,ASP0,NASP0,RMODE0,H,LAMBDAVDW,
     &                    A11,A22,A33,AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)
          CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETACST,
     &                    ZETAPST,AP,ASP0,NASP0,RMODE0,H,PI,FEDL)
          CALL FORCEAB (PI,AP,ASP0,NASP0,RMODE0,LAMBDAAB,
     &                    GAMMA0AB,H,H0,FAB)
          CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                    A22,A33,AC1C1,AC2C2,VDWMODE)
          IF (FVDW.GT.0.0) THEN
              FVDW = 0.0
          ENDIF
          IF (FEDL.GT.0.0) THEN
              FEDL = 0.0
          ENDIF
          IF (FAB.GT.0.0) THEN
              FAB = 0.0
          ENDIF
          FCOLL = FVDW + FEDL + FAB + FBORN
      ENDDO
      
C     SET COEFFICIENTS FOR UNIVERSAL HYDRODYNAMIC FUNCTIONS -UPDATED- 2017
      A1 = 0.9267             !FROM MASLIYAH & BHATTACHARJEE 2005
      B1 = -0.3990
      C1 = 0.1487
      D1 = -0.601
      E1 = 1.202

      A2 = 0.5695             !FROM MASLIYAH & BHATTACHARJEE 2005
      B2 = 1.355
      C2 = 1.36
      D2 = 0.875
      E2 = 0.525

      A3 = 0.2803             !FIT FROM GCB 1967 (SEE SPREADSHEET)
      B3 = -0.1430
      C3 = 1.472
      D3 = -0.6772
      E3 = 2.765

      A4 = 0.2607             !FIT FROM GCB 1967 (SEE SPREADSHEET)
      B4 = -0.3015
      C4 = 0.9006
      D4 = -0.5942
      E4 = 1.292
      
C     SET NUMBER OF PARTICLES TO 1 IF IN PARALLEL VERSION
      IF (CLUSTER.EQ.1) THEN
          NPARTLOOP = 1
C         MC read number of particles and ID of particle as a program argument for the cluster version    
          call getarg(1,argv)
          read(argv,*)npart
          call getarg(2,argv)
          read(argv,*)ipart
      ELSE          
          NPARTLOOP = NPART
      ENDIF      

      IF (CLUSTER.EQ.0) THEN
C	    **************** OPEN THREE FLUX FILES FOR SINGLE CORE VERSION *********************************
C	    OPEN HAPHETFLUXEX.OUT FOR OUTPUT
          OPEN (UNIT=21,FILE='FLUXEX.OUT',STATUS='REPLACE')

C	    OPEN HAPHETFLUXATT.OUT FOR OUTPUT
          OPEN (UNIT=22,FILE='FLUXATT.OUT',STATUS='REPLACE')

C	    OPEN HAPHETFLUXREM.OUT FOR OUTPUT
	    OPEN (UNIT=23,FILE='FLUXREM.OUT',STATUS='REPLACE')
C	    **************** END OPEN THREE FLUX FILES FOR SINGLE CORE VERSION *****************************

C         **************** WRITE FLUX HEADERS FOR SINGLE CORE VERSION ************************************
C         EXIT FLUX FILE, UNIT=21
          WRITE (21,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (21,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
          WRITE (21,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (21,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2    
          WRITE (21,110)
          WRITE (21,206)

C         ATTACHMENT FLUX FILE, UNIT=22
          WRITE (22,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (22,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
          WRITE (22,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (22,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2   
          WRITE (22,110)
          WRITE (22,206)

C         REMAINING FLUX FILE, UNIT=23
          WRITE (23,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (23,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
          WRITE (23,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (23,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2     
          WRITE (23,110)
          WRITE (23,206)
C         **************** END WRITE FLUX HEADERS FOR SINGLE CORE VERSION ********************************
      ENDIF

	IF (CLUSTER.EQ.1) THEN
C         **************** OPEN SIX OUTPUT FILES FOR PARALLEL VERSION ************************************
C         THESE NEED TO BE OPENED OUTSIDE THE LOOP TO AVOID MULTIPLE UNITS BEING WRITTEN TO SIMULTANEOUSLY 
C         REMOVE THE !! FROM THE LINES IN THE LINES IN THE SECTION BELOW FOR THE CLUSTER VERSION

C         OPEN HAPHETTRAJEX.OUT FOR OUTPUT
          filenam='HAPHETTRAJEX.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=11,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETTRAJATT.OUT FOR OUTPUT
          filenam='HAPHETTRAJATT.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=12,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETTRAJREM.OUT FOR OUTPUT
          filenam='HAPHETTRAJREM.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=13,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETFLUXEX.OUT FOR OUTPUT
          filenam='HAPHETFLUXEX.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=21,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETFLUXATT.OUT FOR OUTPUT
          filenam='HAPHETFLUXATT.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=22,FILE=filenam,STATUS='REPLACE')

C	    OPEN HAPHETFLUXREM.OUT FOR OUTPUT
          filenam='HAPHETFLUXREM.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=23,FILE=filenam,STATUS='REPLACE')
C         **************** END OPEN SIX OUTPUT FILES FOR PARALLEL VERSION ********************************
      END IF

C     ******************** LOOP THROUGH PARTICLES ********************************************************  
      DO J = 1,NPARTLOOP

        IF (CLUSTER.EQ.0) THEN
          ipart = J	
C         OPEN ATTACHED PARTICLES FLUX FILE TO OBTAIN ATTAHMENT LOCATIONS TO SET INITIAL POSITION OF PARTICLES
          IF (ATTMODE.EQ.-1) THEN
              OPEN(99,file="FLUXATT.IN",status="OLD")
          ENDIF

C         **************** OPEN THREE TRAJECTORY FILES FOR SINGLE CORE VERSION ***************************
C         OPEN HAPHETTRAJEX.OUT FOR OUTPUT
1001      FORMAT ('HAPHETTRAJEX.',I0,'.OUT')
          WRITE(FILESINGLE,1001) J
          OPEN (UNIT=11,FILE=FILESINGLE,STATUS='REPLACE')

C         OPEN HAPHETTRAJATT.OUT FOR OUTPUT
1002      FORMAT ('HAPHETTRAJATT.',I0,'.OUT')
          WRITE(FILESINGLE,1002) J
          OPEN (UNIT=12,FILE=FILESINGLE,STATUS='REPLACE')

C         OPEN HAPHETTRAJATT.OUT FOR OUTPUT
1003      FORMAT ('HAPHETTRAJREM.',I0,'.OUT')
          WRITE(FILESINGLE,1003) J
          OPEN (UNIT=13,FILE=FILESINGLE,STATUS='REPLACE')
C         **************** END OPEN THREE TRAJECTORY FILES FOR SINGLE CORE VERSION ***********************
        ENDIF

C       ****************** WRITE TRAJECTORY HEADERS ******************************************************
C       EXIT TRAJECTORY FILE, UNIT=11
        WRITE (11,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
        WRITE (11,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
        WRITE (11,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
        WRITE (11,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2     

C       ATTACHMENT TRAJECTORY FILE, UNIT=12
        WRITE (12,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
        WRITE (12,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
        WRITE (12,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
        WRITE (12,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2     

C       REMAINING TRAJECTORY FILE, UNIT=13
        WRITE (13,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
        WRITE (13,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
        WRITE (13,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
        WRITE (13,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2     
C       ****************** END WRITE TRAJECTORY HEADERS **************************************************

        IF (CLUSTER.EQ.1) THEN
C         **************** WRITE FLUX HEADERS FOR PARALLEL VERSION ***************************************
C         EXIT FLUX FILE, UNIT=21
          WRITE (21,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (21,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
          WRITE (21,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (21,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2     
          WRITE (21,110)
          WRITE (21,206)

C         ATTACHMENT FLUX FILE, UNIT=22
          WRITE (22,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (22,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
          WRITE (22,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (22,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2     
          WRITE (22,110)
          WRITE (22,206)

C         REMAINING FLUX FILE, UNIT=23
          WRITE (23,101) NPART,Q,ZLIM,RPAR,REXIT,ZMAX,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (23,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT
          WRITE (23,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                    SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (23,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
          WRITE (23,110)
          WRITE (23,206)
C         **************** END WRITE FLUX HEADERS FOR PARALLEL VERSION ***********************************
        ENDIF

C       ****************** WRITE FORMAT FOR OUTPUT FILES *************************************************
C       COMMON HEADERS FOR BOTH FLUX AND TRAJECTORY FILES
101     FORMAT ('NPART= ',I6,2X,' Q(m/s)= ',E15.8,2X,
     &        'ZLIM(m)= ',E15.8,2X,'RPAR(m)= ',E15.8,2X,
     &        'REXIT(m)= ',E15.8,2X,'ZMAX(m)= ',E15.8,2X,
     &        'TTIME(s)= ',E15.8,2X,'ATTMODE= ',I2,2X,
     &        'SLIP(m)= ',E15.8,2X,'RMODE= ',I2,2X,
     &        'ASP(m)= ',E15.8,2X,'ASP2(m)= ',E15.8)
102     FORMAT ('AP(m)= ',E15.8,2X,'IS(mol/m3)= ',E15.8,2X,
     &        'ZI= ',E15.8,2X,'ZETAPST(V)= ',E15.8,2X,
     &        'ZETACST(V)= ',E15.8,2X,'RHOP(kg/m3)= ',E15.8,2X,
     &        'RHOW(kg/m3)= ',E15.8,2X,'VISC(kg/m/s)= ',E15.8,2X,
     &        'ER= ',E15.8,2X,'T(K)= ',E15.8,2X,
     &        'DIFFSCALE= ',E15.8,2X,'GRAVFACT= ',E15.8)
103     FORMAT ('SCOV= ',E15.8,2X,'ZETAHET(V)= ',E15.8,2X,
     &        'HETMODE= ',I1,2X,'RHET0(m)= ',E15.8,2X,
     &        'RHET1(m)= ',E15.8,2X,'RHET2(m)= ',E15.8,2X,
     &        'SCOVP= ',E15.8,2X,'ZETAHETP(V)= ',E15.8,2X,
     &        'HETMODEP= ',I1,2X,'RHETP0(m)= ',E15.8,2X,
     &        'RHETP1(m)= ',E15.8,2X, 
     &        'RZOIBULK(m)= ',E15.8,2X,'dTMRT(s)= ',E15.8,2X,
     &        'MULTB= ',E15.8,2X,'MULTNS= ',E15.8,2X,'MULTC= ',E15.8,
     &        'VDWMODE= ',I6)
104     FORMAT ('A132(J)= ',E15.8,2X,'LAMBDAVDW(m)= ',E15.8,2X,
     &        'GAMMA0AB(J/m2)= ',E15.8,2X,'LAMBDAAB(m)= ',E15.8,2X,
     &        'GAMMA0STE(J/m2)= ',E15.8,2X,'LAMBDASTE(m)= ',E15.8,2X,
     &        'KINT(N/m2)= ',E15.8,2X,'W132(J/m2)= ',E15.8,2X,
     &        'ACONTMAX(m)= ',E15.8,2X,'BETA= ',E15.8,2X,
     &    'DFACTNS= ',E15.8,2X,'DFACTC= ',E15.8,2X,'A11(J)=',E15.8,2X,
     &	'A22(J)=',E15.8,2X,'A33(J)=',E15.8,2X,'AC1C1(J)=',E15.8,2X,
     &	'AC2C2(J)=',E15.8,2X,'T1(m)=',E15.8,2X,'T2(m)=',E15.8)

C       DEFINE ATTACHK VALUES FOR FLUX FILES
110     FORMAT ('ATTACHK1=EXIT,'
     &          'ATTACHK2=ATTACHED-BY-PERFECT-SINK-OR-TORQUE,'
     &          'ATTACHK3=REMAINING-UNRESOLVED-WHEN-SIMULATION-ENDS,'
     &          'ATTACHK4=TORQUE-WITH-SLOW-MOTION,'
     &          'ATTACHK5=IN-NEAR-SURFACE-WITH-SLOW-MOTION,'
     &          'ATTACHK6=CRASHED')

C       DECLARE ATTACHK VALUE FOR EACH PARTICLE TRAJECTORY FILE
105     FORMAT ('ATTACHK= ',I5)

C       LABEL AND WRITE VARIABLES FOR TRAJECTORY FILES
106     FORMAT ('I',19X,'X',19X,'Y',19X,'R',19X,'Z',19X,'H',19X,
     &        'ETIME',15X,'PTIMEF',14X,'FCOLL',15X,'FVDW',16X,
     &        'FEDL',16X,'FAB',17X,'FSTE',16X,'FBORN',15X,'UT',18X,
     &        'UN',18X,'VT',18X,'VN',18X,'FDRGT',15X,'FDRGN',15X,
     &        'FDIFX',15X,'FDIFY',15X,'FDIFZ',15X,'FG',18X,'FLIFT',15X,
     &        'ACONT',15X,'RZOI',16X,'AFRACT')
107     FORMAT (I15.15,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8)

C       LABEL AND WRITE VARIABLES FOR FLUX FILES
206     FORMAT ('PARTICLE',3X,'ATTACHK',1X,'XINIT(m)',12X,
     &        'YINIT(m)',12X,'RINIT(m)',12X,'ZINIT(m)',12X,
     &        'HINIT(m)',12X,'XOUT(m)',13X,'YOUT(m)',13X,'ROUT(m)',13X,
     &        'ZOUT(m)',13X,'HOUT(m)',13X,'ETIME(s)',12X,
     &        'PTIMEIN(s)',10X,'PTIMEOUT(s)',9X,'TBULK(s)',12x,
     &        'TNEAR(s)',12x,'TFRIC(s)',12x,'NSVISIT',13X,
     &        'FRICVISIT',11X,'ACONT(m)',12x,'RZOI(m)',13X,'AFRACT',14X,
     &        'HETTYPE',1X,'HETFLAG',1X,
     &        'NSVEL(m/s)',10X,'HAVE(m)')
207     FORMAT (I6.6,5X,I1,7X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,I15,5X,
     &          I15,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          I1,5X,I1,7X,E15.8,5X,E15.8)
C       ****************** END WRITE FORMAT FOR OUTPUT FILES *********************************************
      
C       INITIALIZE RANDOM NUMBER GENERATOR SEED
        RMULT = 7654321
        CALL init_random_seed()
        
C       SET INITIAL LOCATION AND PARAMETERS DEPENDENT ON MODE OF PERFECT-SINK/TORQUE OR PERTURBATION
        IF (ATTMODE.EQ.-1) THEN !PERTURBATION
C           SET INITIAL PARTICLE TIME TO BE 0
            PTIMEF = 0
C           COLLOID STARTS IN CONTACT
            dT = MULTC*dTMRT
            HFLAG = 3
C           FIND ATTACHED PARTICLE POSITION IN FLUX FILE , THIS STRUCTURE WORKS FOR BOTH CLUSTER AND SINGLE CORE VERSION (J = ipart set above)
            DO I=1,6 !SKIP HEADER
              READ (99,*)DUMMY
            ENDDO
            DO I=1,J
              IF (I.EQ.J) THEN
                READ(99,*) DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,
     &                    XINIT,YINIT,RINIT,ZINIT,HINIT,DUMMY,DUMMY,
     &                    DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,ACONT,
     &                    DUMMY,DUMMY,DUMMY,DUMMY,DUMMY
                X = XINIT
                Y = YINIT
                R = RINIT
                Z = ZINIT
                H = HINIT
              ELSE
                !SKIP PREVIOUS PARTICLES
                READ (99,*) DUMMY
              ENDIF  
            END DO
C           CALCULATE FLUID VELOCITY COMPONENTS AND SET COLLOID NORMAL VELOCITY
            CALL PARFF (R,Z,Q,RPAR,ZMAX,B,VISC,VR,VZ)
            UZ = 0.0
        ELSE !PERFECT SINK OR CONTACT MODE
C           SET INITIAL PARTICLE TIME (EVENLY DISTRIBUTED THROUGH TIME FOR FLUX) SET MAXIMUM INJECTION TIME 1/6 OF TOTAL SIMULATION TIME
            PTIMEF = (ipart-1)*TINJ/NPART
C           COLLOID STARTS IN BULK
            dT = MULTB*dTMRT
            HFLAG = 1
            ACONT = 0.0
C           INITIALIZE LOCATION OF PARTICLES
            CALL INITIAL (ZLIM,AP,ASP,RMODE,ZMAX,
     &                    YPAR,YINIT,RINIT,ZINIT,HINIT)
            Y = YINIT
            R = RINIT
		  XINIT = RINIT
		  X = XINIT
            Z = ZINIT
            H = HINIT
C           CALCULATE FLUID VELOCITY COMPONENTS AND SET COLLOID NORMAL VELOCITY
            CALL PARFF (R,Z,Q,RPAR,ZMAX,B,VISC,VR,VZ)
            UZ = VZ
        ENDIF !(ATTMODE.EQ.-1)
        
C       INITIALIZE VELOCITIES
        UX = 0.0
        UY = 0.0
        UR = 0.0
        OMEGA = 0.0

C       CALCULATE RZOI AND RZOIAB
        RZOI = (ACONT**2+2/KAPPA*(AP+(AP**2-ACONT**2)**0.5))**0.5
        RZOIAB = (ACONT**2+2*LAMBDAAB*(AP+(AP**2-ACONT**2)**0.5))**0.5
C       CALCULATE THE NUMBER OF ASPERITIES IN EACH ZOI
        NASP = 0.0
        NASPAB = 0.0
        ASPLIM = 0.5*(PI**0.5)*RZOI
        ASPLIMAB = 0.5*(PI**0.5)*RZOIAB
        IF (RMODE.GT.0) THEN
            IF (ASP.GT.ASPLIM) THEN
                NASP = 1.0
            ELSE
                NASP = (RZOI**2/ASP**2)*(PI/4)
            ENDIF
            IF (ASP.GT.ASPLIMAB) THEN    
                NASPAB = 1.0
            ELSE
                NASPAB = (RZOIAB**2/ASP**2)*(PI/4)
            END IF
        END IF
C       CALCULATE FORCES FOR INITIAL POSITION FOR FIRST TRAJECTORY POINT
        CALL FORCEVDW (A132,AP,ASP,NASP,RMODE,H,LAMBDAVDW,A11,A22,A33,
     &                    AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)

C       FAVORABLE CONDITIONS IF BULK ZETAC AND ZETAP ARE OPPOSITE IN SIGN, THEN SET SCOV = 0.0 AND SCOVP = 0.0
        IF (((ZETACST.GE.0.0).AND.(ZETAPST.LE.0.0)).OR.
     &      ((ZETACST.LE.0.0).AND.(ZETAPST.GE.0.0))) THEN
            SCOV = 0.0
            SCOVP = 0.0
        END IF
C       CALCULATE PROJECTION MATRIX FOR HETEROGENEITY ON COLLOID
        IF ((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)) THEN
C         HETEROGENEITY ON COLLOID SUBROUTINE TO DETERMINE HETERODOMAIN PROJECTIONS
          CALL HETTRACKP(X,Y,Z,RZOIBULK,AP,HETMODEP,SCOVP,RHETP0,
     &                   RHETP1,NHETP,XHETP,YHETP,ZHETP,RHETP,THETAP,
     &                   PHIP,NPRO,XPRO,YPRO,RPRO)
C         PROJECTION MATRIX FOR HETERODOMAINS ON COLLOID
          IF (NPRO.EQ.0) THEN
              NPRO = 1
              ALLOCATE(M_PRO(NPRO,3))
              M_PRO = 0.0
          ELSE
              ALLOCATE(M_PRO(NPRO,3))
              CALL PROJECTION_MATRIX(NPRO,XPRO,YPRO,RPRO,M_PRO)
          END IF
        END IF
C       CALCULATE HETERODOMAINS INFLUENCE 
        IF (((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(HFLAG.GT.1)) THEN
C         HETEROGENEITY ON COLLECTOR SUBROUTINE TO DETERMINE CLOSEST HETERODOMAIN TO COLLOID
          IF (SCOV.GT.0.0) THEN
              CALL HETTRACK(X,Y,Xm0,Ym0,RZOIBULK,RPAR,YPAR,HETMODE,SCOV,
     &                      RHET0,RHET1,RHET2,XHET,YHET,RHET)
          ELSE
              XHET = 0.0
              YHET = 0.0
              ZHET = 0.0
          ENDIF
C         INITIALIZE FRACTIONAL AREAS
          AFRACT = 0.0       !TOTAL ATTRACTIVE FRACTIONAL AREA
          AFRACT_PZ = 0.0    !PRO-ZOI FRACTIONAL AREA
          AFRACT_ZH = 0.0    !ZOI-HET FRACTIONAL AREA
          AFRACT_PZH = 0.0   !PRO-ZOI-HET FRACTIONAL AREA
          AFRACT_Z = 0.0     !ZOI FRACTIONAL AREA NON-OVERLAPPED
C         CALCULATE OVERLAPING AREA OF HETERODOMAINS AND ZOI
          CALL FRACTIONAL_AREA(X,Y,RZOIBULK,Xm0,Ym0,Zm0,NPRO,M_PRO,
     &                         AF_PZ,AF_ZH,AF_PZH,AF_Z)
          AFRACT = AF_PZ
          AFRACT_PZ = AF_PZ
          DO K=1,HETMODE
              CALL FRACTIONAL_AREA(X,Y,RZOIBULK,XHET(K),YHET(K),RHET(K),
     &                             NPRO,M_PRO,AF_PZ,AF_ZH,AF_PZH,AF_Z)
              AFRACT = AFRACT + AF_ZH               !TOTAL ATTRACTIVE FRACTIONAL AREA
              IF (AF_ZH.GT.0.0) THEN
                  AFRACT = AFRACT - AF_PZH          !TOTAL ATTRACTIVE FRACTIONAL AREA
                  AFRACT_PZ = AFRACT_PZ - AF_PZH    !PRO-ZOI FRACTIONAL AREA
              ENDIF
              AFRACT_ZH = AFRACT_ZH + AF_ZH         !ZOI-HET FRACTIONAL AREA
              AFRACT_PZH = AFRACT_PZH + AF_PZH      !PRO-ZOI-HET FRACTIONAL AREA
              AFRACT_Z = 1 - AFRACT_PZ - AFRACT_ZH - AFRACT_PZH !ZOI FRACTIONAL AREA NON-OVERLAPPED    
          END DO
          !DEALLOCATE(M_PRO)
          IF (AFRACT.GT.0.0) THEN
              !CALCULATE PRO-ZOI ATTRACTIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETACST
              ZETAP = ZETAHETP
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                       ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_PZ = FEDL
              !CALCULATE ZOI-HET ATTRACTIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETAHET
              ZETAP = ZETAPST
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                       ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_ZH = FEDL
              !CALCULATE PRO-ZOI-HET REPULSIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETAHET
              ZETAP = ZETAHETP
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                       ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_PZH = FEDL
              !CALCULATE ZOI REPULSIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETACST
              ZETAP = ZETAPST
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                       ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_Z = FEDL
              !CALCULATE NET EDL FORCE
              FEDL = AFRACT_PZ*FEDL_PZ + AFRACT_ZH*FEDL_ZH + 
     &               AFRACT_PZH*FEDL_PZH + AFRACT_Z*FEDL_Z
          ELSE !(AFRACT.GT.0.0)
              ZETAC = ZETACST
              ZETAP = ZETAPST
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                       ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
          ENDIF !(AFRACT.GT.0.0)
        ELSE !((SCOV.GT.0.0).AND.(HFLAG.GT.1))
          AFRACT = -1.0
          ZETAC = ZETACST
          ZETAP = ZETAPST
          CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                   ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
        END IF !((SCOV.GT.0.0).AND.(HFLAG.GT.1))
        
        CALL FORCEAB (PI,AP,ASP,NASPAB,RMODE,LAMBDAAB,
     &                  GAMMA0AB,H,H0,FAB)
        CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
        CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
        FCOLL = FVDW + FEDL + FAB + FBORN + FSTE
        FDIFX = 0.0
        FDIFY = 0.0
        FDIFZ = 0.0
        CALL GRAVITY(GRAVFACT,AP,G,RHOP,RHOW,PI,FG)
        CALL FORCELIFT (RHOW,Z,AP,VR,UR,OMEGA,FLIFT)
        HBAR = (H+B)/AP !REDUCED RETARDATION DUE TO ROUGHNESS
        FUN2=1.0+B2*EXP(-C2*HBAR)+D2*EXP(-E2*HBAR**A2)
        FUN3=1.0+B3*EXP(-C3*HBAR)+D3*EXP(-E3*HBAR**A3)
        FUN4=1.0+B4*EXP(-C4*HBAR)+D4*EXP(-E4*HBAR**A4)
        CALL FORCEDRAG (FUN2,FUN3,FUN4,M3,VZ,VR,FDRGR,FDRGZ)
          
C       RESTART TRANSLATION AND OUTPUT COUNTERS
        I = 0
        PCOUNT = 1
        OUTCOUNT = 1
        OUTFLAG = 1
        ATTACHK = 0 !INITIALIZE ATTACHK FLAG
        ARRESTFLAG = 0 !USED TO ALLOW COLLOID REACH EQUILIBRIUM SEPARATION DISTANCE
C       RESET STAGNANT PARTICLE INDICATOR
        IREF1 = 0
        IREF2 = 0
C       RESET CUMULATIVE BULK,NEAR-SURFACE, AND FRICTION TIMES
        TBULK = 0.0
        TNEAR = 0.0
        TFRIC = 0.0
        ETIME = 0.0
C       RESET NEAR-SURFACE AND FRICTION VISIT COUNTERS
        NSVISIT = 0
        FRICVISIT = 0
C       RESET AVERAGE SEPARATION DISTANCE AND NEAR-SURFACE VELOCITY PARAMETERS
        L = 0
        HSUM = 0
        HAVE = 0.0
        NSDIST = 0.0
        NSVEL = 0.0
C       EMPTY PROJECTION MATRIX
        IF ((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)) THEN
          DEALLOCATE(M_PRO)
        ENDIF
C       ****************** TRANSLATION LOOP **************************************************************
        DO WHILE (ATTACHK.EQ.0)
C         OUTPUT TO ARRAY
          IF ((PCOUNT.EQ.NOUT).OR.(I.EQ.0)) THEN
              PCOUNT = 0
              IOT(OUTCOUNT) = I
              XOT(OUTCOUNT) = X
              YOT(OUTCOUNT) = Y
              ROT(OUTCOUNT) = R
              ZOT(OUTCOUNT) = Z
              HOT(OUTCOUNT) = H
              ETIMEOT(OUTCOUNT) = ETIME
              PTIMEFOT(OUTCOUNT) = PTIMEF
              FCOLLOT(OUTCOUNT) = FCOLL
              FVDWOT(OUTCOUNT) = FVDW
              FEDLOT(OUTCOUNT) = FEDL
              FABOT(OUTCOUNT) = FAB
              FSTEOT(OUTCOUNT) = FSTE
              FBORNOT(OUTCOUNT) = FBORN
              UTOT(OUTCOUNT) = UR
              UNOT(OUTCOUNT) = UZ
              VTOT(OUTCOUNT) = VR
              VNOT(OUTCOUNT) = VZ
              FDRGTOT(OUTCOUNT) = FDRGR
              FDRGNOT(OUTCOUNT) = FDRGZ
              FDIFXOT(OUTCOUNT) = FDIFX
              FDIFYOT(OUTCOUNT) = FDIFY
              FDIFZOT(OUTCOUNT) = FDIFZ
              FGOT(OUTCOUNT) = FG
              FLIFTOT(OUTCOUNT) = FLIFT
              ACONTOT(OUTCOUNT) = ACONT
              RZOIOT(OUTCOUNT) = RZOI
              AFRACTOT(OUTCOUNT) = AFRACT
              OUTCOUNT = OUTCOUNT + 1
C             RESET OUTPUT COUNTER TO KEEP STORING NEW VALUE IN THE BEGINNING OF THE ARRAY
C             FLAG THIS EVENT TO OUTPUT ARRAY PROPERLY WHEN TRAJECTORY IS RESOLVED
              IF (OUTCOUNT.GT.OUTMAX) THEN 
                  OUTFLAG = OUTFLAG + 1
C                 IF ARRAY REWRITE OCCURS OUTMAX TIMES, THEN OVERWRITE SECOND 
C                 TO LAST POSITION TO HOLD SPACE FOR FINAL RESOLVED POSITION
                  IF (OUTFLAG.EQ.OUTMAX) THEN
                      OUTFLAG = OUTFLAG - 1
                  END IF
                  OUTCOUNT = OUTFLAG
              END IF   
              IF (CLUSTER.EQ.0) THEN
                  PRINT 6001, J,I,X,H,UR,AFRACT
 6001             FORMAT ('J= ',I6,1X,'I= ',I15,1X,'X= ',E11.4,1X,
     &            'H= ',E11.4,1X,'UR= ',E12.5,1X,'AFRACT= ',E11.4)
              ENDIF
          END IF
          I = I + 1 !COUNT THE NUMBER OF TRANSLATIONS
          PCOUNT = PCOUNT + 1 !COUNT THE NUMBER OF TRANSLATIONS TO OUT
          PTIMEF = PTIMEF + dT !ADD TIME STEP TO TOAL TIME
C         CALCULATE ELAPSED TIME
          ETIME = PTIMEF-PTIMEFOT(1)
C         RECORD PREVIOUS VALUES
          XO = X
          YO = Y
          ZO = Z
C         TRANSLATE PARTICLE
          X = XO + UX*dT
          Y = YO + UY*dT
          Z = ZO + UZ*dT
C         CALCULATE RADIAL DISTANCE (NOT NEEDED IN PARALLEL PLATE) 
C         CALCULATE VERTICAL DEFORMATION AS FUNCTION OF Z
C         EQUATION OF LINE CONNECTING POINTS DELTA=0,Z=AP+HFRIC AND DELTA=DELTAMAX,Z=AP-DELTAMAX+HMIN (ADJUST TO INCLUDE ASPERITIES)
          IF (RMODE.EQ.0) THEN !SMOOTH-SMOOTH INTERACTION
              DELTA = DELTAMAX*(Z-AP-HFRIC)/(HMIN-HFRIC-DELTAMAX)
          ELSE IF ((RMODE.EQ.1).OR.(RMODE.EQ.2)) THEN !SMOOTH-ROUGH INTERACTION
              DELTA = DELTAMAX*(Z-AP-HFRIC-ASP)/(HMIN-HFRIC-DELTAMAX)
          ELSE IF (RMODE.EQ.3) THEN !ROUGH-ROUGH INTERACTION
              DELTA = DELTAMAX*(Z-AP-HFRIC-0.5*(2*ASP+3**0.5*ASP))/
     &                            (HMIN-HFRIC-DELTAMAX)
          END IF
          IF (DELTA.GT.DELTAMAX) THEN
              DELTA = DELTAMAX
          ENDIF
          IF (DELTA.LT.0.0) THEN
              DELTA = 0.0
          ENDIF
C         CALCULATE CONTACT AREA
          ACONT = BETA*SQRT(2.0*AP*DELTA-DELTA**2.0)
          RZOI = (ACONT**2+2/KAPPA*(AP+(AP**2-ACONT**2)**0.5))**0.5
          RZOIAB = (ACONT**2+2*LAMBDAAB*(AP+(AP**2-ACONT**2)**0.5))**0.5
          ASPLIM = 0.5*(PI**0.5)*RZOI
          ASPLIMAB = 0.5*(PI**0.5)*RZOIAB
          IF (RMODE.GT.0) THEN
              IF (ASP.GT.ASPLIM) THEN
                  NASP = 1.0
              ELSE
                  NASP = (RZOI**2/ASP**2)*(PI/4)
              ENDIF
              IF (ASP.GT.ASPLIMAB) THEN    
                  NASPAB = 1.0
              ELSE
                  NASPAB = (RZOIAB**2/ASP**2)*(PI/4)
              END IF
          END IF
          IF (RMODE.EQ.0) THEN !SMOOTH-SMOOTH INTERACTION
              H = Z - AP + DELTA
          ELSE IF ((RMODE.EQ.1).OR.(RMODE.EQ.2)) THEN !SMOOTH-ROUGH INTERACTION
              H = Z - AP + DELTA - ASP
          ELSE IF (RMODE.EQ.3) THEN !ROUGH-ROUGH INTERACTION
              H = Z - AP + DELTA - 0.5*(2*ASP+3**0.5*ASP) !THIRD TERM IS AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH SURFACES FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
          END IF
          
C         INCREMENT BULK OR NEAR SURFACE TRAJECTORY TIME, TRACK PARTICLE TO STUCK INDICATOR IF IN NEAR SURFACE DOMAIN
          IF (H.GT.2.0E-7) THEN
              IF (HFLAG.EQ.2) THEN !Increment time in domain from which particle came
                  TNEAR = TNEAR + dT
                  dT = MULTB*dTMRT !change dT after accumulating timestep from near surface
                  HFLAG = 1 !flag particle in bulk
                  !ACCUMULATE DISTANCE TRAVELED IN NEAR SURFACE VISIT
                  IF(IREF1.GT.200) THEN
                  NSDIST = NSDIST+((X-XENTER)**2.0+(Y-YENTER)**2.0)**0.5
                  !CALCULATE AVERAGE NEAR SURFACE VELOCITY
                  NSVEL = NSDIST/TNEAR
                  ENDIF
                  IREF1 = 0 !reset IREF1 if particle leaves near surface
              ELSE IF (HFLAG.EQ.1) THEN
                  TBULK = TBULK+dT
              END IF  
          ELSE IF ((H.LE.2.0E-7).AND.(H.GT.HFRIC)) THEN !H IS IN NEAR SURFACE
              IF (HFLAG.EQ.1) THEN !particle is coming from bulk
                  TBULK = TBULK + dT
                  dT = MULTNS*dTMRT !change dT after accumulating timestep from bulk
                  HFLAG = 2 !flag particle in near surface
                  NSVISIT = NSVISIT + 1 !COUNT NUMBER OF VISITS TO NEAR SURFACE FROM BULK
                  !SET ENTRANCE COORDINATES TO NEAR SURFACE FOR CALCULATING AVERAGE VELOCITY
                  XENTER = X
                  YENTER = Y
              ELSE IF (HFLAG.EQ.3) THEN !particle is coming from friction
                  TFRIC = TFRIC + dT
                  dT = MULTNS*dTMRT !change dT after accumulating timestep from friction
                  HFLAG = 2 !flag particle in near surface
                  IREF2 = 0 !reset friction IREF
                  !SET ENTRANCE COORDINATES TO NEAR SURFACE FOR CALCULATING AVERAGE VELOCITY
                  XENTER = X
                  YENTER = Y
              ELSE IF (HFLAG.EQ.2) THEN !particle is coming from near surface
                  TNEAR = TNEAR + dT !NEAR SURFACE RESIDENCE TIME
C                 NUMBER OF CONSECUTIVE TIME STEPS IN NEAR SURFACE
                  L = L+1
C                 CALCULATE AVERAGE NEAR-SURFACE SEPARATION DISTANCE
                  HSUM = H + HSUM
                  HAVE = HSUM/L
              END IF
           
              IF (IREF1.EQ.0) THEN !IDENTIFY REFERENCE POINT AND TIME
                  XREF1 = X 
                  YREF1 = Y
                  ZREF1 = Z
                  TREF1 = 0.0
                  IREF1 = 1
              ELSE
                  IREF1 = IREF1 + 1
                  TREF1 = TREF1 + dT
                  IF (IREF1.GT.1000) THEN 
                      DREF1 = ((X-XREF1)*(X-XREF1)+(Y-YREF1)*
     &                    (Y-YREF1)+(Z-ZREF1)*(Z-ZREF1))**0.5 !COMPARE REFERENCE DISTANCE TO DIFFUSION ONLY DISPLACEMENT 
                      IF (VZ.GT.VR) THEN
                          DCOEF = FUN1
                      ELSE
                          DCOEF = FUN4
                      END IF
                      DIND3 = (6.0*DCOEF*KB*T*TREF1/M3)**0.5
                      DIND1 = DFACTNS*(6.0*DCOEF*KB*T*TREF1/M3)**0.5 !SCALE DISPLACEMENT TO DIFFUSION (WITHOUT DIFFSCALE)
                      IF ((DREF1.LT.DIND1).AND.(H.GT.5*HFRIC)) THEN 
                          ATTACHK = 5 !RETENTION WITHOUT CONTACT IN NEAR SURFACE
                      ELSE
                          IREF1 = 0
                      END IF
                  END IF !IF IREF.GT.1000
              END IF !IF IREF1.EQ.0

          ELSE IF ((H.LE.2.0E-7).AND.(H.LE.HFRIC)) THEN !particle is in friction
              IF (HFLAG.EQ.2) THEN
                  TNEAR = TNEAR + dT
                  dT = MULTC*dTMRT !change dT after accumulating timestep from near surface
                  HFLAG = 3 !flag particle in friction
                  !ACCUMULATE DISTANCE TRAVELED IN NEAR SURFACE VISIT
                  NSDIST = NSDIST + 
     &                    ((X-XENTER)**2.0+(Y-YENTER)**2.0)**0.5
                  !CALCULATE AVERAGE NEAR SURFACE VELOCITY
                  NSVEL = NSDIST/TNEAR
                  FRICVISIT = FRICVISIT + 1 !count number of visits to friction
              ELSE IF (HFLAG.EQ.3) THEN
                  TFRIC = TFRIC + dT !friction residence time
              END IF
              IF (H.LT.H0) THEN
                  ATTACHK = 6 !Flag if particle runs into surface
              END IF
              IF (ATTMODE.EQ.0) THEN !attachment by perfect sink
                  ATTACHK = 2
              ELSE !TORQUE BALANCE MODE FOR ATTACHMENT AND DETACHMENT
                  IF ((UR.EQ.0.0).AND.(ARRESTFLAG.EQ.1)) THEN !UR=0.0 AND COLLOID HAS REACHED EQUILIBRIUM SEPARATION (FADH~FREP)
                      ATTACHK = 2 !PARTICLE ARRESTS
                  ENDIF
                  IF (IREF2.EQ.0) THEN !IDENTIFY REFERENCE POINT AND TIME
                      XREF2 = X
                      YREF2 = Y
                      ZREF2 = Z
                      TREF2 = 0.0
                      IREF2 = 1
                  ELSE
                      IREF2 = IREF2 + 1
                      TREF2 = TREF2 + dT
                      IF (IREF2.GT.1000) THEN !COMPARE REFERENCE DISTANCE TO DIFFUSION ONLY DISPLACEMENT 
                          DREF2 = ((X-XREF2)*(X-XREF2)+(Y-YREF2)*
     &                        (Y-YREF2)+(Z-ZREF2)*(Z-ZREF2))**0.5
                          IF (VZ.GT.VR) THEN
                              DCOEF = FUN1
                          ELSE
                              DCOEF = FUN4
                          END IF
                          DIND2 = DFACTC*(6.0*DCOEF*KB*T*TREF2/M3)**0.5!SCALE DISPLACEMENT TO DIFFUSION (WITHOUT DIFFSCALE)
                          IF (DREF2.LT.DIND2) THEN 
                              ATTACHK = 4 !RETENTION WITH CONTACT
                          ELSE
                              IREF2 = 0
                          END IF
                      END IF
                  END IF !FOR IF IREF2.EQ.0
              ENDIF !FOR ATTMODE.EQ.0
          ENDIF !FOR H.GT.2.0E-7

C         EXIT CONDITION IF PARTICLE IS IN BULK FLUID
          IF (X.GT.REXIT) THEN
              ATTACHK = 1
          ENDIF
C
C         REFLECTION CONDITIONS IF PARTICLE CROSSES Y=0 OR Y=YPAR OR Z=MAX
          IF (Y.LT.0.0) THEN
              Y=-Y
          ENDIF
		  IF (Y.GT.YPAR) THEN
			  Y=Y-(Y-YPAR)
		  ENDIF
		  IF (Z.GT.ZMAX)THEN
			  Z=Z-(Z-ZMAX)
		  ENDIF
C
C         FINISH TRAJECTORY IF PARTICLE STILL IN THE SYSTEM WHEN TOTAL TIME IS REACHED (NO STAGNANT)
          IF (PTIMEF.GT.TTIME) THEN
              ATTACHK = 3
          ENDIF
            
C         CONTINUE FORCE AND INTEGRATION IF PARTICLE IS AQUEOUS
          IF (ATTACHK.EQ.0) THEN

C             DETERMINE FORCES

C             CALCULATE COLLOIDAL FORCE (SPHERE-PLATE GEOMETRY)

C             CALCULATE VDW FORCE
              CALL FORCEVDW (A132,AP,ASP,NASP,RMODE,H,LAMBDAVDW,A11,A22,
     &                     A33,AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)
              
C             CALCULATE EDL
C             FAVORABLE CONDITIONS IF BULK ZETAC AND ZETAP ARE OPPOSITE IN SIGN, THEN SET SCOV = 0.0 AND SCOVP = 0.0
              IF (((ZETACST.GE.0.0).AND.(ZETAPST.LE.0.0)).OR.
     &            ((ZETACST.LE.0.0).AND.(ZETAPST.GE.0.0))) THEN
		        SCOV = 0.0
                  SCOVP = 0.0
              END IF
C             CALCULATE PROJECTION MATRIX FOR HETEROGENEITY ON COLLOID
              IF (((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(I.EQ.1)) THEN
C             HETEROGENEITY ON COLLOID SUBROUTINE TO DETERMINE HETERODOMAIN PROJECTIONS
                  CALL HETTRACKP(X,Y,Z,RZOIBULK,AP,HETMODEP,SCOVP,
     &                           RHETP0,RHETP1,NHETP,XHETP,YHETP,ZHETP,
     &                           RHETP,THETAP,PHIP,NPRO,XPRO,YPRO,RPRO)
C                 PROJECTION MATRIX FOR HETERODOMAINS ON COLLOID
                  IF (NPRO.EQ.0) THEN
                      NPRO = 1
                      ALLOCATE(M_PRO(NPRO,3))
                      M_PRO = 0.0
                  ELSE
                      ALLOCATE(M_PRO(NPRO,3))
                      CALL PROJECTION_MATRIX(NPRO,XPRO,YPRO,RPRO,M_PRO)
                  END IF
              ELSEIF (((SCOV.GT.0.0).OR.(SCOVP.GT.0)).AND.(I.GT.1)) THEN
C                 UPDATE PROJECTION MATRIX FOR HETEROGENEITY ON COLLOID
                  DO IPRO=1,NPRO
                      M_PRO(IPRO,1) = M_PRO(IPRO,1) + (X-XO)
                      M_PRO(IPRO,2) = M_PRO(IPRO,2) + (Y-YO)
                  END DO
              END IF
C             CALCULATE HETERODOMAINS INFLUENCE 
              IF (((SCOV.GT.0.0).OR.(SCOVP.GT.0)).AND.(HFLAG.GT.1)) THEN
C                 HETEROGENEITY ON COLLECTOR SUBROUTINE TO DETERMINE CLOSEST HETERODOMAIN TO COLLOID
                  IF (SCOV.GT.0.0) THEN
                      CALL HETTRACK(X,Y,Xm0,Ym0,RZOIBULK,RPAR,YPAR,
     &                              HETMODE,SCOV,RHET0,RHET1,RHET2,XHET,
     &                              YHET,RHET)
                  ELSE
                      XHET = 0.0
                      YHET = 0.0
                      ZHET = 0.0
                  ENDIF
C                 INITIALIZE FRACTIONAL AREAS
                  AFRACT = 0.0       !TOTAL ATTRACTIVE FRACTIONAL AREA
                  AFRACT_PZ = 0.0    !PRO-ZOI FRACTIONAL AREA
                  AFRACT_ZH = 0.0    !ZOI-HET FRACTIONAL AREA
                  AFRACT_PZH = 0.0   !PRO-ZOI-HET FRACTIONAL AREA
                  AFRACT_Z = 0.0     !ZOI FRACTIONAL AREA NON-OVERLAPPED
C                 INITIALIZE HETTYPE COLLECTOR
                  HETTYPE = 0.0
C                 CALCULATE OVERLAPING AREA OF HETERODOMAIN AND ZOI
                  CALL FRACTIONAL_AREA(X,Y,RZOIBULK,Xm0,Ym0,Zm0,NPRO,
     &                                M_PRO,AF_PZ,AF_ZH,AF_PZH,AF_Z)
                  AFRACT = AF_PZ
                  AFRACT_PZ = AF_PZ
                  DO K=1,HETMODE
                      CALL FRACTIONAL_AREA(X,Y,RZOIBULK,XHET(K),YHET(K),
     &                                RHET(K),NPRO,M_PRO,AF_PZ,AF_ZH,
     &                                AF_PZH,AF_Z)
                      AFRACT = AFRACT + AF_ZH               !TOTAL ATTRACTIVE FRACTIONAL AREA
                      IF (AF_ZH.GT.0.0) THEN
                          AFRACT = AFRACT - AF_PZH          !TOTAL ATTRACTIVE FRACTIONAL AREA
                          AFRACT_PZ = AFRACT_PZ - AF_PZH    !PRO-ZOI FRACTIONAL AREA
                      ENDIF
                      AFRACT_ZH = AFRACT_ZH + AF_ZH         !ZOI-HET FRACTIONAL AREA
                      AFRACT_PZH = AFRACT_PZH + AF_PZH      !PRO-ZOI-HET FRACTIONAL AREA
                      AFRACT_Z = 1 - AFRACT_PZ - AFRACT_ZH - AFRACT_PZH !ZOI FRACTIONAL AREA NON-OVERLAPPEP                  
C                     DETERMINE TYPE OF HETERODOMAIN COLLOID IS OVERLAPPING (NONE=0, LARGE=1, MEDIUM=2, SMALL=3, LARGE AND MEDIUM=4, LARGE AND SMALL=5, MEDIUM AND SMALL=6)
                      IF ((AF_ZH.GT.0.0).AND.(K.EQ.1)) THEN
                          HETTYPE = 1
                      END IF
                      IF ((HETMODE.EQ.5).OR.(HETMODE.EQ.9)) THEN
                          IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.0)
     &                        .AND.(K.GT.1))THEN
                              HETTYPE = 2
                          END IF
                          IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.1)
     &                        .AND.(K.GT.1))THEN
                              HETTYPE = 4
                          END IF
                      ELSEIF (HETMODE.EQ.73) THEN
                          IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.0)
     &                        .AND.(K.GT.1.AND.K.LE.9))THEN
                              HETTYPE = 2
                          END IF
                          IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.0)
     &                        .AND.(K.GT.9))THEN
                              HETTYPE = 3
                          END IF
                          IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.1)
     &                        .AND.(K.GT.1.AND.K.LE.9))THEN
                              HETTYPE = 4
                          END IF
                          IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.1)
     &                        .AND.(K.GT.9))THEN
                              HETTYPE = 5
                          END IF
                          IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.2)
     &                        .AND.(K.GT.9))THEN
                              HETTYPE = 6
                          END IF
                      ENDIF
                  END DO
                  !DEALLOCATE(M_PRO)
                  IF (AFRACT.GT.0.0) THEN
                      HETFLAG = 1 !COLLOID HAS PASSED OVER A HETERODOMAIN
                      !CALCULATE PRO-ZOI ATTRACTIVE CONTRIBUTION TO EDL FORCE
                      ZETAC = ZETACST
                      ZETAP = ZETAHETP
                      CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                               ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
                      FEDL_PZ = FEDL
                      !CALCULATE ZOI-HET ATTRACTIVE CONTRIBUTION TO EDL FORCE
                      ZETAC = ZETAHET
                      ZETAP = ZETAPST
                      CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                               ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
                      FEDL_ZH = FEDL
                      !CALCULATE PRO-ZOI-HET REPULSIVE CONTRIBUTION TO EDL FORCE
                      ZETAC = ZETAHET
                      ZETAP = ZETAHETP
                      CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                               ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
                      FEDL_PZH = FEDL
                      !CALCULATE ZOI REPULSIVE CONTRIBUTION TO EDL FORCE
                      ZETAC = ZETACST
                      ZETAP = ZETAPST
                      CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                               ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
                      FEDL_Z = FEDL
                      !CALCULATE NET EDL FORCE
                      FEDL = AFRACT_PZ*FEDL_PZ + AFRACT_ZH*FEDL_ZH + 
     &                       AFRACT_PZH*FEDL_PZH + AFRACT_Z*FEDL_Z
                  ELSE !(AFRACT.GT.0.0)
                      ZETAC = ZETACST
                      ZETAP = ZETAPST
                      CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                               ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
                  ENDIF !(AFRACT.GT.0.0)
              ELSE !((SCOV.GT.0.0).AND.(HFLAG.GT.1))
                  ZETAC = ZETACST
                  ZETAP = ZETAPST
                  CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,
     &                           ZETAP,AP,ASP,NASP,RMODE,H,PI,FEDL)
              END IF !((SCOV.GT.0.0).AND.(HFLAG.GT.1))
              
C             CALCULATE ACID-BASE, BORN, AND STERIC REPULSION
              CALL FORCEAB (PI,AP,ASP,NASPAB,RMODE,LAMBDAAB,
     &                  GAMMA0AB,H,H0,FAB)
              CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
              CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
              
              FCOLL = FVDW + FEDL + FAB + FBORN + FSTE

C             CALCULATE NON-COLLOIDAL FORCES (DRAG,DIFFUSION,GRAVITY,LIFT)

C             CALCULATE DRAG FORCE
C             CALCULATE FLUID VELOCITY AT GIVEN LOCATION BEFORE CALCULATING DRAG FORCE
              CALL PARFF (R,Z,Q,RPAR,ZMAX,B,VISC,VR,VZ)
C             UNIVERSAL HYDRODYNAMIC FUNCTIONS
              HBAR = (H+B)/AP!REDUCED RETARDATION DUE TO ROUGHNESS
              FUN1=1.0+B1*EXP(-C1*HBAR)+D1*EXP(-E1*HBAR**A1)
              FUN2=1.0+B2*EXP(-C2*HBAR)+D2*EXP(-E2*HBAR**A2)
              FUN3=1.0+B3*EXP(-C3*HBAR)+D3*EXP(-E3*HBAR**A3)
              FUN4=1.0+B4*EXP(-C4*HBAR)+D4*EXP(-E4*HBAR**A4)
C             AXIAL AND RADIAL DRAG FORCES ARE CALCULATED WITH CORRECTED FUN2 AND FUN3 IN THE SUBROUTINE
              CALL FORCEDRAG (FUN2,FUN3,FUN4,M3,VZ,VR,FDRGR,FDRGZ)

C             CALCULATE DIFFUSION FORCE
              CALL FORCEDIFF(DIFFSCALE,PI,VISC,AP,KB,T,dT,
     &                       FDIFX,FDIFY,FDIFZ)
              IF (H.LE.HFRIC) THEN
C                 DIFFUSION FORCES EQUAL TO ZERO IN CONTACT 
                  FDIFX=0.0
                  FDIFY=0.0
                  FDIFZ=0.0
              END IF

C             CALCULATE GRAVITATIONAL FORCE  
              CALL GRAVITY(GRAVFACT,AP,G,RHOP,RHOW,PI,FG)

C             CALCULATE LIFT FORCE
              CALL FORCELIFT (RHOW,Z,AP,VR,UR,OMEGA,FLIFT)

C             DRIVING DRAG FORCES
			  FDRGX = FDRGR
			  FDRGY = 0.0
C
C             INTEGRATE
C             INTEGRATION ADDS AN EXTRA TERM TO ACCOUNT FOR FLOW DISTURBANCE DUE TO PRESENCE OF STATIONARY PARTICLE,
C             REF. MA ET AL. 2009 SI -Hemispheres-in-cell geometry to predict colloid deposition in porous media 
C             INTEGRATE NORMAL AND TANGENTIAL(x,y,z) FORCES TO PARTICLE VELOCITIES
C
C             STEADY STATE FORMULATION FOR DEBUGGING
!        	    UNX = (FUN1/M3)*(FGNX+FCOLLX+FDIFNX+FLIFTX+FDRGNX)
!        	    UNY = (FUN1/M3)*(FGNY+FCOLLY+FDIFNY+FLIFTY+FDRGNY)
!        	    UNZ = (FUN1/M3)*(FGNZ+FCOLLZ+FDIFNZ+FLIFTZ+FDRGNZ)
!C
!             UTX = (FUN4*(FGTX+FDIFTX)+FDRGTX)/M3
!             UTY = (FUN4*(FGTY+FDIFTY)+FDRGTY)/M3
!             UTZ = (FUN4*(FGTZ+FDIFTZ)+FDRGTZ)/M3

C             SAVE VELOCITIES FROM PREVIOUS TIME STEP 
              UXO = UX
              UYO = UY
              UZO = UZ

C             INTEGRATION UTILIZING AN IMPLICIT APPROACH, I.E., RESISITNG DRAG PARTICLE VELOCITY CORRESPONDS
c             TO THE FUTURE LOCATION WHILE FORCES CORRESPOND TO ACTUAL LOCATION.
C             EXPLICIT APPROACH WAS DISCARDED BECAUSE THE MODEL BECOMES UNSTABLE AND EXTREMELY DEPENDENT ON dT

        	    UZ = ((MP+VM)*UZO+(FG+FCOLL+FDIFZ+FLIFT+FDRGZ)*dT)/ !should we subject axial velocity to surface friction rather than just fluid viscosity
     &             (MP+VM+M3*dT/FUN1)
              
C             TANGENTIAL VELOCITY FROM MA ET AL. 2009 EQUATION S14
              IF (H.GT.HFRIC) THEN
                  UX = ((MP+VM)*UXO+(FDIFX+FDRGX)*dT)/
     &                 (MP+VM+M3*dT/FUN4)
                  UY = ((MP+VM)*UYO+(FDIFY+FDRGY)*dT)/
     &                 (MP+VM+M3*dT/FUN4)
C                 TANGENTIAL VELOCITY IS NEGATIVE IF THE VELOCITY VECTOR POINTS
C                         TOWARD THE ENTRY PLANE
                  UR = SIGN((UX*UX+UY*UY)**0.5,UX)
C                 FIT OMEGA*AP/UR AS FUNCTION OF H/AP USING GCB 1967b TABLES 2&3
                  OMEGA = ABS(UR)/AP*(0.5518+117.4*(H/AP))/
     &                    (1+232.1*(H/AP)+237.7*(H/AP)**2.0)
              END IF

C             INTEGRATION IF PARTICLE IS IN CONTACT
              IF (H.LE.HFRIC)THEN
                  
C                 CALCULATE NORMAL ADHESIVE AND REPULSIVE FORCES FOR RESISTING TORQUE
                  FADH = FVDW + FEDL + FG + FLIFT + FDRGZ
                  FREP = FBORN
                  IF (FAB.LT.0.0) THEN
                      FADH = FADH + FAB
                  ELSE
                      FREP = FREP + FAB
                  END IF
                  IF (FSTE.LT.0.0) THEN
                      FADH = FADH + FSTE
                  ELSE
                      FREP = FREP + FSTE
                  END IF
                  IF (FADH.GT.0.0) THEN
                      FADH = 0.0;
                  ELSE
C                     SINCE ATTRACTIVE FORCES ARE NEGATIVE IN SIGN, FLIP THE SIGN OF FADH TO MAKE IT POSITIVE
                      FADH = -FADH;                     
                  END IF   
                  
C                 CALCULATE ADHESIVE TORQUE LEVER ARM
                  RLEV = AP*ASP2/(AP+ASP2)
                  IF (RLEV.LE.ACONT) THEN
                      RLEV = ACONT !LARGER RESISTING LEVER ARM DUE TO DEFORMATION THAN ROUGHNESS
                  ENDIF

C                 FORCE AND TORQUE COMPONENTS FROM GCB 1967A/B AS H/AP GOES TO 0
                  FSHRT = 1.7005
                  TSHRY = 0.9440
                  FTRT = (8.0/15.0)*LOG(H/AP)-0.9588
                  FROT = -(2.0/15.0)*LOG(H/AP)-0.2526	
                  TTRY = -(1.0/10.0)*LOG(H/AP)-0.1895
                  TROY = (2.0/5.0)*LOG(H/AP)-0.3817

C                 INTEGRATE TANGENTIAL VELOCITY
C                 By ignoring FG AND FDIFF TANGENTIAL, the influence of gravity and Brownian motion are ignored. 
C                 However we need to do this because determining the direction in the tangential axis is not straight forward.
C                 This is a point for future exploration
                  URO = (UXO*UXO+UYO*UYO)**0.5

C                 THE TERM IN THE VELOCITY INTEGRATION APPEAR ALL POSITIVE, RESISTING FORCES AND TORQUES NEGATIVE SIGN IS DETERMINED BY THE 
C                 DIMENSIONLESS HYDRODYNAMIC CORRECTION FACTOR CALCULATED ABOVE, THE NORMAL FORCE MUST BE NEGATIVE (ATTRACTIVE) FOR ADHESION TO OCCUR (EQUAL TO ATTRACTIVE COLLOIDAL FORCES)
C                 TANGENTIAL VELOCITY FROM MA ET AL. 2011 EQUATION S6 - NOTE THAT MISTAKES ARE CORRECTED
                  UR = (1.4*(MP+VM)*URO
     &                     -FADH*RLEV/AP*(AP-DELTA)/AP*dT
     &                     +6.0*PI*VISC*(AP-DELTA)*VR*dT*
     &                      (FSHRT+2.0/3.0*AP/(H+AP)*TSHRY))
     &                 /(1.4*(MP+VM)-6.0*PI*VISC*(AP-DELTA)*dT*
     &                       (FTRT+FROT+4.0/3.0*(TTRY+TROY)))
C                 ASSIGN NEGATIVE TANGENTIAL VELOCITY AS ZERO
                  IF (UR.LT.0.0) THEN
                      UR = 0.0
                      ARRESTFLAG = 1
                  ENDIF
C                 RESET ARRESTFLAG IF COLLOID IS NOT IN EQUILIBRIUM
                  IF ((FADH.LT.0.995*FREP).OR.
     &                        (FADH.GT.1.005*FREP)) THEN
                      ARRESTFLAG = 0
                  ENDIF
C                 ATTRIBUTE ALL UR TO UX SINCE NO DIFFUSION IN CONTACT?
  			    UX = UR
			    UY = 0.0
C                 NO SLIP SO OMEGA*AP/UR=1
                  OMEGA = UR/(AP-DELTA)
              END IF !(H.LT.HFRIC)
C
          ELSE !ATTACHK.GT.0
C             STORE FINAL TRAJECTORY VALUES
              ETIME = PTIMEF-PTIMEFOT(1) !Calculate final elapsed time
              IOT(OUTCOUNT) = I
              XOT(OUTCOUNT) = X
              YOT(OUTCOUNT) = Y
              ROT(OUTCOUNT) = R
              ZOT(OUTCOUNT) = Z 
              HOT(OUTCOUNT) = H
              ETIMEOT(OUTCOUNT) = ETIME
              PTIMEFOT(OUTCOUNT) = PTIMEF
              FCOLLOT(OUTCOUNT) = FCOLL
              FVDWOT(OUTCOUNT) = FVDW
              FEDLOT(OUTCOUNT) = FEDL
              FABOT(OUTCOUNT) = FAB
              FSTEOT(OUTCOUNT) = FSTE
              FBORNOT(OUTCOUNT) = FBORN
              UTOT(OUTCOUNT) = UR
              UNOT(OUTCOUNT) = UZ
              VTOT(OUTCOUNT) = VR
              VNOT(OUTCOUNT) = VZ
              FDRGTOT(OUTCOUNT) = FDRGR
              FDRGNOT(OUTCOUNT) = FDRGZ
              FDIFXOT(OUTCOUNT) = FDIFX
              FDIFYOT(OUTCOUNT) = FDIFY
              FDIFZOT(OUTCOUNT) = FDIFZ
              FGOT(OUTCOUNT) = FG
              FLIFTOT(OUTCOUNT) = FLIFT
              ACONTOT(OUTCOUNT) = ACONT
              RZOIOT(OUTCOUNT) = RZOI
              AFRACTOT(OUTCOUNT) = AFRACT
          END IF !IF ATTACHK.EQ.0
C
        END DO !TRAJECTORY LOOP (ATTACHK=0)
C       WRITE ARRAY TO FILE 

        WRITE (11,105) ATTACHK
        WRITE (11,106)
        WRITE (12,105) ATTACHK
        WRITE (12,106)
        WRITE (13,105) ATTACHK
        WRITE (13,106)
     
C       WRITE DATA TO FLUX AND TRAJECTORY FILES
        NPRINT = INT(OUTCOUNT/PRINTMAX)+1
        
        IF (ATTACHK.EQ.1)THEN !EXITED PARTICLE
C           WRITE TO TRACTORY FILE
            DO K=1,OUTFLAG-1
                WRITE (11,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO
            DO K=OUTFLAG,OUTCOUNT-2,NPRINT
                WRITE (11,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO
            DO K=OUTCOUNT-1-MOD(OUTCOUNT-2-OUTFLAG,NPRINT),OUTCOUNT
                WRITE (11,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO

C           WRITE TO FLUX FILE
            WRITE (21,207)ipart,ATTACHK,XINIT,YINIT,RINIT,ZINIT,
     &            HINIT,X,Y,R,Z,H,ETIME,PTIMEFOT(1),PTIMEF,TBULK,TNEAR,
     &            TFRIC,NSVISIT,FRICVISIT,ACONT,RZOI,AFRACT,HETTYPE,
     &            HETFLAG,NSVEL,HAVE
        END IF

        IF ((ATTACHK.EQ.2).OR.(ATTACHK.EQ.6)) THEN !ATTACHED PARTICLE
C           WRITE TO TRACTORY FILE
            DO K=1,OUTFLAG-1
                WRITE (12,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO
            DO K=OUTFLAG,OUTCOUNT-2,NPRINT
                WRITE (12,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO
            DO K=OUTCOUNT-1-MOD(OUTCOUNT-2-OUTFLAG,NPRINT),OUTCOUNT
                WRITE (12,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO

C           WRITE TO FLUX FILE
            WRITE (22,207)ipart,ATTACHK,XINIT,YINIT,RINIT,ZINIT,
     &            HINIT,X,Y,R,Z,H,ETIME,PTIMEFOT(1),PTIMEF,TBULK,TNEAR,
     &            TFRIC,NSVISIT,FRICVISIT,ACONT,RZOI,AFRACT,HETTYPE,
     &            HETFLAG,NSVEL,HAVE
        END IF

        IF ((ATTACHK.EQ.3).OR.(ATTACHK.EQ.4).OR.(ATTACHK.EQ.5)) THEN !REMAINING PARTICLE
C           WRITE TO TRACTORY FILE
            DO K=1,OUTFLAG-1
                WRITE (13,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO
            DO K=OUTFLAG,OUTCOUNT-2,NPRINT
                WRITE (13,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO
            DO K=OUTCOUNT-1-MOD(OUTCOUNT-2-OUTFLAG,NPRINT),OUTCOUNT
                WRITE (13,107)IOT(K),XOT(K),YOT(K),ROT(K),ZOT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGOT(K),FLIFTOT(K),ACONTOT(K),RZOIOT(K),
     &          AFRACTOT(K)
            END DO

C           WRITE TO FLUX FILE
            WRITE (23,207)ipart,ATTACHK,XINIT,YINIT,RINIT,ZINIT,
     &            HINIT,X,Y,R,Z,H,ETIME,PTIMEFOT(1),PTIMEF,TBULK,TNEAR,
     &            TFRIC,NSVISIT,FRICVISIT,ACONT,RZOI,AFRACT,HETTYPE,
     &            HETFLAG,NSVEL,HAVE
        END IF

C       CLOSE ATTACHED PARTICLES FLUX FILES TO RELOAD FILE FOR NEXT PARTICLE LOOP
        IF (ATTMODE.EQ.-1) THEN
            CLOSE(99)
        ENDIF

C       EMPTY PROJECTION MATRIX
        IF ((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)) THEN
          DEALLOCATE(M_PRO)
        ENDIF
        
      END DO !LOOP TO NEXT PARTICLE
C
 5001 FORMAT (E15.8,2X,E15.8,2X,E15.8,2X,I10) 
 
      END PROGRAM HAPHETLN


C     SUBROUTINES FOR FORCES ON COLLOID (VDW,EDL,AB,BORN,STERIC,DRAG,DIFFUSION,GRAVITY,LIFT)

C     SUBROUTINE VDW FORCE (N)
      SUBROUTINE FORCEVDW (A132,AP,ASP,NASP,RMODE,H,LAMBDAVDW,A11,A22,
     &                     A33,AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)
      INTEGER VDWMODE,RMODE
      DOUBLE PRECISION A132,AP,ASP,NASP,H,H2,LAMBDAVDW,A11,A22,A33,
     &                 AC1C1,AC2C2,T1,T2,FVDW,FVDW1,FVDW2
      DOUBLE PRECISION A12,A1C2,A13,AC12,AC1C2,
     &                 AC13,A23,AC23

      A12 = (A11**0.5)*(A22**0.5)
      A1C2 = (A11**0.5)*(AC2C2**0.5) 
      A13 = (A11**0.5)*(A33**0.5)
      AC12 = (AC1C1**0.5)*(A22**0.5)
      AC1C2 = (AC1C1**0.5)*(AC2C2**0.5)
      AC13 = (AC1C1**0.5)*(A33**0.5)
      A23 = (A22**0.5)*(A33**0.5)
      AC23 = (AC2C2**0.5)*(A33**0.5)
C     CALCULATE VDW
      IF (VDWMODE.EQ.1) THEN
          IF (RMODE.EQ.0) THEN !SMOOTH SURFACE ON BOTH
              FVDW = -(A132*AP/(6.0*H**2)) !(SPHERE-PLANE GEOMETRY) -RETARDED VAN DER WAALS EXPRESSION DERIVED FROM ENERGY GIVEN BY NIR 1977 INCLUDING RETARDATION FROM GREGORY 1981
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
          END IF
          IF (RMODE.EQ.1) THEN !ASPERITIES ON COLLOID
              H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C             CALCULATE VDW INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-PLATE)
              FVDW1 = -(A132*AP/(6.0*H2**2))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H2))
C             CALCULATE VDW INTERACITON BETWEEN ASPERTIES AND COLLECTOR (SPHERE-PLATE)
              FVDW2 = -(A132*ASP/(6.0*H**2))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
C             CALCULATE TOTAL INTERACTION
              FVDW = FVDW1 + NASP*FVDW2
          END IF
          IF (RMODE.EQ.2) THEN !ASPERITIES ON COLLECTOR
              H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C             CALCULATE VDW INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-PLATE)
              FVDW1 = -(A132*AP/(6.0*H2**2))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H2))
C             CALCULATE VDW INTERACITON BETWEEN ASPERTIES AND COLLOID (SPHERE-SPHERE)
              FVDW2 = -(A132*ASP*AP/(6.0*(ASP+AP)*H**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
C             CALCULATE TOTAL INTERACTION
              FVDW = FVDW1 + NASP*FVDW2
          END IF
          IF (RMODE.EQ.3) THEN  !ASPERITIES ON BOTH SURFACES
              H2 = H + 0.5*(2*ASP+3**0.5*ASP) !AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
C             CALCULATE VDW INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-PLATE)
              FVDW1 = -(A132*AP/(6.0*H2**2))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H2))
C             CALCULATE VDW INTERACTION BETWEEN ASPERITIES (SPHERE-SPHERE GEOMETRY JUSTIFIED BY LINEAR APPROXIMATION) Gregory retarded vdw energy 1981 from Elimelech Part. Dep book
              FVDW2 = -(A132*ASP*ASP/(6.0*(ASP+ASP)*H**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
C             CALCULATE TOTAL INTERACTION
              FVDW = FVDW1 + 2.5*NASP*FVDW2
          END IF
      END IF
      IF (VDWMODE.EQ.2) THEN
          FVDW = -(AC1C2-AC23-AC13+A33)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*H)*
     &         ((AP+T1)/H**2-1/H+(AP+T1)/(H+2*T1+2*AP)**2+
     &         1/(H+2*T1+2*AP))+11.12*LAMBDAVDW/(LAMBDAVDW+11.12*H)**2*
     &         ((AP+T1)/H+(AP+T1)/(H+2*T1+2*AP)+
     &         LOG(H/(H+2*T1+2*AP)))))/6
     &         -(A1C2-AC1C2-A13+AC13)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*(H+T1))*
     &         (AP/(H+T1)**2-1/(H+T1)+AP/(H+T1+2*AP)**2+
     &         1/(H+T1+2*AP))+
     &         11.12*LAMBDAVDW/(LAMBDAVDW+11.12*(H+T1))**2*
     &         (AP/(H+T1)+AP/(H+T1+2*AP)+LOG((H+T1)/(H+T1+2*AP)))))/6
     &         -(AC12-A23-AC1C2+AC23)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*(H+T2))*
     &         ((AP+T1)/(H+T2)**2-1/(H+T2)+
     &         (AP+T1)/(H+2*T1+T2+2*AP)**2+
     &         1/(H+2*T1+T2+2*AP))+
     &         11.12*LAMBDAVDW/(LAMBDAVDW+11.12*(H+T2)**2)*
     &         ((AP+T1)/(H+T2)+(AP+T1)/(H+2*T1+T2+2*AP)+
     &         LOG((H+T2)/(H+2*T1+T2+2*AP)))))/6
     &         -(A12-AC12-A1C2+AC1C2)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*(H+T1+T2))*
     &         (AP/(H+T1+T2)**2-1/(H+T1+T2)+AP/(H+T1+T2+2*AP)**2+
     &         1/(H+T1+T2+2*AP))+
     &         11.12*LAMBDAVDW/(LAMBDAVDW+11.12*(H+T1+T2))**2*
     &         (AP/(H+T1+T2)+AP/(H+T1+T2+2*AP)+
     &         LOG((H+T1)/(H+T1+2*AP)))))/6
      END IF
      IF (VDWMODE.EQ.3) THEN
          FVDW = -(A1C2-AC23-A13+A33)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*H)*
     &         (AP/H**2-1/H+AP/(H+2*AP)**2+1/(H+2*AP))+
     &         11.12*LAMBDAVDW/(LAMBDAVDW+11.12*H)**2*
     &         (AP/H+AP/(H+2*AP)+LOG(H/(H+2*AP)))))/6
     &         -(A12-A23-A1C2+AC23)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*(H+T2))*
     &         (AP/(H+T2)**2-1/(H+T2)+AP/(H+T2+2*AP)**2+
     &         1/(H+T2+2*AP))+
     &         11.12*LAMBDAVDW/(LAMBDAVDW+11.12*(H+T2))**2*
     &         (AP/(H+T2)+AP/(H+T2+2*AP)+LOG((H+T2)/(H+T2+2*AP)))))/6
      END IF
      IF (VDWMODE.EQ.4) THEN         
          FVDW = -(AC12-A23-AC13+A33)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*H)*
     &         ((AP+T1)/H**2-1/H+(AP+T1)/(H+2*T1+2*AP)**2+
     &         1/(H+2*T1+2*AP))+11.12*LAMBDAVDW/(LAMBDAVDW+11.12*H)**2*
     &         ((AP+T1)/H+(AP+T1)/(H+2*T1+2*AP)+
     &         LOG(H/(H+2*T1+2*AP)))))/6
     &         -(A12-AC12-A13+AC13)*(
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*(H+T1))*
     &         (AP/(H+T1)**2-1/(H+T1)+AP/(H+T1+2*AP)**2+
     &         1/(H+T1+2*AP))+
     &         11.12*LAMBDAVDW/(LAMBDAVDW+11.12*(H+T1))**2*
     &         (AP/(H+T1)+AP/(H+T1+2*AP)+LOG((H+T1)/(H+T1+2*AP)))))/6
      END IF
      END SUBROUTINE FORCEVDW

C     SUBROUTINE FORCE EDL (N) 
      SUBROUTINE FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                        AP,ASP,NASP,RMODE,H,PI,FEDL)
      DOUBLE PRECISION KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                 AP,ASP,NASP,H,H2,PI,FEDL1,FEDL2,FEDL
      DOUBLE PRECISION COEF1,COEF2,J
      INTEGER RMODE
      
      J = 1-(PI/4) !CALCULATE AREA OF SURFACE NOT OCCUPIED BY ASPERITIES USING JAMMING LIMIT FOR CUBIC PACKED SPHERES
      IF (RMODE.EQ.0) THEN !SMOOTH SURFACE ON BOTH (SPHERE-PLANE GEOMETRY) (DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*(KB*T/ZI/ECHG)**2.0
     &            *TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL = COEF1*((KAPPA*AP-1)*EXP(-KAPPA*H)
     &            +((KAPPA*AP+1)*EXP(-KAPPA*(H+2*AP))))
      END IF    
      IF (RMODE.EQ.1) THEN !ASPERITIES ON COLLOID
          H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C         CALCULATE EDL INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-PLATE DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*(KB*T/ZI/ECHG)**2.0* 
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL1 = COEF1*((KAPPA*AP-1)*EXP(-KAPPA*H2)
     &            +((KAPPA*AP+1)*EXP(-KAPPA*(H2+2*AP))))
C         CALCULATE EDL INTERACITON BETWEEN ASPERTIES AND COLLECTOR (SPHERE-PLATE) 
          COEF2 = 64.0*PI*ERE0*(KB*T/ZI/ECHG)**2.0* 
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL2 = COEF2*((KAPPA*ASP-1)*EXP(-KAPPA*H)
     &            +((KAPPA*ASP+1)*EXP(-KAPPA*(H+2*ASP))))
C         CALCULATE TOTAL INTERACTION (MULTIPLY OFFSET SMOOTH SURFACE BY 1-JAMMING LIMIT OF SURFACE COVERED BY ASPERITIES)
          FEDL = J*FEDL1 + NASP*FEDL2 
      END IF
      IF (RMODE.EQ.2) THEN !ASPERITIES ON COLLECTOR
          H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C         CALCULATE EDL INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-PLATE DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*(KB*T/ZI/ECHG)**2.0* 
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL1 = COEF1*((KAPPA*AP-1)*EXP(-KAPPA*H2)
     &            +((KAPPA*AP+1)*EXP(-KAPPA*(H2+2*AP))))
C         CALCULATE EDL INTERACITON BETWEEN ASPERTIES AND COLLOID (SPHERE-SPHERE) 
          COEF2 = 64.0*PI*ERE0*ASP*AP/(ASP+AP)*(KB*T/ZI/ECHG)**2.0*
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T) 
          FEDL2 = COEF2*KAPPA*EXP(-KAPPA*H)
C         CALCULATE TOTAL INTERACTION (MULTIPLY OFFSET SMOOTH SURFACE BY 1-JAMMING LIMIT OF SURFACE COVERED BY ASPERITIES)
          FEDL = J*FEDL1 + NASP*FEDL2 
      END IF
      IF (RMODE.EQ.3) THEN  !ASPERITIES ON BOTH SURFACES 
          H2 = H+0.5*(2*ASP+3**0.5*ASP) !AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
C         CALCULATE EDL INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-PLATE (DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*(KB*T/ZI/ECHG)**2.0* 
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL1 = COEF1*((KAPPA*AP-1)*EXP(-KAPPA*H2)
     &            +((KAPPA*AP+1)*EXP(-KAPPA*(H2+2*AP))))
C         CALCULATE EDL INTERACTION BETWEEN ASPERITIES (SPHERE-SPHERE JUSTIFIED BY LINEAR APPROXIMATION)
          COEF2 = 64.0*PI*ERE0*ASP*ASP/(ASP+ASP)*(KB*T/ZI/ECHG)**2.0*
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T) 
          FEDL2 = COEF2*KAPPA*EXP(-KAPPA*H)
C         CALCULATE TOTAL INTERACTION (MULTIPLY OFFSET SMOOTH SURFACE BY 1-JAMMING LIMIT OF SURFACE COVERED BY ASPERITIES)          
          FEDL = J*FEDL1 + 2.5*NASP*FEDL2 
      END IF
      IF (ABS(FEDL).LT.1.0E-30) THEN
          FEDL = 0.0
      ENDIF
      END SUBROUTINE FORCEEDL
     
C     SUBROUTINE LEWIS ACID-BASE FORCE (N) (DERIVED FROM WOOD & REHMANN 2014)
      SUBROUTINE FORCEAB (PI,AP,ASP,NASPAB,RMODE,LAMBDAAB,
     &                  GAMMA0AB,H,H0,FAB)
      DOUBLE PRECISION PI,AP,LAMBDAAB,GAMMA0AB,H,H0,FAB
      DOUBLE PRECISION AEFF,LOWGEO,HIGHGEO,ASP,NASPAB,COEFF,FAB1
      INTEGER RMODE
      
      IF (RMODE.EQ.0) THEN !SMOOTH COLLOID AND COLLECTOR
C         CALCULATE AB INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-PLATE)
          FAB = 2*PI*AP*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)*
     &          (1-LAMBDAAB/AP+(1+LAMBDAAB/AP)*EXP(-2*AP/LAMBDAAB))
      END IF
      IF (RMODE.EQ.1) THEN !ASPERITIES ON COLLOID
C         CALCULATE AB INTERACTION BETWEEN ASPERITIES AND COLLECTOR (SPHERE-PLATE)
          FAB1 = 2*PI*ASP*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)*
     &          (1-LAMBDAAB/ASP+(1+LAMBDAAB/ASP)*EXP(-2*ASP/LAMBDAAB))
C         CALCULATE TOTAL INTERACTION
          FAB = NASPAB*FAB1
      END IF
      IF (RMODE.EQ.2) THEN !ASPERITIES ON COLLECTOR
C         CALCULATE THE EFFECTIVE RADIUS USING ASPERITY AND COLLOID RADIUS
          AEFF = 2*(ASP*AP)/(ASP+AP)
C         LOWER BOUND ON GEOMETRIC CORRECTION - SPHERE-PLATE APPROXIMATION USING EFFECTIVE RADIUS
          LOWGEO = 1-LAMBDAAB/AEFF+(1+LAMBDAAB/AEFF)*
     &                EXP(-2*AEFF/LAMBDAAB)
C         UPPER BOUND ON GEOMETRIC CORRECTION - SAME SIZE SPHERE-SPHERE APPROXIMATION USING EFFECTIVE RADIUS
          HIGHGEO = 1-LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0)-
     &      (4*AEFF/(3*LAMBDAAB))*EXP(-2*AEFF/LAMBDAAB)-
     &      (1+LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0))*
     &      EXP(-4*AEFF/LAMBDAAB)
C         GEOMETRIC CORRECTION FOR SPHERE-SPHERE
          COEFF = ((1-ASP/AP)*LOWGEO+ASP/AP*HIGHGEO)
C         CALCULATE AB INTERACTION BETWEEN ASPERITIES AND COLLOID (SPHERE-SPHERE)
          FAB1 = COEFF*PI*AEFF*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)
C         CALCULATE TOTAL INTERACTION
          FAB = NASPAB*FAB1
      END IF
      IF (RMODE.EQ.3) THEN  !ASPERITIES ON BOTH SURFACES
C         GEOMETRIC CORRECTION FOR SAME SIZE SPHERE
          COEFF = 1-LAMBDAAB/ASP+LAMBDAAB**2.0/(2*ASP**2.0)-
     &      (4*ASP/(3*LAMBDAAB))*EXP(-2*ASP/LAMBDAAB)-
     &      (1+LAMBDAAB/ASP+LAMBDAAB**2.0/(2*ASP**2.0))*
     &      EXP(-4*ASP/LAMBDAAB)
C         CALCULATE AB INTERACTION BETWEEN ASPERITIES (SAME SIZE SPHERE-SPHERE)
          FAB1 = COEFF*PI*ASP*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)
C         CALCULATE TOTAL INTERACTION
          FAB = 2.5*NASPAB*FAB1
      END IF
      END SUBROUTINE FORCEAB

C     SUBROUTINE BORN FORCE (N) (DERIVED FROM ENERGY GIVEN BY RUCKENSTEIN & PRIEVE 1976)
      SUBROUTINE FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
      INTEGER VDWMODE
      DOUBLE PRECISION A132,SIGMAC,AP,H,FBORN
      DOUBLE PRECISION A11,A22,A33,AC1C1,AC2C2
      DOUBLE PRECISION A1C2,A13,AC12,AC1C2,
     &                 AC13,A23,AC23
   
      A1C2 = (A11**0.5)*(AC2C2**0.5) 
      A13 = (A11**0.5)*(A33**0.5)
      AC12 = (AC1C1**0.5)*(A22**0.5)
      AC1C2 = (AC1C1**0.5)*(AC2C2**0.5)
      AC13 = (AC1C1**0.5)*(A33**0.5)
      A23 = (A22**0.5)*(A33**0.5)
      AC23 = (AC2C2**0.5)*(A33**0.5)
      IF (VDWMODE.EQ.1) THEN
          FBORN = (A132*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      IF (VDWMODE.EQ.2) THEN
          FBORN = ((AC1C2-AC23-AC13+A33)*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      IF (VDWMODE.EQ.3) THEN
          FBORN = ((A1C2-AC23-A13+A33)*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      IF (VDWMODE.EQ.4) THEN
          FBORN = ((AC12-A23-AC13+A33)*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      END SUBROUTINE FORCEBORN

C     SUBROUTINE STERIC FORCE (N)
      SUBROUTINE FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
      DOUBLE PRECISION PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE
      
      FSTE = GAMMA0STE/LAMBDASTE*EXP(-H/LAMBDASTE)*PI*ASTE**2
      END SUBROUTINE FORCESTE

C     SUBROUTINE DRIVING DRAG FORCE
      SUBROUTINE FORCEDRAG (FUN2,FUN3,FUN4,M3,VZ,VR,FDRGR,FDRGZ)
      DOUBLE PRECISION FUN2,FUN3,FUN4,M3,VZ,VR,FDRGR,FDRGZ
      
C     CALCULATE DRAG FORCES (RADIAL AND NORMAL)
	  FDRGR = FUN3/FUN4*M3*VR
      FDRGZ = FUN2*M3*VZ
      END SUBROUTINE FORCEDRAG

C     SUBROUTINE DIFFUSION FORCE
      SUBROUTINE FORCEDIFF(DIFFSCALE,PI,VISC,AP,KB,T,dT,
     &                       FDIFX,FDIFY,FDIFZ)
      DOUBLE PRECISION DIFFSCALE,PI,VISC,AP,KB,T,dT,
     &                FDIFX,FDIFY,FDIFZ,rsign1,rnum1,rsign2,rnum2,
     &                rsign3,rnum3,bigni,ni
      INTEGER nrand
      
C     CALL SUBROUTINE generate_unif WHICH USES SEED TO GENERATE TWO RANDOM NUMBERS IN 
C     THE RANGE 0 TO 1 (UNIFORM DISTRIBUTION) AND WHICH GENERATES NEW SEED
      CALL generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &                   nrand)
C     ONLY POSITIVE DOMAIN LOWER LIMIT = 0.5 UPPER LIMIT FOR  + 2*STDEV= 0.9771 , SPAN = 0.4771
      rnum1 = rnum1 * 0.4771+ 0.5
      rnum2 = rnum2 * 0.4771+ 0.5
      rnum3 = rnum3 * 0.4771+ 0.5
C     CONVERT UNIFORM DISTRIBUTION TO GAUSSIAN DISTRIBUTION WITH ZERO MEAN AND VARIANCE OF UNITY   
      
      bigni = rnum1
      CALL calc_ni(bigni,ni)
      randm1 = ni*rsign1
C
      bigni = rnum2
      CALL calc_ni(bigni,ni)
      randm2 = ni*rsign2
C
      bigni = rnum3   
      CALL calc_ni(bigni,ni)
      randm3 = ni*rsign3
      
C     KIM AND ZYDNEY (2004) INDICATE FORMULAS USED ABOVE APPLY TO Z AND R AND ARE ADDITIVE 
	  FDIFZ = DIFFSCALE*(randm1)*((12.0*PI*AP*VISC*KB*T/(dT))**0.5)
C     DIFFUSION APPLIED IN 3DIMENSIONS
	  FDIFX = DIFFSCALE*(randm2)*((12.0*PI*AP*VISC*KB*T/(dT))**0.5)
	  FDIFY = DIFFSCALE*(randm3)*((12.0*PI*AP*VISC*KB*T/(dT))**0.5)
      END SUBROUTINE FORCEDIFF
      
C     SUBROUTINE GRAVITY (N)
C     GRAVITATIONAL FORCE VECTOR SET TO NEGATIVE FOR CONCURRENT FLOW AND GRAVITY 
C     FOR COUNTERCURRENT FLOW AND GRAVITY, SET GRAVFACT TO POSITIVE
      SUBROUTINE GRAVITY (GRAVFACT,AP,G,RHOP,RHOW,PI,FG)
      DOUBLE PRECISION GRAVFACT,AP,G,RHOP,RHOW,PI,FG
      
      FG = GRAVFACT*(4.0/3.0)*PI*(AP**3)*(RHOP-RHOW)*G
      END SUBROUTINE GRAVITY
      
C     LIFT FORCE SUBROUTINE (NORMALIZED TO THE CLOSTEST SURFACE)
      SUBROUTINE FORCELIFT (RHOW,Z,AP,VR,UR,OMEGA,FLIFT)
      DOUBLE PRECISION RHOW,Z,AP,VR,UR,OMEGA,FLIFT
      DOUBLE PRECISION KS,LNZAP,LS,LR,LT,LRT,LSR,LST
      
C     (Yahiaoui&Feuillebois2010)
C     CONSIDER LIFT FORCE IF PARTICLE IS WITHIN 10 RADII OF THE SURFACE
      IF (Z.LE.(100.0*AP)) THEN
          KS = VR/Z                                                     !SHEAR RATE  
          LNZAP = LOG(Z/AP)
          LS = EXP(2.221+1.565*LNZAP+0.06602*LNZAP**2.0)                !LIFT FORCE ON FIXED SPHERE IN LINEAR SHEAR FLOW
          LR = EXP(-1.0*(0.6390+1.408*LNZAP)/                           !LIFT FORCE ON ROTATING SPHERE IN FLUID AT REST
     &            (1.0-0.1036*LNZAP+0.01136*LNZAP**2.0))
          LT = (1.751+6.147*LNZAP+3.299*LNZAP**2.0-2.485*LNZAP**3.0+    !LIFT FORCE ON TRANSLATING SPHERE IN FLUID AT REST
     &            1.952*LNZAP**4.0)/(1.0+3.714*LNZAP+1.481*LNZAP**2.0-
     &            1.278*LNZAP**3.0+1.0905*LNZAP**4.0)
          LRT = -LNZAP*(10.97+439.4*LNZAP+355.0*LNZAP**2.0+             !LIFT FORCE COUPLING TERM FOR ROTATING AND TRANSLATING SPHERE IN FLUID AT REST
     &            171.6*LNZAP**3.0)/(1.0+7.309*LNZAP+284.7*LNZAP**2.0+
     &            86.45*LNZAP**3.0+77.45*LNZAP**4.0)
          LSR = EXP((-4.723-11.11*LNZAP+41.76*LNZAP**2.0)/              !LIFT FORCE COUPLING TERM FOR ROTATING SPHERE IN LINEAR SHEAR FLOW
     &            (1.0+20.31*LNZAP))
          LST = (-10.76-2.158*LNZAP-4.218*LNZAP**2.0)/(1.0-0.1749*LNZAP)!LIFT FORCE COUPLING TERM FOR TRANSLATING SPHERE IN LINEAR SHEAR FLOW
          
          FLIFT = RHOW*AP**2.0*((AP*KS)**2.0*LS+(AP*OMEGA)**2.0*LR+
     &            (UR)**2.0*LT+(AP*OMEGA*UR)*LRT+
     &            (AP**2.0*OMEGA*KS)*LSR+(AP*KS*UR)*LST)
      ELSE
          FLIFT = 0.0
      ENDIF
      END SUBROUTINE FORCELIFT

C     SUBROUTINE INITIAL
C     SUBROUTINE TO OBTAIN INITIAL PARTICLE LOCATIONS
      SUBROUTINE INITIAL (ZLIM,AP,ASP,RMODE,ZMAX,
     &                    YPAR,YINIT,RINIT,ZINIT,HINIT)   
      DOUBLE PRECISION ZLIM,AP,ASP,ZMAX,YPAR,YINIT,RINIT,ZINIT,HINIT
      DOUBLE PRECISION rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,ZMIN
      INTEGER  nrand,RMODE
      
      ZINIT = 2.0*ZLIM !INITIALIZE VALUE TO EXECUTE DO WHILE LOOP
      IF (RMODE.EQ.0) THEN !SMOOTH-SMOOTH INTERACTION
          ZMIN = AP
      ELSE IF ((RMODE.EQ.1).OR.(RMODE.EQ.2)) THEN !SMOOTH-ROUGH INTERACTION
          ZMIN = AP + ASP
      ELSE IF (RMODE.EQ.3) THEN !ROUGH-ROUGH INTERACTION
          ZMIN = AP + 0.5*(2*ASP+3**0.5*ASP) !THIRD TERM IS AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH SURFACES FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
      ENDIF   
      DO WHILE ((ZINIT.GT.ZLIM).OR.(ZINIT.LE.ZMIN))
C         CALL RANDOM NUMBER FOR LOCATIONS
          CALL generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &                       nrand)
          ZINIT = (rnum1)*ZMAX
          YINIT = (rnum2)*YPAR
      END DO 
      RINIT = 0.0
C     SET HINIT ACCORDING TO ROUGHNESS MODE
      IF (RMODE.EQ.0) THEN !SMOOTH-SMOOTH INTERACTION
          HINIT = ZINIT - AP
      ELSE IF ((RMODE.EQ.1).OR.(RMODE.EQ.2)) THEN !SMOOTH-ROUGH INTERACTION
          HINIT = ZINIT - AP - ASP
      ELSE IF (RMODE.EQ.3) THEN !ROUGH-ROUGH INTERACTION
          HINIT = ZINIT - AP - 0.5*(2*ASP+3**0.5*ASP) !THIRD TERM IS AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH SURFACES FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
      END IF
      END SUBROUTINE INITIAL 
C
C     SUBROUTINE PARFF  
      SUBROUTINE PARFF (R,Z,Q,RPAR,ZMAX,B,VISC,VR,VZ)
	IMPLICIT NONE
	DOUBLE PRECISION, INTENT(IN):: R,Z,Q,RPAR,ZMAX,B,VISC
      DOUBLE PRECISION, INTENT(OUT):: VR,VZ
      DOUBLE PRECISION ZR,G3
      
      ZR = Z + B !INCLUDE SLIP LAYER FOR TANGENTIAL FLOW (WORKS FOR Z=0 BOUNDARY ONLY, NOT Z=MAX)
      G3 = 12*Q*VISC/(ZMAX*ZMAX*ZMAX)
	VR = (G3/(2*VISC))*ZR*(ZMAX-ZR)
	VZ = 0.0
      END SUBROUTINE PARFF
    
C     SUBROUTINE HETTRACK
      SUBROUTINE HETTRACK(X,Y,Xm0,Ym0,RZOI,RPAR,YPAR,HETMODE,
     &                    SCOV,RHET0,RHET1,RHET2,XHET,YHET,RHET)
      DIMENSION XHET(100),YHET(100),RHET(100)
      DOUBLE PRECISION X,Y,Xm0,Ym0,XHET,YHET
      DOUBLE PRECISION XP,YP,NHETREAL0,HMODEREAL
      DOUBLE PRECISION RZOI,SCOV,SCOV0,RHET0,RHET1,RHET2,RHET
      DOUBLE PRECISION ROXY,RPAR,XPAR,YPAR
      DOUBLE PRECISION PHI,DPHI,D
      DOUBLE PRECISION HM1,HM2,ODD,COEFF
      DOUBLE PRECISION PI,REALNX,REALNY
      DOUBLE PRECISION DX,DY,DX1,DX2,DY1,DY2
      INTEGER NHET0,HETMODE,NX,NY,NXP,NYP,M,J
      DATA PI/3.14159265359/
      
C     CALCULATE SURFACE COVERAGE OF LARGE HETERODOMAINS
      IF (HETMODE.EQ.1) THEN
          HM1 = 0.0
          HM2 = 0.0
      ELSEIF (HETMODE.EQ.5) THEN
          HM1 = 4.0
          HM2 = 0.0
      ELSEIF (HETMODE.EQ.9) THEN
          HM1 = 8.0
          HM2 = 0.0
      ELSEIF (HETMODE.EQ.73) THEN
          HM1 = 8.0
          HM2 = 64.0
      END IF
      SCOV0 = SCOV*(RHET0**2)/(RHET0**2+HM1*RHET1**2+HM2*RHET2**2)
C     CALCULATE APPROXIMATE NUMBER OF HETERODOMAINS REQUIRED
C     ACTUAL SURFACE COVERAGE HAS TO BE CALCULATED IN HETSAMEARC
C     AFTER ALL HETERODOMAINS ARE EXPLICITLY GENERATED
C     APPROXIMATION IS GOOD TO WITHIN 5% OR BETTER
      XPAR = RPAR
      NHET0 = NINT(SCOV0*(XPAR*YPAR)/(PI*RHET0**2.0))
      NHETREAL0 = NHET0
C     CALCULATE NUMBER OF EVENLY SPACED LINES IN EACH DIMENSION, THE INTERSECTIONS OF WHICH ARE HETERODOMAINS
C     NX = # LINES IN XPAR (RPAR) DIMENSION
      NX = NINT((NHETREAL0*(XPAR/YPAR))**0.5)
C     NY = # LINES IN YPAR DIMENSION
	NY = NINT(NX*(YPAR/XPAR))
	REALNX = NX
	REALNY = NY
C     CALCULATE LONGITUDINAL STEP IN XPAR (RPAR) 
      DX =  XPAR/REALNX
C     CALCULATE ORTHOGONAL STEP IN YPAR 
      DY =  YPAR/REALNY
C     CALCULATE LONGITUDINAL AND ORTHOGONAL DISTANCE OF COLLOID FROM ORIGIN
      XP = X-Xm0 ! COLLOID DISTANCE IN X AXIS
	YP = Y-Ym0 ! COLLOID DISTANCE IN Y AXIS
C     FIND CLOSEST NX AND NY TO PARTICLE
      NXP = NINT(XP/DX)
	NYP = NINT(YP/DY)
C     CALCULATE OFFSET FOR Y COMPONENT
      L=2
      ODD = MOD(NXP,L)
      COEFF=0.0
      IF(ODD.GT.0) COEFF=0.5 !ONE LINE IF STATEMENT (NO END NEEDED) TO SET OFFSET COEFF TO 0.5
C     CALCULATE X AND Y COMPONENTS OF CLOSEST HETERODOMAIN
      XGRID = NXP*DX
	YGRID = NYP*DY+COEFF*DY
C     FIND CLOSEST HETERODOMAIN
      DO J=1,HETMODE
		IF (J.EQ.1) THEN !GENERATE LARGE HETERODOMAIN
			XHET(J) = XGRID+Xm0
			YHET(J) = YGRID+Ym0
			RHET(J) = RHET0
          ELSE !GENERATE MEDIUM AND SMALL HETERODOMAINS
              DX1 = 1.0/3.0*DX
              DX2 = 1.0/9.0*DX
              DY1 = 1.0/3.0*DY
              DY2 = 1.0/9.0*DY
              IF (HETMODE.EQ.5) THEN !1:4 
                   D = 1
                   DPHI = 2.0*PI/HM1
                   PHI = (J-2)*(DPHI) + PI/4                     
                   XHET(J) = DX1*D*DCOS(PHI) + XGRID + Xm0
		         YHET(J) = DY1*D*DSIN(PHI) + YGRID + Ym0
			     RHET(J) = RHET1
              ELSEIF (HETMODE.EQ.9) THEN !1:8 
                   M=2
                   PAIR = MOD(J,M)
                   IF (PAIR.GT.0) THEN
                       D = 1
                   ELSE
                       D = (2**0.5)                      
                   END IF
                   DPHI = 2.0*PI/HM1
                   PHI = (J-1)*DPHI 
                   XHET(J) = DX1*D*DCOS(PHI) + XGRID + Xm0
                   YHET(J) = DY1*D*DSIN(PHI) + YGRID + Ym0
                   RHET(J) = RHET1
              ELSEIF (HETMODE.EQ.73) THEN !1:8:64
                   M=2
                   PAIR = MOD(J,M)
                   IF (PAIR.GT.0) THEN
                       D = 1
                   ELSE
                       D = (2**0.5)                      
                   END IF 
                   IF (J.GE.2.AND.J.LE.9) THEN 
                       DPHI = 2.0*PI/HM1
                       PHI = (J-1)*DPHI
                       XHET(J) = DX1*D*DCOS(PHI) + XGRID + Xm0
                       YHET(J) = DY1*D*DSIN(PHI) + YGRID + Ym0
                       RHET(J) = RHET1
                   ELSEIF (J.GE.10.AND.J.LE.17) THEN 
                       PHI = (J-9)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(2)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(2)
                       RHET(J) = RHET2  
                   ELSEIF (J.GE.18.AND.J.LE.25) THEN 
                       PHI = (J-17)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(3)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(3)
                       RHET(J) = RHET2 
                   ELSEIF (J.GE.26.AND.J.LE.33) THEN 
                       PHI = (J-25)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(4)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(4)
                       RHET(J) = RHET2 
                   ELSEIF (J.GE.34.AND.J.LE.41) THEN 
                       PHI = (J-33)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(5)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(5)
                       RHET(J) = RHET2 
                   ELSEIF (J.GE.42.AND.J.LE.49) THEN 
                       PHI = (J-41)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(6)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(6)
                       RHET(J) = RHET2 
                   ELSEIF (J.GE.50.AND.J.LE.57) THEN 
                       PHI = (J-49)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(7)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(7)
                       RHET(J) = RHET2 
                   ELSEIF (J.GE.58.AND.J.LE.65) THEN 
                       PHI = (J-33)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(8)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(8)
                       RHET(J) = RHET2 
                   ELSEIF (J.GE.66.AND.J.LE.73) THEN 
                       PHI = (J-65)*DPHI 
                       XHET(J) = DX2*D*DCOS(PHI) + XHET(9)
                       YHET(J) = DY2*D*DSIN(PHI) + YHET(9)
                       RHET(J) = RHET2 
                   END IF
              END IF 
          ENDIF                      
      END DO
      END SUBROUTINE HETTRACK
      
C     SUBROUTINE GENERATION AND PROJECTION OF HETERODOMAINS ON COLLOID WRITTEN BY CESAR RON - ISO CONVENTION USED FOR SPHERICAL COORDINATES [R,THETA,PHI] (RADIAL, POLAR, AZIMUTAHL) 
      SUBROUTINE HETTRACKP(X,Y,Z,RZOI,AP,HETMODEP,SCOVP,RHETP0,RHETP1,
     &                     NHETP,XHETP,YHETP,ZHETP,RHETP,THETAP,PHIP,
     &                     NPRO,XPRO,YPRO,RPRO)
      
      DOUBLE PRECISION XHETP(10000000),YHETP(10000000),ZHETP(10000000)
      DOUBLE PRECISION RHETP(10000000),THETAP(10000000),PHIP(10000000)
      DOUBLE PRECISION XPRO(10000000),YPRO(10000000),RPRO(10000000)
      DOUBLE PRECISION X,Y,Z,XmP0,YmP0,ZmP0
      DOUBLE PRECISION XHET,YHET,ZHET,RHET
      DOUBLE PRECISION ALPHA,BETA,A,B,RDHET
      DOUBLE PRECISION NHETREAL0,HMODEREAL,NRINGREAL,NHRINGREAL
      DOUBLE PRECISION PI,AP,RZOI,RHETP0,RHETP1,RPRO0,RPRO1
      DOUBLE PRECISION SCOVP,SCOVP0,SCOVP1
      DOUBLE PRECISION RRING,R1
      DOUBLE PRECISION THETA,THETA1,DTHETA
      DOUBLE PRECISION PHI,PHI1,DPHI,ARCL,PHIOFF
      DOUBLE PRECISION OMEGA0,OMEGA1
      DOUBLE PRECISION DAP,DC,DX,DY,ZU,ZL,RPL
      INTEGER NHETP0,NHETP1,NHETP,HETMODEP
      INTEGER NRING,NHETRING,NTHETA,NPHI,NPRO
      INTEGER I,J,K,M,N,HC 
      DATA PI/3.14159265359/ 
      
C     DEFINE COLLOID CENTER IN COLLECTOR FRAME OF REFERENCE
      XmP0 = X 
      YmP0 = Y 
      ZmP0 = Z 
C     RADIAL LIMIT WITHIN HETERODOMAINS WILL BE PROJECTED
      RPL = RZOI + RHETP0
C     LIMITS IN Z AXIS FOR THE RANGE WITHIN WHICH HETERODOMIANS WILL NOT BE PROJECTED
      ZU = AP + ZmP0 
      ZL = ZmP0 
C     HETMODEP TO BE USED IN DOUBLE PRECISION CALCULATIONS
      HMODEREAL = HETMODEP
C     CALCULATE OPENING ANGLE FOR ARC LENGTH OF SINGLE HETDOMAIN
      OMEGA0 = RHETP0/AP
      OMEGA1 = RHETP1/AP 
C     CALCULATE DIFFERENCE BETWEEN AP AND AP'
      DAP = AP*(1-DCOS(OMEGA0))
C     CALCULATE PROJECTED HETDOMAIN RADIUS
      RPRO0 = AP*DSIN(OMEGA0)
      RPRO1 = AP*DSIN(OMEGA1)
C     EQUIVALENT SURFACE COVERAGE CORRESPONDING TO UNIFORM HETDOMAINS IS USED IN CALCULATION
      IF (HETMODEP.EQ.1) THEN
          SCOVP0 = SCOVP
      ELSE 
          SCOVP0 = SCOVP*((1.0-DCOS(OMEGA0))
     &            /((1.0-DCOS(OMEGA0))
     &            +(HMODEREAL-1.0)*(1.0-DCOS(OMEGA1))))
      END IF     
C     CALCULATE THEORETICAL NUMBER OF HETDOMAINS
      NHETP0 = NINT(SCOVP0*4.0
     &        /(2.0*(1.0-DCOS(OMEGA0))))
      NHETP1 = (HMODEREAL-1.0)*NHETP0
C     INITIALIZE COUNT OF HETERODOMAINS
      HC = 0
C     CALCULATE NUMBER OF RINGS THAT YIELD NHET ASSUMING EVEN SPACING 
      NHETREAL0 = NHETP0
      NRING = NINT((NHETREAL0/1.3)**0.5)
      NRINGREAL = NRING
      SCOVP = (NHETREAL0*2.0*(1-DCOS(OMEGA0))+
     &       (HMODEREAL-1.0)*NHETREAL0*2.0*(1-DCOS(OMEGA1)))
     &       /(4.0)
C     CALCULATE POLAR (ELEVATION) ANGLE STEP
      DTHETA =  PI/(NRINGREAL-1.0)
C     INITITIALIZE POLAR (ELEVATION) ANGLE
      THETA = 0.0
C     CALCULATE ARCLENGHT CONSTANT IN AZIMUTH
      ARCL = DTHETA*AP
C     INITIALIZE PROJECTION ARRAYS
      IF (NHETP0.EQ.0) THEN
          XPRO(1) = 0.0
          YPRO(1) = 0.0
          RPRO(1) = 0.0
      ENDIF
C     GENERATE HETDOMAINS FROM 0.0 TO PI THETA DOMAIN     
      DO I=1,NRING            
          !CALCULATE POLAR (ELEVATION) ANGLE 
          THETA = (I-1)*DTHETA  
          IF ((I.EQ.1).OR.(I.EQ.NRING)) THEN !AT POLES
              RRING = 0.0 !IN POLE NO RING AND ONLY ONE HETDOMAIN
              NHETRING = 1
              DPHI = 0.0
              IF (I.EQ.1) THEN
                  THETA = 0.0 
              ELSEIF (I.EQ.NRING) THEN
                  THETA = PI
              ENDIF
              !POPULATE HETDOMAINS AT POLE
              DO J=1,HETMODEP
                  HC = HC + 1
                  IF (J.EQ.1) THEN !GENERATE LARGE HETDOMAIN
                      PHI = 0
                      XHET = RRING*DCOS(PHI)+XmP0
                      YHET = RRING*DSIN(PHI)+YmP0
                      ZHET = AP*DCOS(THETA)+ZmP0  
                      RHET = RHETP0
                      BETA = ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETERODOMAIN RESPECT TO PROJECTION PLANE
                      ARG = (ZmP0-ZHET)/AP
                      IF (ARG.GE.1.0) THEN
                          ARG = 1.0
                          BETA = ACOS(ARG)
                      ELSEIF (ARG.LE.-1.0) THEN
                          ARG = -1.0
                          BETA = ACOS(ARG)
                      ENDIF
                      RDHET = ((XHET-XmP0)**2+
     &                        (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                      XHETP(HC) = XHET
                      YHETP(HC) = YHET
                      ZHETP(HC) = ZHET
                      RHETP(HC) = RHET
                      THETAP(HC) = THETA
                      PHIP(HC) = PHI
                      IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL)) THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                          XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                      ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                          IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE PROJECTION RADIAL LIMIT
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION
                          ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE PROJECTION RADIAL LIMIT AND LOWER HEMISPHERE OF COLLOID
                              DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                              DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                              DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                              A = RPRO0 !ELLIPSE MAJOR AXIS
                              B = RPRO0*DCOS(BETA) !ELLIPSE MINOR AXIS
                              XPRO(HC) = XHET-DX
                              YPRO(HC) = YHET-DY
                              RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS
                          ENDIF
                      ENDIF
                  ELSE !GENERATE SMALL HETDOMAINS AROUND LARGE HETERODOMAIN 
                      IF (HETMODEP.EQ.5) THEN !1:4
                          THETA1 = THETA+(1.0/3.0*DTHETA)  
                          PHI = (J-2)*PI/2.0
                          R1 = AP*DSIN(THETA1)
                          XHET = R1*DCOS(PHI)+XmP0
                          YHET = R1*DSIN(PHI)+YmP0
                          ZHET = AP*DCOS(THETA1)+ZmP0
                          RHET = RHETP1
                          BETA = ACOS((ZmP0-ZHET)/AP)!ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                          ARG = (ZmP0-ZHET)/AP
                          IF (ARG.GE.1.0) THEN
                              ARG = 1.0
                              BETA = ACOS(ARG)
                          ELSEIF (ARG.LE.-1.0) THEN
                              ARG = -1.0
                              BETA = ACOS(ARG)
                          ENDIF
                          RDHET = ((XHET-XmP0)**2+
     &                            (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                          XHETP(HC) = XHET
                          YHETP(HC) = YHET
                          ZHETP(HC) = ZHET
                          RHETP(HC) = RHET
                          THETAP(HC) = THETA1
                          PHIP(HC) = PHI
                          IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL))THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                              IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION
                              ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                  DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                  DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                  DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                  A = RPRO1 !ELLIPSE MAJOR AXIS
                                  B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                  XPRO(HC) = XHET-DX
                                  YPRO(HC) = YHET-DY
                                  RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS
                              ENDIF
                          ENDIF
                      ELSEIF (HETMODEP.EQ.9) THEN !1:8
                          THETA1 = THETA + (1.0/3.0*DTHETA)
                          R1 = AP*DSIN(THETA1)
                          IF (J.EQ.2) THEN
                              PHI = 0.0
                          ENDIF
                          IF (J.EQ.3) THEN
                              PHI = PI/4.0
                          ENDIF
                          IF (J.EQ.4) THEN
                              PHI = PI/2.0
                          ENDIF
                          IF (J.EQ.5) THEN
                              PHI = 3.0/4.0*PI
                          END IF 
                          IF (J.EQ.6) THEN
                              PHI = PI
                          ENDIF
                          IF (J.EQ.7) THEN
                              PHI = 5.0/4.0*PI
                          ENDIF
                          IF (J.EQ.8) THEN
                              PHI = 3.0/2.0*PI
                          ENDIF
                          IF (J.EQ.9) THEN
                              PHI = 7.0/4.0*PI
                          ENDIF
                          XHET = R1*DCOS(PHI)+XmP0
                          YHET = R1*DSIN(PHI)+YmP0
                          ZHET = AP*DCOS(THETA1)+ZmP0
                          RHET = RHETP1
                          BETA =ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                          ARG = (ZmP0-ZHET)/AP
                          IF (ARG.GE.1.0) THEN
                              ARG = 1.0
                              BETA = ACOS(ARG)
                          ELSEIF (ARG.LE.-1.0) THEN
                              ARG = -1.0
                              BETA = ACOS(ARG)
                          ENDIF
                          RDHET = ((XHET-XmP0)**2+
     &                            (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                          XHETP(HC) = XHET
                          YHETP(HC) = YHET
                          ZHETP(HC) = ZHET
                          RHETP(HC) = RHET
                          THETAP(HC) = THETA1
                          PHIP(HC) = PHI
                          IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL))THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                              IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION
                              ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                  DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                  DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                  DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                  A = RPRO1 !ELLIPSE MAJOR AXIS
                                  B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                  XPRO(HC) = XHET-DX
                                  YPRO(HC) = YHET-DY
                                  RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS
                              ENDIF
                          ENDIF
                      ENDIF
                  ENDIF
              ENDDO
          ELSE !NOT AT POLES
              RRING = AP*DSIN(THETA) 
              NHETRING = NINT(2.0*PI*RRING/ARCL)
              IF (NHETRING.LT.3) THEN
                  NHETRING = 3
              ENDIF
              NHRINGREAL = NHETRING
              !CALCULATE STEP IN PHI (AZIMUTHAL ANGLE) BASED ON NHETRING
              DPHI = 2.0*PI/NHRINGREAL
              !CALCULATE OFFSET AS 10% OF THE STEP IN PHI IF RING IS ODD OR EVEN
              M = MOD(I,2)
              IF (M.EQ.0) THEN
                  PHIOFF = 0.1*DPHI 
              ELSE
                  PHIOFF = -0.1*DPHI 
              ENDIF  
              !POPULATE HETERODOMAINS ON RINGS     
              DO K=1,NHETRING
              !CALCULATE AZIMUTHAL ANGLE
                  PHI = (K-1)*DPHI+PHIOFF
                  !FORTRAN DOES NOT RECOGNIZE ANGLE VALUES GT.2.0*PI RADIANS
                  IF (PHI.GT.(2.0*PI)) THEN 
                      PHI = 2.0*PI*((PHI)/(2.0*PI)-INT(PHI/(2.0*PI)))
                  ENDIF
                  DO J=1,HETMODEP
                      HC = HC + 1
                      IF (J.EQ.1) THEN !GENERATE LARGE HETDOMAIN
                          XHET = RRING*DCOS(PHI)+XmP0 
                          YHET = RRING*DSIN(PHI)+YmP0
                          ZHET = AP*DCOS(THETA)+ZmP0
                          RHET = RHETP0
                          BETA =ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                          ARG = (ZmP0-ZHET)/AP
                          IF (ARG.GE.1.0) THEN
                              ARG = 1.0
                              BETA = ACOS(ARG)
                          ELSEIF (ARG.LE.-1.0) THEN
                              ARG = -1.0
                              BETA = ACOS(ARG)
                          ENDIF
                          RDHET = ((XHET-XmP0)**2+
     &                            (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                          XHETP(HC) = XHET
                          YHETP(HC) = YHET
                          ZHETP(HC) = ZHET
                          RHETP(HC) = RHET
                          THETAP(HC) = THETA
                          PHIP(HC) = PHI
                          IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL))THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                              IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION 
                              ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                  DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                  DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                  DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                  A = RPRO0 !ELLIPSE MAJOR AXIS
                                  B = RPRO0*DCOS(BETA) !ELLIPSE MINOR AXIS
                                  XPRO(HC) = XHET-DX
                                  YPRO(HC) = YHET-DY
                                  RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS 
                              ENDIF
                          ENDIF
                      ELSE !GENERATE SMALL HETERODOMAINS AROUND LARGE HETERODOMAIN
                          IF (HETMODEP.EQ.5) THEN !1:4
                              IF (J.EQ.2) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.3) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.4) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.5) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              R1 = AP*DSIN(THETA1)
                              XHET = R1*DCOS(PHI1)+XmP0
                              YHET = R1*DSIN(PHI1)+YmP0
                              ZHET = AP*DCOS(THETA1)+ZmP0
                              RHET = RHETP1
                              BETA = ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                              ARG = (ZmP0-ZHET)/AP
                              IF (ARG.GE.1.0) THEN
                                  ARG = 1.0
                                  BETA = ACOS(ARG)
                              ELSEIF (ARG.LE.-1.0) THEN
                                  ARG = -1.0
                                  BETA = ACOS(ARG)
                              ENDIF
                              RDHET = ((XHET-XmP0)**2+
     &                                (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                              XHETP(HC) = XHET
                              YHETP(HC) = YHET
                              ZHETP(HC) = ZHET
                              RHETP(HC) = RHET
                              THETAP(HC) = THETA1
                              PHIP(HC) = PHI1
                              IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL)) THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                                  IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                      XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION 
                                  ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                      DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                      DX = DC*DCOS(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                      DY = DC*DSIN(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                      A = RPRO1 !ELLIPSE MAJOR AXIS
                                      B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                      XPRO(HC) = XHET-DX
                                      YPRO(HC) = YHET-DY
                                      RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS 
                                  ENDIF
                              ENDIF
                          ELSEIF (HETMODEP.EQ.9) THEN !1:8
                              IF (J.EQ.2) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.3) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.4) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.5) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.6) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA
                              ENDIF
                              IF (J.EQ.7) THEN
                                  PHI1 = PHI
                                  THETA1 = THETA + (1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.8) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA
                              ENDIF
                              IF (J.EQ.9) THEN
                                  PHI1 = PHI
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              R1 = AP*DSIN(THETA1)
                              XHET = R1*DCOS(PHI1)+XmP0
                              YHET = R1*DSIN(PHI1)+YmP0
                              ZHET = AP*DCOS(THETA1)+ZmP0
                              RHET = RHETP1
                              BETA = ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                              ARG = (ZmP0-ZHET)/AP
                              IF (ARG.GE.1.0) THEN
                                  ARG = 1.0
                                  BETA = ACOS(ARG)
                              ELSEIF (ARG.LE.-1.0) THEN
                                  ARG = -1.0
                                  BETA = ACOS(ARG)
                              ENDIF
                              RDHET = ((XHET-XmP0)**2+
     &                                (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                              XHETP(HC) = XHET
                              YHETP(HC) = YHET
                              ZHETP(HC) = ZHET
                              RHETP(HC) = RHET
                              THETAP(HC) = THETA1
                              PHIP(HC) = PHI1
                              IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL)) THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                                  IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                      XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION 
                                  ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                      DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                      DX = DC*DCOS(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                      DY = DC*DSIN(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                      A = RPRO1 !ELLIPSE MAJOR AXIS
                                      B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                      XPRO(HC) = XHET-DX
                                      YPRO(HC) = YHET-DY
                                      RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS 
                                  ENDIF
                              ENDIF
                          ENDIF
                      ENDIF
                  ENDDO  
              ENDDO 
          ENDIF
      ENDDO
C     REAL NUMBER OF HETDOMAINS
      NHETP = COUNT(RHETP.NE.0.0)
C     NUMBER OF PROJECTIONS
      NPRO = COUNT(RPRO.NE.0.0)
      
      END SUBROUTINE HETTRACKP       
      
C     PROJECTION MATRIX FOR HETERODOMAINS ON COLLOID
      SUBROUTINE PROJECTION_MATRIX(NPRO,XPRO,YPRO,RPRO,M_PRO)
      
      DOUBLE PRECISION XPRO(10000000),YPRO(10000000),RPRO(10000000)
      INTEGER I,NPRO
      DOUBLE PRECISION, DIMENSION(NPRO,3) :: M_PRO 
      DOUBLE PRECISION, ALLOCATABLE :: M_X(:),M_Y(:),M_R(:)

C     EXTRACT PROJECTION POSITION AND RADIUS
      ALLOCATE(M_X(0))
      ALLOCATE(M_Y(0))
      ALLOCATE(M_R(0))
      DO I=1,SIZE(RPRO)
      IF (RPRO(I).NE.0.0) THEN
          M_X = [M_X, XPRO(I)]
          M_Y = [M_Y, YPRO(I)]
          M_R = [M_R, RPRO(I)]
      END IF
      ENDDO
C     PROJECTION MATRIX
      M_PRO(:,1) = M_X 
      M_PRO(:,2) = M_Y
      M_PRO(:,3) = M_R
C     CLEAR ARRAYS
      DEALLOCATE(M_X)
      DEALLOCATE(M_Y)
      DEALLOCATE(M_R)
      
      END SUBROUTINE PROJECTION_MATRIX
      
C     SUBROUTINE TO DETERMINE FRACTIONAL AREA WRITTEN BY CESAR RON     
      SUBROUTINE FRACTIONAL_AREA(XP,YP,RZOI,XHET,YHET,RHET,NPRO,M1,
     &                           AF_PZ,AF_ZH,AF_PZH,AF_Z)
      
      DOUBLE PRECISION XP,YP,XmP0,YmP0,RZOI,XHET,YHET,RHET
      DOUBLE PRECISION RZ,RH,DXZH,DYZH,DZH,SUMRZH,DIFFRZH
      DOUBLE PRECISION R1,R2,D,A1,A2
      DOUBLE PRECISION R1_2,R2_2,D_2
      DOUBLE PRECISION DX12,DY12,D12,PHI12,OMEGA1_12,OMEGA2_12
      DOUBLE PRECISION X1_12,Y1_12,X2_12,Y2_12
      DOUBLE PRECISION Ao3,AF_PZ,AF_ZH,AF_PZH,AF_Z
      DOUBLE PRECISION, ALLOCATABLE :: DX(:,:),DY(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: SUMR(:,:),DIFFR(:,:),DIST(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_1(:,:),Ao2_2(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_PZ(:,:),Ao2_PH(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_ZH(:,:),Ao3_F(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_PZF(:,:),Ao2_PHF(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_ZHF(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: IZH(:,:),IPZ(:,:),IPH(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: POINTS_IP(:,:),POINTS_IZ(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: POINTS_IH(:,:)
      INTEGER, ALLOCATABLE :: PAIRS_O(:,:),PAIRS_PO(:,:),PAIRS_CO(:,:)
      INTEGER, ALLOCATABLE :: PAIRS_NO(:,:),OM_P(:,:),OM_ZH(:,:)
      INTEGER, ALLOCATABLE :: IPI(:,:),IPIP(:,:),IPIH(:,:),IPIZ(:,:)
      INTEGER NPRO,S1,S2
      INTEGER I,J,OO,PO,CO,NO,O,N,P,C,NF
      INTEGER AZH,APZ,APH
      INTEGER IPI_1,IPI_2
      INTEGER IPIP_O,IPIH_O,IPIZ_O,LOCATOR_IP,LOCATOR_IH,LOCATOR_IZ
      DOUBLE PRECISION, DIMENSION(NPRO,3) :: M1                       !PRO
      DOUBLE PRECISION, DIMENSION(2,3) :: M2                          !ZOI AND HET
      DATA PI/3.14159265359/ 
      
C     DEFINE COLLOID CENTER IN COLLECTOR FRAME OF REFERENCE
      XmP0 = XP 
      YmP0 = YP 
C     DEFINE PRO MATRIX AND ZOI-HET MATRIX
      M2(1,:) = [XmP0, YmP0, RZOI]   !ZOI
      M2(2,:) = [XHET, YHET, RHET] !HET
C     ZOI AND HET RADII
      RZ = M2(1,3)
      RH = M2(2,3)
C     ZOI-HET DISTANCES
      DXZH = M2(2,1)-M2(1,1)
      DYZH = M2(2,2)-M2(1,2)
      DZH = (DXZH**2+DYZH**2)**0.5
      SUMRZH = RZ+RH
      DIFFRZH = RZ-RH
C     ROWS IN M1 AND M2
      S1 = SIZE(M1,1)
      S2 = SIZE(M2,1)
C     X AND Y DISTANCE BETWEEN PRO AND BOTH ZOI AND HET
      ALLOCATE(DX(S1,S2))
      ALLOCATE(DY(S1,S2))
      DX(:,1) = M1(:,1)-M2(1,1)
      DX(:,2) = M1(:,1)-M2(2,1)
      DY(:,1) = M1(:,2)-M2(1,2)
      DY(:,2) = M1(:,2)-M2(2,2)
C     RADIUS SUM AND DIFFERENCE BETWEEN PRO AND BORH ZOI AND HET
      ALLOCATE(SUMR(S1,S2))
      ALLOCATE(DIFFR(S1,S2))
      SUMR(:,1) = M1(:,3)+M2(1,3) 
      SUMR(:,2) = M1(:,3)+M2(2,3)
      DIFFR(:,1) = M1(:,3)-M2(1,3)
      DIFFR(:,2) = M1(:,3)-M2(2,3)
C     TOTAL DISTANCE BETWEEN PRO AND BOTH ZOI AND HET
      ALLOCATE(DIST(S1,S2))
      DIST = (DX**2+DY**2)**0.5
C     PAIRS PRO-ZOI AND PRO-HET WHICH OVERLAP, PARTIALLY OVERLAP, AND COMPLETELY OVERLAP
      !ALLOCATE(PAIRS_O(0,2))
      OO = 0
      PO = 0
      CO = 0
      NO = 0
      DO I=1,S2
          DO J=1,S1
              IF (DIST(J,I).LT.SUMR(J,I)) THEN
                  OO = OO + 1
                  IF (DIST(J,I).GT.ABS(DIFFR(J,I))) THEN
                      PO = PO + 1
                  ELSEIF (DIST(J,I).LE.ABS(DIFFR(J,I))) THEN
                      CO = CO + 1
                  ENDIF
              ElSE
                  NO = NO + 1
              ENDIF
          ENDDO
      ENDDO
      ALLOCATE(PAIRS_O(OO,2))
      ALLOCATE(PAIRS_PO(PO,2))
      ALLOCATE(PAIRS_CO(CO,2))
      ALLOCATE(PAIRS_NO(NO,2))
      O = 0
      P = 0
      C = 0
      N = 0
      DO I=1,S2
          DO J=1,S1
              IF (DIST(J,I).LT.SUMR(J,I)) THEN
                  O = O + 1
                  PAIRS_O(O,:) = [J, I]
                  IF (DIST(J,I).GT.ABS(DIFFR(J,I))) THEN
                      P = P + 1
                      PAIRS_PO(P,:) = [J, I]
                  ELSEIF (DIST(J,I).LE.ABS(DIFFR(J,I))) THEN
                      C = C + 1
                      PAIRS_CO(C,:) = [J, I]
                  ENDIF
              ELSE
                  N = N + 1
                  PAIRS_NO(N,:) = [J, I]
              ENDIF
          ENDDO
      ENDDO
C     PRO OVERLAP MATRIX: 1 FOR PARTIAL OVERLAP, -1 FOR COMPLETE OVERLAP, 0 FOR NO OVERLAP
      ALLOCATE(OM_P(S1,S2))
      OM_P(:,:) = 0 !COLUMN 1: PRO-ZOI OVERLAP, COLUMN 2: PRO-HET OVERLAP
      DO I=1,PO
          OM_P(PAIRS_PO(I,1),PAIRS_PO(I,2)) = 1
      ENDDO
      DO I=1,CO
          OM_P(PAIRS_CO(I,1),PAIRS_CO(I,2)) = -1
      ENDDO
C     ZOI-HET OVERLAP MATRIX: 1 FOR PARTIAL OVERLAP, -1 FOR COMPLETE OVERLAP, 0 FOR NO OVERLAP  
      ALLOCATE(OM_ZH(1,1))
      OM_ZH = 0
      IF (DZH.GT.SUMRZH) THEN !NO 2 OVERLAP FOR ZOI-HET
          OM_ZH = OM_ZH
      ELSE !2 OVERLAP FOR ZOI-HET
          IF (ABS(DIFFRZH).GE.DZH) THEN !ZOI-HET COMPLETE OVERLAP
              OM_ZH = -1
          ELSE !ZOI-HET PARTIAL OVERLAP
              OM_ZH = 1
          ENDIF
      ENDIF
C     CALCULATE 2 OVERLAP AREA FOR PRO-ZOI AND PRO-HET
      ALLOCATE(Ao2_1(S1,S2))
      Ao2_1 = 0.0      
      !PRO-ZOI AND PRO-HET PARTIAL OVERLAP
      DO I=1,SIZE(PAIRS_PO(:,1))
          R1 = M1(PAIRS_PO(I,1),3)
          D = DIST(PAIRS_PO(I,1),PAIRS_PO(I,2))
          IF (PAIRS_PO(I,2).EQ.1) THEN
              R2 = M2(1,3)
          ELSE
              R2 = M2(2,3)
          ENDIF
          R1_2 = R1**2
          R2_2 = R2**2
          D_2 = D**2
          A1 = ACOS((D_2+R1_2-R2_2)/(2*D*R1))
          ARG = (D_2+R1_2-R2_2)/(2*D*R1)
          IF (ARG.GE.1.0) THEN
              ARG = 1.0
              A1 = ACOS(ARG)
          ELSEIF (ARG.LE.-1.0) THEN
              ARG = -1.0
              A1 = ACOS(ARG)
          ENDIF
          A2 = ACOS((D_2+R2_2-R1_2)/(2*D*R2))
          ARG = (D_2+R2_2-R1_2)/(2*D*R2)
          IF (ARG.GE.1.0) THEN
              ARG = 1.0
              A2 = ACOS(ARG)
          ELSEIF (ARG.LE.-1.0) THEN
              ARG = -1.0
              A2 = ACOS(ARG)
          ENDIF
          Ao2_1(PAIRS_PO(I,1),PAIRS_PO(I,2)) = R1_2*A1+R2_2*A2-0.5*
     &                                       (((-D+R1+R2)*(D+R1-R2)
     &                                       *(D-R1+R2)*(D+R1+R2))**0.5)
      ENDDO
      !PRO-ZOI AND PRO-HET COMPLETE OVERLAP    
      DO I=1,SIZE(PAIRS_CO(:,1))
          R1 = M1(PAIRS_CO(I,1),3)
          D = DIST(PAIRS_CO(I,1),PAIRS_CO(I,2))
          IF (PAIRS_CO(I,2).EQ.1) THEN
              R2 = M2(1,3)
          ELSE
              R2 = M2(2,3)
          ENDIF
          IF (R1.GT.R2) THEN
              Ao2_1(PAIRS_CO(I,1),PAIRS_CO(I,2)) = PI*(R2**2)
          ELSE
              Ao2_1(PAIRS_CO(I,1),PAIRS_CO(I,2)) = PI*(R1**2)
          ENDIF
      ENDDO
C     CALCULATE 2 OVERLAP AREA FOR PRO-ZOI AND PRO-HET
      ALLOCATE(Ao2_2(1,1))
      Ao2_2 = 0
      R1 = RZ
      R2 = RH
      R1_2 = RZ**2
      R2_2 = RH**2
      D = DZH
      D_2 = DZH**2
      IF (D.LT.(R1+R2)) THEN 
          IF (ABS(R1-R2).GE.D) THEN
              IF (R1.GT.R2) THEN
                  Ao2_2 = PI*R2**2
              ELSE
                  Ao2_2 = PI*R1**2
              ENDIF
          ELSE
              A1 = ACOS((D_2+R1_2-R2_2)/(2*D*R1))
              ARG = (D_2+R1_2-R2_2)/(2*D*R1)
              IF (ARG.GE.1.0) THEN
                  ARG = 1.0
                  A1 = ACOS(ARG)
              ELSEIF (ARG.LE.-1.0) THEN
                  ARG = -1.0
                  A1 = ACOS(ARG)
              ENDIF
              A2 = ACOS((D_2+R2_2-R1_2)/(2*D*R2))
              ARG = (D_2+R2_2-R1_2)/(2*D*R2)
              IF (ARG.GE.1.0) THEN
                  ARG = 1.0
                  A2 = ACOS(ARG)
              ELSEIF (ARG.LE.-1.0) THEN
                  ARG = -1.0
                  A2 = ACOS(ARG)
              ENDIF
              Ao2_2 = R1_2*A1+R2_2*A2-0.5*(((-D+R1+R2)*(D+R1-R2)
     &                 *(D-R1+R2)*(D+R1+R2))**0.5)
          ENDIF
      ENDIF
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI
      ALLOCATE(Ao2_PZ(S1,1))
      Ao2_PZ = 0.0
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI    
      ALLOCATE(Ao2_PH(S1,1))
      Ao2_PH = 0.0
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI 
      ALLOCATE(Ao2_ZH(S1,1))
      Ao2_ZH = 0.0
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI 
      ALLOCATE(Ao3_F(S1,1))
      Ao3_F = 0.0
C     DETERMINE 2 OR 3 OVERLAP AREA FOR EACH PRO
      DO I=1,S1 ![1] LOOP THROUGH EACH PRO
          AZH = OM_ZH(1,1)
          APZ = OM_P(I,1)
          APH = OM_P(I,2)
          IF ((APZ.EQ.1).AND.(APH.EQ.1)) THEN ![2] PRO-ZOI PARTIAL OVERLAP, PRO-HET PARTIAL OVERLAP
              IF (AZH.EQ.0) THEN ![3] NO ZOI-HET OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !ZOI-HET INTERSECTION POINTS
                  ALLOCATE(IZH(2,2))
                  CALL INTERSECTION_POINTS(RZ,RH,M2(1,1),M2(1,2),
     &                                     M2(2,1),M2(2,2),
     &                                     XP,YP,X1_12,Y1_12,
     &                                     X2_12,Y2_12)
                  IZH(1,:) = [X1_12, Y1_12]
                  IZH(2,:) = [X2_12, Y2_12]
                  !ZOI-HET INTERSECTION POINTS INSIDE PRO: 1 FOR INSIDE, 0 FOR OUTSIDE
                  ALLOCATE(IPIP(2,1))
                  CALL INSIDE_CIRCLE(M1(I,1),M1(I,2),M1(I,3),
     &                               IZH,IPI_1,IPI_2)
                  IPIP(1,1) = IPI_1
                  IPIP(2,1) = IPI_2
                  !PRO-ZOI INTERSECTION POINTS
                  ALLOCATE(IPZ(2,2))
                  CALL INTERSECTION_POINTS(RZ,M1(I,3),M2(1,1),M2(1,2),
     &                                     M1(I,1),M1(I,2),             
     &                                     XP,YP,X1_12,Y1_12,
     &                                     X2_12,Y2_12)
                  IPZ(1,:) = [X1_12, Y1_12]
                  IPZ(2,:) = [X2_12, Y2_12]
                  !PRO-ZOI INTERSECTION POINTS INSIDE HET: 1 FOR INSIDE, 0 FOR OUTSIDE
                  ALLOCATE(IPIH(2,1))
                  CALL INSIDE_CIRCLE(M2(2,1),M2(2,2),M2(2,3),
     &                               IPZ,IPI_1,IPI_2)
                  IPIH(1,1) = IPI_1
                  IPIH(2,1) = IPI_2
                  !PRO-HET INTERSECTION POINTS
                  ALLOCATE(IPH(2,2))
                  CALL INTERSECTION_POINTS(RH,M1(I,3),M2(2,1),M2(2,2),
     &                                     M1(I,1),M1(I,2),             
     &                                     M2(2,1),M2(2,2),X1_12,Y1_12,
     &                                     X2_12,Y2_12)
                  IPH(1,:) = [X1_12, Y1_12]
                  IPH(2,:) = [X2_12, Y2_12]
                  !PRO-HET INTERSECTION POINTS INSIDE ZOI: 1 FOR INSIDE, 0 FOR OUTSIDE
                  ALLOCATE(IPIZ(2,1))
                  CALL INSIDE_CIRCLE(M2(1,1),M2(1,2),M2(1,3),
     &                               IPH,IPI_1,IPI_2)
                  IPIZ(1,1) = IPI_1
                  IPIZ(2,1) = IPI_2
                  !DECIDE IF 3 OVERLAP OR 2 OVERLAP AREA CALCULATION
                  IPIP_O = 0
                  IPIH_O = 0
                  IPIZ_O = 0
                  DO J=1,SIZE(IPIP(:,1))
                      IF (IPIP(J,1).EQ.1) THEN
                          IPIP_O = J
                      END IF
                      IF (IPIH(J,1).EQ.1) THEN
                          IPIH_O = J
                      END IF
                      IF (IPIZ(J,1).EQ.1) THEN
                          IPIZ_O = J
                      END IF
                  ENDDO
                  IF ((IPIP_O.EQ.0).AND.(IPIH_O.EQ.0)
     &                .AND.(IPIZ_O.EQ.0)) THEN !2 OVERLAP AREA
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = 0.0
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)
                      DEALLOCATE(IZH)
                      DEALLOCATE(IPZ)
                      DEALLOCATE(IPH)
                      DEALLOCATE(IPIP)
                      DEALLOCATE(IPIH)
                      DEALLOCATE(IPIZ)
                  ELSE !3 OVERLAP AREA
                      !POINTS CORRESPONDING TO VERTICES OF POLYGON REQUIRED FOR 3 OVERLAP AREA CALCULATION
                      LOCATOR_IP = IPIP_O
                      LOCATOR_IH = IPIH_O
                      LOCATOR_IZ = IPIZ_O
                      !DECIDE IF POLYGON WITHIN 3 OVERLAP AREA IS FORMED BY 3 OR 4 POINTS
                      IF ((LOCATOR_IH.EQ.0).AND.(LOCATOR_IP.NE.0)
     &                    .AND.(LOCATOR_IZ.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 4 POINTS
                          ALLOCATE(POINTS_IP(2,2))
                          CALL INTERSECTION_POINTS(RZ,RH,
     &                                             M2(1,1),M2(1,2),
     &                                             M2(2,1),M2(2,2),     
     &                                             XP,YP,
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IP(1,:) = [X1_12, Y1_12]
                          POINTS_IP(2,:) = [X2_12, Y2_12]
                          ALLOCATE(POINTS_IZ(2,2))
                          CALL INTERSECTION_POINTS(RH,M1(I,3),
     &                                             M2(2,1),M2(2,2),
     &                                             M1(I,1),M1(I,2),     
     &                                             M2(2,1),M2(2,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IZ(1,:) = [X1_12, Y1_12]
                          POINTS_IZ(2,:) = [X2_12, Y2_12]
                          !3 OVERLAP AREA
                          CALL OVERLAP4(POINTS_IP,POINTS_IZ,
     &                                  RH,RZ,M1(I,3),Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IP)
                          DEALLOCATE(POINTS_IZ)
                      ELSEIF ((LOCATOR_IZ.EQ.0).AND.(LOCATOR_IP.NE.0)
     &                       .AND.(LOCATOR_IH.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 4 POINTS
                          ALLOCATE (POINTS_IP(2,2))
                          CALL INTERSECTION_POINTS(RZ,RH,
     &                                             M2(1,1),M2(1,2),
     &                                             M2(2,1),M2(2,2),     
     &                                             XP,YP,
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IP(1,:) = [X1_12, Y1_12]
                          POINTS_IP(2,:) = [X2_12, Y2_12]
                          ALLOCATE(POINTS_IH(2,2))
                          CALL INTERSECTION_POINTS(M1(I,3),RZ,
     &                                             M1(I,1),M1(I,2),
     &                                             M2(1,1),M2(1,2),     
     &                                             M1(I,1),M1(I,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IH(1,:) = [X1_12, Y1_12]
                          POINTS_IH(2,:) = [X2_12, Y2_12]
                          !3 OVERLAP AREA
                          CALL OVERLAP4(POINTS_IP,POINTS_IH,
     &                                  RZ,RH,M1(I,3),Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IP)
                          DEALLOCATE(POINTS_IH)
                      ELSEIF ((LOCATOR_IP.EQ.0).AND.(LOCATOR_IZ.NE.0)
     &                       .AND.(LOCATOR_IH.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 4 POINTS    
                          ALLOCATE (POINTS_IZ(2,2))
                          CALL INTERSECTION_POINTS(RH,M1(I,3),
     &                                             M2(2,1),M2(2,2),
     &                                             M1(I,1),M1(I,2),     
     &                                             M2(2,1),M2(2,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IZ(1,:) = [X1_12, Y1_12]
                          POINTS_IZ(2,:) = [X2_12, Y2_12]
                          ALLOCATE(POINTS_IH(2,2))
                          CALL INTERSECTION_POINTS(M1(I,3),RZ,
     &                                             M1(I,1),M1(I,2),
     &                                             M2(1,1),M2(1,2),     
     &                                             M1(I,1),M1(I,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IH(1,:) = [X1_12, Y1_12]
                          POINTS_IH(2,:) = [X2_12, Y2_12]
                          !3 OVERLAP AREA
                          CALL OVERLAP4(POINTS_IZ,POINTS_IH,
     &                                  M1(I,3),RH,RZ,Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IH)
                          DEALLOCATE(POINTS_IZ)
                      ELSEIF ((LOCATOR_IP.EQ.0).AND.(LOCATOR_IH.EQ.0)
     &                       .AND.(LOCATOR_IZ.NE.0)) THEN !3 OVERLAP AREA CORRESPOND TO PRO-HET 2 OVERLAP AREA
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_1(I,2)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                      ELSEIF ((LOCATOR_IP.NE.0).AND.(LOCATOR_IH.NE.0)
     &                       .AND.(LOCATOR_IZ.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 3 POINTS
                          ALLOCATE (POINTS_IH(1,2))
                          ALLOCATE (POINTS_IZ(1,2))
                          ALLOCATE (POINTS_IP(1,2))
                          POINTS_IH(1,:) = IPZ(LOCATOR_IH,:)
                          POINTS_IZ(1,:) = IPH(LOCATOR_IZ,:)
                          POINTS_IP(1,:) = IZH(LOCATOR_IP,:)
                          !3 OVERLAP AREA
                          CALL OVERLAP3(POINTS_IH,POINTS_IP,POINTS_IZ,
     &                                  M1(I,3),RZ,RH,Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IP)
                          DEALLOCATE(POINTS_IH)
                          DEALLOCATE(POINTS_IZ)
                      ELSE
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = 0.0
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                      ENDIF
                  ENDIF
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF (RZ.GE.RH) THEN ![4] ZOI >= HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (RH.GT.RZ) THEN ![4] HET > ZOI
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)      
                  ENDIF ![4] END
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.1).AND.(APH.EQ.-1)) THEN ![2] PRO-ZOI PARTIAL OVERLAP, PRO-HET COMPLETE OVERLAP
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0  
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  IF (RH.GE.M1(I,3)) THEN ![4] HET >= PRO
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (M1(I,3).GT.RH) THEN ![4] PRO > HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0      
                  ENDIF ![4] END
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF (RH.GE.M1(I,3)) THEN ![4] HET >= PRO
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (M1(I,3).GT.RH) THEN ![4] PRO > HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0     
                  ENDIF ![4] END
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.-1).AND.(APH.EQ.1)) THEN ![2] PRO-ZOI COMPLETE OVERLAP, PRO-HET PARTIAL OVERLAP   
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0   
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  IF (RZ.GE.M1(I,3)) THEN ![4] ZOI >= PRO
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (M1(I,3).GT.RZ) THEN ![4] PRO > ZOI
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0       
                  ENDIF![4] END
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF (RZ.GE.RH) THEN ![4] ZOI >= HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (RH.GT.RZ) THEN ![4] HET > ZOI
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0     
                  ENDIF ![4] END
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.-1).AND.(APH.EQ.-1)) THEN ![2] PRO-ZOI COMPLETE OVERLAP, PRO-HET COMPLETE OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)    
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  IF ((M1(I,3).GE.RZ).AND.(M1(I,3).GE.RH)) THEN ![4] 
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0    
                  ELSE ![4] 
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1) 
                  ENDIF ![4] END
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF ((RZ.GE.RH).AND.(RZ.GE.M1(I,3))) THEN ![4]
                      IF (RH.GE.M1(I,3)) THEN ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_1(I,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)      
                      ELSEIF (M1(I,3).GT.RH) THEN  ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0  
                      ENDIF  ![5] END
                  ELSEIF ((RH.GE.RZ).AND.(RH.GE.M1(I,3))) THEN ![4]
                      IF (RZ.GE.M1(I,3)) THEN ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_1(I,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)      
                      ELSEIF (M1(I,3).GT.RZ) THEN  ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0  
                      ENDIF  ![5] END
                  ELSEIF ((M1(I,3).GE.RZ).AND.(M1(I,3).GE.RH)) THEN ![4] 
                      IF (RZ.GE.RH) THEN ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0      
                      ELSEIF (RH.GT.RZ) THEN  ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0  
                      ENDIF ![5] END
                  ENDIF ![4] END    
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.1).AND.(APH.EQ.0)) THEN ![2] PRO-ZOI PARTIAL OVERLAP, PRO-HET NO OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.0).AND.(APH.EQ.1)) THEN ![2] PRO-ZOI NO OVERLAP, PRO-HET PARTIAL OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.-1).AND.(APH.EQ.0)) THEN ![2] PRO-ZOI COMPLETE OVERLAP, PRO-HET NO OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.0).AND.(APH.EQ.-1)) THEN ![2] PRO-ZOI NO OVERLAP, PRO-HET COMPLETE OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.0).AND.(APH.EQ.0)) THEN ![2] PRO-ZOI NO OVERLAP, PRO-HET NO OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSE ![2] ANY OTHER CASES WHERE NO 3 OVERLAP OCCURS
              !3 OVERLAP AREA
              Ao3_F(I,1) = 0.0
              !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
              Ao2_PZ(I,1) = 0.0
              Ao2_PH(I,1) = 0.0
              Ao2_ZH(I,1) = 0.0        
          ENDIF ![2] END
      ENDDO ![1] END OF: LOOP THROUGH EACH PRO
C     FINAL OVERLAPPING AREA
      !PRO-ZOI
      ALLOCATE(Ao2_PZF(S1,1))
      Ao2_PZF = Ao2_PZ
      !PRO-HET
      ALLOCATE(Ao2_PHF(S1,1))
      Ao2_PHF = Ao2_PH
      !ZOI-HET
      ALLOCATE(Ao2_ZHF(1,1))
      IF (SUM(Ao2_ZH).GT.0.0) THEN
          Ao2_ZHF = Ao2_2(1,1)
          DO I=1,S1
              Ao2_ZHF = Ao2_ZHF-Ao3_F(I,1)
          ENDDO
      ELSE
          Ao2_ZHF = 0.0
      ENDIF
C     CALCULATE ATTRACTIVE FRACTIONAL AREAS
      AF_PZ = SUM(Ao2_PZF)/(PI*RZ**2)
      AF_ZH = SUM(Ao2_ZHF)/(PI*RZ**2)
C     CALCULATE REPULSIVE FRACTIONAL AREAS
      AF_PZH = SUM(Ao3_F)/(PI*RZ**2)
      AF_Z = 1-AF_PZ-AF_ZH-AF_PZH
      END SUBROUTINE FRACTIONAL_AREA
          
C     SUBROUTINE TO DETERMINE INTERSECTION POINTS BETWEEN 2 OVERLAPPING CIRCLES      
      SUBROUTINE INTERSECTION_POINTS(R1,R2,X1,Y1,X2,Y2,X0,Y0,
     &                               X1_12,Y1_12,X2_12,Y2_12)

      DOUBLE PRECISION R1,R2,X1,Y1,X2,Y2,X0,Y0
      DOUBLE PRECISION R1_2,R2_2,DX12,DY12,D12,D12_2
      DOUBLE PRECISION PHI12,PSI12,OMEGA1_12,OMEGA2_12
      DOUBLE PRECISION X1_12,Y1_12,X2_12,Y2_12
      DATA PI/3.14159265359/

      R1_2 = R1**2
      R2_2 = R2**2 
      DX12 = X2-X1
      DY12 = Y2-Y1 
      D12 = (DX12**2+DY12**2)**0.5
      D12_2 = DX12**2+DY12**2
      IF (DY12.LT.0.0) THEN
          PHI12 = 2*PI-ACOS(DX12/D12)
      ELSE
          PHI12 = ACOS(DX12/D12)
      ENDIF
      PSI12 = ACOS((R1_2+D12_2-R2_2)/(2*R1*D12))
      ARG = (R1_2+D12_2-R2_2)/(2*R1*D12)
      IF (ARG.GE.1.0) THEN
          ARG = 1.0
          PSI12 = ACOS(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          PSI12 = ACOS(ARG)
      ENDIF
      OMEGA1_12 = PHI12 + PSI12
      OMEGA2_12 = PHI12 - PSI12
      X1_12 = DCOS(OMEGA1_12)*R1+X0
      Y1_12 = DSIN(OMEGA1_12)*R1+Y0
      X2_12 = DCOS(OMEGA2_12)*R1+X0
      Y2_12 = DSIN(OMEGA2_12)*R1+Y0  
      
      END SUBROUTINE INTERSECTION_POINTS

C     SUBROUTINE TO DETERMINE INTERSECTIONS POINTS INSIDE A CIRCLE  
      SUBROUTINE INSIDE_CIRCLE(X3,Y3,R3,IP,IPI_1,IPI_2)
      
      DOUBLE PRECISION X3,Y3,R3,DI
      DOUBLE PRECISION, DIMENSION(2,2) :: IP
      INTEGER, ALLOCATABLE :: IPI(:,:)
      INTEGER J,IPI_1,IPI_2
      
      ALLOCATE(IPI(2,1))
      IPI = 0
      DO J=1,SIZE(IP(:,1))
          DI = ((IP(J,1)-X3)**2+(IP(J,2)-Y3)**2)**0.5
          IF (DI.LE.R3) THEN
              IPI(J,1) = 1
          ENDIF
      ENDDO
      IPI_1 = IPI(1,1)
      IPI_2 = IPI(2,1)
      
      END SUBROUTINE INSIDE_CIRCLE

C     SUBROUTINE TO DETERMINE 3 OVERLAP AREA WITH 4 INTERECTION POINTS
      SUBROUTINE OVERLAP4(POINTS_AB,POINTS_CD,R1,R2,R3,Ao3)
      
      DOUBLE PRECISION XA,YA,XB,YB,XC,YC,XD,YD
      DOUBLE PRECISION DX_AB,DY_AB,DX_CD,DY_CD,DX_AC,DY_AC
      DOUBLE PRECISION DX_BD,DY_BD,DX_AD,DY_AD,DX_BC,DY_BC
      DOUBLE PRECISION D_AB,D_CD,D_AC,D_DB
      DOUBLE PRECISION D_AD,D_BC
      DOUBLE PRECISION THETA_AB,THETA_CD,THETA_AC,THETA_BD
      DOUBLE PRECISION AQ_ABCD,ACS_AB,ACS_CD,ACS_AC,ACS_DB
      DOUBLE PRECISION R1,R2,R3,Ao3
      DOUBLE PRECISION, DIMENSION(2,2) :: POINTS_AB,POINTS_CD
      
      !POLYGON COORDINATES
      XA = POINTS_AB(1,1)
      YA = POINTS_AB(1,2)
      XB = POINTS_AB(2,1)
      YB = POINTS_AB(2,2)
      XC = POINTS_CD(1,1)
      YC = POINTS_CD(1,2)
      XD = POINTS_CD(2,1)
      YD = POINTS_CD(2,2)
      !DISTANCE BETWEEN POINTS OF THE POLYGON
      DX_AB = XA-XB
      DY_AB = YA-YB
      DX_CD = XC-XD
      DY_CD = YC-YD
      DX_AC = XA-XC
      DY_AC = YA-YC
      DX_BD = XB-XD
      DY_BD = YB-YD
      DX_AD = XA-XD
      DY_AD = YA-YD
      DX_BC = XB-XC
      DY_BC = YB-YC
      !LONGITUDE OF POLYGON SIDES
      D_AB = (DX_AB**2+DY_AB**2)**0.5
      D_CD = (DX_CD**2+DY_CD**2)**0.5
      D_AC = (DX_AC**2+DY_AC**2)**0.5
      D_BD = (DX_BD**2+DY_BD**2)**0.5
      !LONGITUDE OF POLYGON DIAGONALS
      D_AD = (DX_AD**2+DY_AD**2)**0.5
      D_BC = (DX_BC**2+DY_BC**2)**0.5
      !AREA OF POLYGON (QUADRILATERAL)
      AQ_ABCD = 0.25*(4*D_AD**2*D_BC**2
     &          -(D_AB**2+D_CD**2-D_AC**2-D_BD**2)**2)**0.5
      !ANGLE OF CIRCULAR SEGMENT
      THETA_AB = 2*ASIN(D_AB/(2*R2))
      ARG = D_AB/(2*R2)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AB = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AB = 2*ASIN(ARG)
      ENDIF
      THETA_CD = 2*ASIN(D_CD/(2*R3))
      ARG = D_CD/(2*R3)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_CD = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_CD = 2*ASIN(ARG)
      ENDIF
      THETA_AC = 2*ASIN(D_AC/(2*R1))
      ARG = D_AC/(2*R1)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AC = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AC = 2*ASIN(ARG)
      ENDIF
      THETA_BD = 2*ASIN(D_BD/(2*R1))
      ARG = D_BD/(2*R1)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_BD = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_BD = 2*ASIN(ARG)
      ENDIF
      !AREA OF CIRCULAR SEGMENT
      ACS_AB = 0.5*R2**2*(THETA_AB-DSIN(THETA_AB))
      ACS_CD = 0.5*R3**2*(THETA_CD-DSIN(THETA_CD))
      ACS_AC = 0.5*R1**2*(THETA_AC-DSIN(THETA_AC))
      ACS_BD = 0.5*R1**2*(THETA_BD-DSIN(THETA_BD))
      !TOTAL 3 OVERLAP AREA
      Ao3 = ACS_AB+ACS_CD+ACS_AC+ACS_BD+AQ_ABCD
      
      END SUBROUTINE OVERLAP4
      
C     SUBROUTINE TO DETERMINE 3 OVERLAP AREA WITH 3 INTERECTION POINTS
      SUBROUTINE OVERLAP3(POINTS_A,POINTS_B,POINTS_C,R1,R2,R3,Ao3)
      
      DOUBLE PRECISION R1,R2,R3
      DOUBLE PRECISION R1_2,R2_2,R3_2
      DOUBLE PRECISION DX_AB,DY_AB,DX_BC,DY_BC,DX_AC,DY_AC
      DOUBLE PRECISION D_AB,D_BC,D_AC
      DOUBLE PRECISION THETA_AB,THETA_BC,THETA_AC
      DOUBLE PRECISION S,AT_ABC,ACS_AB,ACS_BC,ACS_ACM,Ao3
      DOUBLE PRECISION, DIMENSION(1,2) :: POINTS_A,POINTS_B,POINTS_C
      
      R1_2 = R1**2
      R2_2 = R2**2
      R3_2 = R3**2
      !DISTANCE BETWEEN POINTS OF THE TRIANGLE
      DX_AB = POINTS_A(1,1)-POINTS_B(1,1)
      DY_AB = POINTS_A(1,2)-POINTS_B(1,2)
      DX_BC = POINTS_C(1,1)-POINTS_B(1,1)
      DY_BC = POINTS_C(1,2)-POINTS_B(1,2)
      DX_AC = POINTS_C(1,1)-POINTS_A(1,1)
      DY_AC = POINTS_C(1,2)-POINTS_A(1,2)
      !LONGITUDE OF TRIANGLE SIDES 
      D_AB = (DX_AB**2+DY_AB**2)**0.5  
      D_BC = (DX_BC**2+DY_BC**2)**0.5
      D_AC = (DX_AC**2+DY_AC**2)**0.5
      ! AREA OF TRIANGLE
      S = 0.5*(D_AB+D_BC+D_AC)
      AT_ABC = (S*(S-D_AB)*(S-D_BC)*(S-D_AC))**0.5
      !ANGLES OF CIRCULAR SEGMENT
      THETA_AB = 2*ASIN(D_AB/(2*R2))
      ARG = D_AB/(2*R2)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AB = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AB = 2*ASIN(ARG)
      ENDIF
      THETA_BC = 2*ASIN(D_BC/(2*R3))
      ARG = D_BC/(2*R3)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_BC = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_BC = 2*ASIN(ARG)
      ENDIF
      THETA_AC = 2*ASIN(D_AC/(2*R1))
      ARG = D_AC/(2*R1)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AC = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AC = 2*ASIN(ARG)
      ENDIF
      !AREA OF CICULAR SEGMENT
      ACS_AB = 0.5*R2_2*(THETA_AB-DSIN(THETA_AB))
      ACS_BC = 0.5*R3_2*(THETA_BC-DSIN(THETA_BC))
      ACS_AC = 0.5*R1_2*(THETA_AC-DSIN(THETA_AC))
      !TOTAL 3 OVERLAP AREA
      Ao3 = AT_ABC+ACS_AB+ACS_BC+ACS_AC
      
      END SUBROUTINE OVERLAP3      

!	SUBROUTINE FROM KIRK NELSON AND TIM GINN TO CONVERT UNIFORM DISTRIBUTION WITH RANGE 0 TO 1
!	TO GAUSSIAN DISTRIBUTION WITH ZERO MEAN AND UNIT VARIANCE	
!	Curve fitting of output from ni.f90 (or ni2.f90) which was
!	adapted from Cunningham (1969), Appl. Stat., vol. 18, no. 3
	subroutine calc_ni(bigni,ni)
	implicit none
	DOUBLE PRECISION off1,off2,off3,a,b,c
	DOUBLE PRECISION, intent(in)::bigni
	DOUBLE PRECISION, intent(out)::ni

	off1 = 1
	off2 = 1
	off3 = 1
	a = -1.0
	b = -1.0
	c = -1.0

	IF (bigni<=.001d0) THEN
		ni = -1.37855370200823D19*bigni**6 +
     &		  4.979009889572070D16*bigni**5 -
     &		  7.214759669310110D13*bigni**4 +
     &		  5.395500767177740D10*bigni**3 - 
     &          2.260106114986480D7*bigni**2 +
     &		  5.826517832043450D3*bigni - 4.129164575760240D0
	ELSE IF (bigni>=.001d0 .and. bigni<.01d0) THEN
	    ni = -6.18440506368D12*bigni**6 +
     &		  2.367655494581510D11*bigni**5 - 
     &          3.71327758909687D9*bigni**4 + 
     &		  3.098709790040470D7*bigni**3 - 
     &          1.51794899112573D5*bigni**2 +
     &		  4.96459221152939D2*bigni - 3.45983671935511D0
	ELSE IF (bigni>=.01d0 .and. bigni<.1d0) THEN
		ni = -6.63992198925781D6*bigni**6 + 
     &		  2.55090340507925D6*bigni**5 - 
     &          4.03094347079323D5*bigni**4 +
     &		  3.41189134002463D4*bigni**3 - 
     &          1.71427218447456D3*bigni**2 + 
     &		  5.95899557785023D1*bigni - 2.77770616554113D0
	ELSE IF (bigni>=.1d0 .and. bigni<.5d0) THEN
		ni = -2.07333319758618D1*bigni**4 +
     &		  3.32434759389286D1*bigni**3 - 
     &          2.07730620338030D1*bigni**2 + 
     &		  8.58215179655931D0*bigni - 1.95934743109075D0
	ELSE IF (bigni>=.5d0 .and. bigni<.9d0) THEN
		ni =  2.0720122918894D1*bigni**4 - 
     &		  4.96540631938802D1*bigni**3 +
     &		  4.54066630995313D1*bigni**2 -
     &		  1.61509902781561D1*bigni + 1.63751297685375D0
	ELSE IF (bigni>=.9d0 .and. bigni<.99d0) THEN
		ni = -1*(-6.63992198925781D6*(a*bigni+off1)**6 + 
     &		  2.55090340507925D6*(a*bigni+off1)**5 - 
     &          4.03094347079323D5*(a*bigni+off1)**4 +
     &		  3.41189134002463D4*(a*bigni+off1)**3 - 
     &          1.71427218447456D3*(a*bigni+off1)**2 + 
     &		  5.95899557785023D1*(a*bigni+off1) - 2.77770616554113D0)
	ELSE IF (bigni>=.99d0 .and. bigni<.9996d0) THEN
	    ni = -1*(-6.18440506368D12*(b*bigni+off2)**6 +
     &		  2.367655494581510D11*(b*bigni+off2)**5 - 
     &          3.71327758909687D9*(b*bigni+off2)**4 + 
     &		  3.098709790040470D7*(b*bigni+off2)**3 - 
     &          1.51794899112573D5*(b*bigni+off2)**2 +
     &		  4.96459221152939D2*(b*bigni+off2) - 3.45983671935511D0)
	ELSE
		ni = -1*(+1.37855370200823D19*(c*bigni+off3)**6 +
     &		  4.979009889572070D16*(c*bigni+off3)**5 -
     &		  7.214759669310110D13*(c*bigni+off3)**4 +
     &		  5.395500767177740D10*(c*bigni+off3)**3 - 
     &          2.260106114986480D7*(c*bigni+off3)**2 +
     &		  5.826517832043450D3*(c*bigni+off3) - 4.129164575760240D0)
	END IF
	RETURN
	end subroutine    

!***************************************************************
!            Pacific Northwest National Laboratory
!***************************************************************
!
! NAME:  Module file "random"
!
! VERSION and DATE: 1.0 8-06-98
!
! PURPOSE:  Random number generation
!
! RETURNS:
!
! REQUIRED:
!
! LOCAL VARIABLES:
!
! COMMENTS: 
!
! MOD HISTORY: 
!
!
!***************************************************************
!***************************************************************

      SUBROUTINE generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &                         nrand)
!	Generates three random numbers from UNIF[0,1]     
	INTEGER i,nrand
	DOUBLE PRECISION :: rnum1, rnum2, rnum3, rnumvec(6)
      DOUBLE PRECISION :: rsign1,rsign2,rsign3
      nrand = 6
!	Set the type of random number generator
!	intrinsinc Fortran r.n. generator for now
!	Call the uniform(0,1) random number generator
      DO i = 1, nrand
          CALL RANDOM_NUMBER(rnumvec(i))
      ENDDO
!	Fill the random number structure
      rsign1 = rnumvec(1) 
      rnum1 = rnumvec(2)
      rsign2  = rnumvec(3)
      rnum2 = rnumvec(4)
      rsign3 = rnumvec(5) 
      rnum3 = rnumvec(6)
!     Assign sign values to rsign variables depending center point of range of distribution 0 to 1
      IF (rsign1.GE.0.5) THEN
          rsign1 = 1.0
      ELSE
          rsign1 = -1.0
      ENDIF
      IF (rsign2.GE.0.5) THEN
          rsign2 = 1.0
      ELSE
          rsign2 = -1.0
      ENDIF
      IF (rsign3.GE.0.5) THEN
          rsign3 = 1.0
      ELSE
          rsign3 = -1.0
      ENDIF
	END SUBROUTINE generate_unif

************************************************************************
C 	BEGIN CLUSTER FUNCTIONS AND SUBROUTINES

      character*(*) function chri(i)
C     returns a character version of the integer i
C     chri must be declared as character*n in calling routine
      
      implicit real*8(a-h,o-z)
      character*5 fmt
      character*40 hold
      character*755 cdum
      common/chrcm/fmt,hold,cdum
      fmt='(i40)'
      write(hold,fmt) i
      call chrpak(hold,40,l)
      chri=hold(1:l)
      return
      end

      subroutine chrpak(c,lmax,lc)
C     packs out blanks in a character string whose maximum length is lmax
C     lc is returned as the packed length.
      
      character*(*) c
      character*800 ct
      common/chrcm/ct
      k=0
      do 10 i=1,lmax
          if(c(i:i).ne.' ') then
            k=k+1
            if(k.gt.800) stop 'abort - maxed out in chrpak'
            ct(k:k)=c(i:i)
          end if
   10 continue
      lc=k
      c=ct(1:lc)
      return
      end
      
C     SUBROUTINE TO INITIALIZE RANDOM SEED DIFFERENT PER EACH IPART AND SYSTEM TIME
      subroutine init_random_seed()
        use iso_fortran_env, only: int64
        implicit none
        integer, allocatable :: seed(:)
        integer :: i, n, un, istat, dt(8), pid, getpid
        integer(int64) :: t
      
        call random_seed(size = n)
        allocate(seed(n))
        ! First try if the OS provides a random number generator
        open(newunit=un, file="/dev/urandom", access="stream", 
     &    form="unformatted", action="read", status="old", iostat=istat)
        if (istat == 0) then
           read(un) seed
           close(un)
        else
           ! Fallback to XOR:ing the current time and pid. The PID is
           ! useful in case one launches multiple instances of the same
           ! program in parallel.
           call system_clock(t)
           if (t == 0) then
              call date_and_time(values=dt)
              t = (dt(1) - 1970) * 365_int64 * 24 * 60 * 60 * 1000 
     &             + dt(2) * 31_int64 * 24 * 60 * 60 * 1000 
     &             + dt(3) * 24_int64 * 60 * 60 * 1000 
     &             + dt(5) * 60 * 60 * 1000 
     &             + dt(6) * 60 * 1000 + dt(7) * 1000 
     &             + dt(8)
           end if
           pid = getpid()
           t = ieor(t, int(pid, kind(t)))
           do i = 1, n
              seed(i) = lcg(t)
           end do
        end if
        call random_seed(put=seed)
      contains
        ! This simple PRNG might not be good enough for real work, but is
        ! sufficient for seeding a better PRNG.
        function lcg(s)
          integer :: lcg
          integer(int64) :: s
          if (s == 0) then
             s = 104729
          else
             s = mod(s, 4294967296_int64)
          end if
          s = mod(s * 279470273_int64, 4294967291_int64)
          lcg = int(mod(s, int(huge(0), int64)), kind(0))
        end function lcg
      end subroutine init_random_seed

C 	END CLUSTER FUNCTIONS AND SUBROUTINES
************************************************************************