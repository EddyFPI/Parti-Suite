      PROGRAM HAPHETLN
C     PROGRAM TO SIMULATE PARTICLE TRAJECTORIES IN HAPPEL SPHERE-IN-CELL

C     DEFINE ARRAYS FIRST
      DIMENSION IOT(50000)                                            !STEP NUMBER
      DIMENSION XOT(50000),YOT(50000),ROT(50000),ZOT(50000)           !PARTICLE POSITION
      DIMENSION HOT(50000)                                            !SEPARATION DISTANCE
      DIMENSION ETIMEOT(50000),PTIMEFOT(50000)                        !TRAJECTORY TIME, ELAPSED AND REAL
      DIMENSION FCOLLOT(50000),FVDWOT(50000),FEDLOT(50000)            !TOTAL COLLOIDAL, VDW, AND EDL FORCES
      DIMENSION FABOT(50000),FSTEOT(50000),FBORNOT(50000)             !ACID-BASE, STERIC, AND BORN FORCES
      DIMENSION UTOT(50000),UNOT(50000),VTOT(50000),VNOT(50000)       !PARTICLE AND FLUID VELOCITIES, TANGENTIAL AND NORMAL
      DIMENSION FDRGTOT(50000),FDRGNOT(50000)                         !DRAG FORCE, TANGENTIAL AND NORMAL
      DIMENSION FDIFXOT(50000),FDIFYOT(50000),FDIFZOT(50000)          !DIFFUSION FORCE
      DIMENSION FGTOT(50000),FGNOT(50000),FLIFTOT(50000)              !GRAVITY AND LIFT FORCE
      DIMENSION ACONTOT(50000),RZOIOT(50000),AFRACTOT(50000)          !CONTACT RADIUS,RZOI,AND FRACTION OF ZOI OVER HET
      DIMENSION XHET(100),YHET(100),ZHET(100),RHET(100)               !HET LOCATIONS
      DIMENSION XHET_T(100),YHET_T(100),ZHET_T(100)                   !HET LOCATIONS TRANSFORMED
      DIMENSION RHET_T(100)                                           !HET LOCATIONS TRANSFORMED
      DIMENSION XHETP(10000000),YHETP(10000000),ZHETP(10000000)       !HETERODOMAIN LOCATIONS ON COLLOID
      DIMENSION RHETP(10000000)                                       !HETERODOMAIN LOCATIONS ON COLLOID
      DIMENSION XPRO(10000000),YPRO(10000000),ZPRO(10000000)          !PROJECTION OF HETERODOMAINS ON COLLOID
      DIMENSION RPRO(10000000)                                        !PROJECTION OF HETERODOMAINS ON COLLOID
      DIMENSION seed(8)                                               !RANDOM NUMBER PARAMETER

      INTEGER IOT
      DOUBLE PRECISION XOT,YOT,ROT,ZOT
      DOUBLE PRECISION HOT
      DOUBLE PRECISION ETIMEOT,PTIMEFOT
      DOUBLE PRECISION FCOLLOT,FVDWOT,FEDLOT
      DOUBLE PRECISION FABOT,FSTEOT,FBORNOT
      DOUBLE PRECISION UTOT,UNOT,VTOT,VNOT
      DOUBLE PRECISION FDRGTOT,FDRGNOT
      DOUBLE PRECISION FDIFXOT,FDIFYOT,FDIFZOT
      DOUBLE PRECISION FGTOT,FGNOT,FLIFTOT
      DOUBLE PRECISION ACONTOT,RZOIOT,AFRACTOT
      DOUBLE PRECISION XHET,YHET,ZHET,RHET
      DOUBLE PRECISION XHET_T,YHET_T,ZHET_T,RHET_T
      DOUBLE PRECISION XHETP,YHETP,ZHETP
      DOUBLE PRECISION RHETP
      DOUBLE PRECISION XPRO,YPRO,ZPRO,RPRO
      DOUBLE PRECISION seed
      
C     DEFINE INPUT VARIABLES (DESCRIBED IN INPUT)
      INTEGER NPART,ATTMODE,CLUSTER,VDWMODE
      DOUBLE PRECISION VSUP,RLIM,POROSITY,AG,TTIME
      DOUBLE PRECISION AP,RHOP,RHOW,VISC,ER,T
      DOUBLE PRECISION IS,ZI,ZETAPST,ZETACST
      DOUBLE PRECISION ZETAHET,RHET0,RHET1,RHET2,SCOV
      DOUBLE PRECISION ZETAHETP,RHETP0,RHETP1,SCOVP
      DOUBLE PRECISION A132,LAMBDAVDW,A11,AC1C1,A22,AC2C2,A33,T1,T2
      DOUBLE PRECISION B,ASP,ASP2
      DOUBLE PRECISION GAMMA0AB,LAMBDAAB,GAMMA0STE,LAMBDASTE
      DOUBLE PRECISION KINT,W132,BETA
      DOUBLE PRECISION DIFFSCALE,GRAVFACT
      DOUBLE PRECISION MULTB,MULTNS,MULTC,DFACTNS,DFACTC
      INTEGER NOUT,PRINTMAX,HETMODE,HETMODEP,RMODE, CBGRAV
      
C     DEFINE OTHER VARIABLES
      DOUBLE PRECISION X,Y,Z,H,R,XO,YO,ZO,RO,Xm0,Ym0,Zm0,XG,YG,ZG     !SPATIAL COORDINATES
      DOUBLE PRECISION THETA,PHI                                      !SPHERICAL COORDINATES OF COLLOID CENTER
      DOUBLE PRECISION ETX,ETY,ETZ,ENX,ENY,ENZ                        !TANGENTIAL AND NORMAL UNIT VECTORS
      DOUBLE PRECISION XINIT,YINIT,RINJ,ZINIT,RINIT,HINIT             !INITIAL COORDINATES
      DOUBLE PRECISION XINNS,YINNS,ZINNS							    !NEAR SURFACE ENTRY
      DOUBLE PRECISION FCOLL,FCOLLX,FCOLLY,FCOLLZ                     !OVERALL COLLOIDAL FORCE
      DOUBLE PRECISION FVDW,FEDL,FAB,FSTE,FBORN                       !COLLOIDAL FORCES
      DOUBLE PRECISION MP,NIO,KAPPA,ZETAC,ZETAP,ERE0                  !MASS AND EDL PARAMETERS
      DOUBLE PRECISION RZOI,RZOIBULK                                  !ZONE OF INFLUENCE
      DOUBLE PRECISION FDRGX,FDRGY,FDRGZ                              !DRAG FORCES
      DOUBLE PRECISION FDRGT,FDRGTX,FDRGTY,FDRGTZ                     !DRAG TANGENTIAL FORCES
      DOUBLE PRECISION FDRGN,FDRGNX,FDRGNY,FDRGNZ                     !DRAG NORMAL FORCES
      DOUBLE PRECISION FDIFX,FDIFY,FDIFZ                              !DIFFUSION FORCES
      DOUBLE PRECISION FDIFT,FDIFTX,FDIFTY,FDIFTZ                     !DIFFUSION TANGENTIAL FORCES
      DOUBLE PRECISION FDIFN,FDIFNX,FDIFNY,FDIFNZ                     !DIFFUSION NORMAL FORCES
      DOUBLE PRECISION FLIFT,FLIFTX,FLIFTY,FLIFTZ                     !LIFT FORCE
      DOUBLE PRECISION FG,FGN,FGNX,FGNY,FGNZ,FGT,FGTX,FGTY,FGTZ       !GRAVITY FORCE
      DOUBLE PRECISION EGX,EGY,EGZ									!GRAVITY UNIT VECTORS
	DOUBLE PRECISION FADH,FREP                                      !FORCES TO DETERMINE EQUILIBRIUM SEPARATION
      DOUBLE PRECISION dTMRT,dT,TBULK,TNEAR,TFRIC                     !TIME
      DOUBLE PRECISION TINJ,PTIMEF,ETIME                              !SIMULATION TIME
      DOUBLE PRECISION VxH1,VyH1,VzH1,VX,VY,VZ,VT,VN                  !FLUID VELOCITIES
      DOUBLE PRECISION VTX,VTY,VTZ,VNX,VNY,VNZ                        !FLUID VELOCITIES TANGENTIAL AND NORMAL
      DOUBLE PRECISION UX,UXO,UY,UYO,UZ,UZO,UT,UTO,UN,UNO,OMEGA       !COLLOID VELOCITIES
      DOUBLE PRECISION UTX,UTXO,UTY,UTYO,UTZ,UTZO                     !COLLOID TANGENTIAL VELOCITIES
      DOUBLE PRECISION UNX,UNXO,UNY,UNYO,UNZ,UNZO                     !COLLOID NORMAL VELOCITIES
      DOUBLE PRECISION PP,WW,K1,K2,K3,K4,RB                           !HAPPEL POROSITY AND FLOW FIELD PARAMETERS
      DOUBLE PRECISION VM,HBAR,M3                                     !HYDRODYNAMIC RETARDATION
      DOUBLE PRECISION A1,B1,C1,D1,E1,A2,B2,C2,D2,E2,A3,B3,C3,D3,E3   !HYDRODYNAMIC RETARDATION
      DOUBLE PRECISION A4,B4,C4,D4,E4,FUN1,FUN2,FUN3,FUN4             !HYDRODYNAMIC RETARDATION
      DOUBLE PRECISION HFRIC,FBORNFRIC,FSTEFRIC,FABFRIC               !CONTACT SEPARATION DISTANCE VARIABLES
      DOUBLE PRECISION HMIN,ASP0,NASP0                                !MINIMUM SEPARATION DISTANCE VARIABLES
      DOUBLE PRECISION ACONTMAX,ACONT,DELTAMAX,DELTA,ASTE             !DEFORMATION VARIABLES
      DOUBLE PRECISION XREF1,YREF1,ZREF1,TREF1,DREF1,DIND1,DCOEF      !SLOW MOTION IN NEAR SURFACE
      DOUBLE PRECISION XREF2,YREF2,ZREF2,TREF2,DREF2,DIND2,DIND3      !SLOW MOTION IN CONTACT
      DOUBLE PRECISION XP,YP,ZP                                       !HETERODOMAIN PARAMETERS
      DOUBLE PRECISION FEDLCST,FEDLHET                                !HETERODOMAIN EDL PARAMETERS
      DOUBLE PRECISION HSUM,HAVE                                      !AVERAGE NS SEPARATION
      DOUBLE PRECISION ENXENTER,ENYENTER,ENZENTER,RENTER,NSDIST,NSVEL !AVERAGE NS VELOCITY
      DOUBLE PRECISION NASP,NASPAB,ASPLIM,ASPABLIM,RZOIAB,RLEV        !ROUGHNESS PARAMETERS (# ASPERITIES, TORQUE LEVER ARM)
      DOUBLE PRECISION PI,G,E0,ECHG,KB,NA,H0,SIGMAC                   !CONSTANTS
      DOUBLE PRECISION ENXEP,ENYEP,ENZEP,ENXP,ENYP,ENZP               !NSVEL PROJECTION PARAMS
      DOUBLE PRECISION CHORD,NSTHETA,NSARC                            !NSVEL PARAMS
      DOUBLE PRECISION AFRACT,AFRACT_PZ,AFRACT_ZH,AFRACT_PZH,AFRACT_Z !FRACTIONAL AREAS 
      DOUBLE PRECISION AF_PZ,AF_ZH,AF_PZH,AF_Z                        !FRACTIONAL AREAS
      DOUBLE PRECISION, ALLOCATABLE :: MPRO(:,:)                      !PROJECTION MATRIX FOR HETERODOMAINS ON COLLOID
      DOUBLE PRECISION, ALLOCATABLE :: MPRO_T(:,:)                    !TRANSFORMED PROJECTION MATRIX FOR HETERODOMAINS ON COLLOID
      
      CHARACTER DUMMY*20
      CHARACTER FILESINGLE*25

      INTEGER I,J,K,L                                                 !LOOP PARAMETERS
      INTEGER PCOUNT,OUTCOUNT,OUTMAX,OUTFLAG,NPRINT                   !OUTPUT FILE PARAMETERS
      INTEGER ATTACHK,HFLAG,ARRESTFLAG,NSVISIT,FRICVISIT              !PARTICLE INDICATORS
      INTEGER IREF1,IREF2,HETTYPE,HETFLAG,NPARTLOOP,RMODE0            !MISCELLANEOUS PARAMETERS
      INTEGER nrand,RMULT                                             !RANDOM NUMBER PARAMETERS
      INTEGER NHETP,NPRO,IPRO                                         !HETERODOMAINS ON COLLOID AND PROJECTIONS PARAMETERS
      
C     MC VARIABLES DECLARATION, THESE ARE NEEDED FOR THE CLUSTER VERSION. DON'T DELETE!
      character*40 argv
      character*40 filenam
      integer ipart,ilen
      character*6 chri
      character*10 date, time, zone
      integer iarray(8)
      
C     PHYSICAL CONSTANTS
      DATA PI/3.14159265359/                                          !PIE (CHERRY,STRAWBERRY RHUBARB, ETC.)
      DATA G/9.80665/                                                 !ACCELERATION DUE TO GRAVITY (M/S^2)
      DATA E0/8.85418781762E-12/                                      !VACUUM PERMITTIVITY (C^2/N M^2)
      DATA ECHG/1.602176634E-19/                                      !ELEMENTARY CHARGE (C)
      DATA KB/1.380649E-23/                                           !BOLTZMANN CONSTANT (J/K)
      DATA NA/6.02214076E23/                                          !AVOGADRO CONSTANT (-)
      
C     HARDWIRED VALUES
      DATA H0/0.158E-9/                                               !MINIMUM SEPARATION DISTANCE (M)
      DATA SIGMAC/5.0E-10/                                            !BORN COLLISION DIAMTER (M)
      DATA OUTMAX/50000/                                              !LARGEST OUTPUT ARRAY LENGTH
      
C     READ INPUT FILE
1000  FORMAT (3/)
	OPEN (UNIT=1,FILE='INPUT.IN',STATUS='OLD')
      DO I=1,6 !SKIP 6 FIRST LINES (HEADER)
          READ (1,*)    
      END DO
      READ (1,*) NPART,ATTMODE,CLUSTER
      READ (1,1000)
      READ (1,*) VSUP,RLIM,POROSITY,AG,TTIME
      READ (1,1000)
      READ (1,*) AP,RHOP,RHOW,VISC,ER,T
      READ (1,1000)
      READ (1,*) IS,ZI,ZETAPST,ZETACST
      READ (1,1000)
      READ (1,*) ZETAHET,HETMODE,RHET0,RHET1,RHET2,SCOV
      READ (1,1000)
      READ (1,*) ZETAHETP,HETMODEP,RHETP0,RHETP1,SCOVP
      READ (1,1000)
      READ (1,*) A132,LAMBDAVDW,VDWMODE
      READ (1,1000)
      READ (1,*) A11,AC1C1,A22,AC2C2,A33
      READ (1,1000)
      READ (1,*) T1,T2
      READ (1,1000)      
      READ (1,*) GAMMA0AB,LAMBDAAB,GAMMA0STE,LAMBDASTE
      READ (1,1000)
      READ (1,*) B,RMODE,ASP,ASP2
      READ (1,1000)
      READ (1,*) KINT,W132,BETA
      READ (1,1000)
      READ (1,*) DIFFSCALE,GRAVFACT,CBGRAV
      READ (1,1000)
      READ (1,*) MULTB,MULTNS,MULTC,DFACTNS,DFACTC
      READ (1,1000)
      READ (1,*) NOUT,PRINTMAX

C     SET CENTER OF COLLECTOR
        Xm0 = 0.0
        Ym0 = 0.0
        Zm0 = 0.0
C     SET NULL HETTYPE, NONE=0, LARGE=1, MEDIUM=2, SMALL=3, LARGEANDMEDIUM=4, LARGEANDSMALL=5, MEDIUMANDSMALL=6
        HETTYPE = 0
C     SET NULL HETFLAG, 0=NOT OVER HETERODOMAIN, 1=PASSED OVER HETERODOMAIN
        HETFLAG = 0
C     CALCULATE MASS OF PARTICLE
        MP = (4.0/3.0)*(PI)*(AP**3)*RHOP 
C	  CALCULATE MOMEMTUM RELAXATION TIME 
	    dTMRT = MP/(6.0*PI*VISC*AP)
C     SET GRAVITY VECTORS
		IF (CBGRAV.EQ.1) THEN
			EGX = 0.0 
			EGY = 0.0  
			EGZ =-1.0 
		ENDIF
		IF (CBGRAV.EQ.2) THEN
			EGX =0.0 
			EGY =0.0  
			EGZ =+1.0     
		ENDIF
		IF (CBGRAV.EQ.3) THEN
			EGX =-1.0 
			EGY =0.0  
			EGZ =0.0     
		ENDIF
		IF (CBGRAV.EQ.4) THEN
			EGX =+1.0 
			EGY =0.0  
			EGZ =0.0     
		ENDIF
C
C     SET INJECTION TIME
      TINJ = TTIME/6.0
C     SET VIRTUAL MASS COEFFICIENT
	VM = (2.0/3.0)*PI*(AP**3)*RHOW
C     SET DRAG FORCE COEFFICIENT
	M3 = 6.0*PI*VISC*AP
C     FLUID SHELL RADIUS
	RB = AG/((1-POROSITY)**(1.0/3.0))
C     CALCULATE Happel sphere-in-cell model analytical streamline function parameters (from Rajagopalan & Tien, 1976)
	PP = AG/RB
	WW = 2.0-3.0*PP+3.0*PP**5.0-2.0*PP**6.0
	K1 = 1/WW
      K2 = -(3.0+2.0*PP**5.0)/WW !NEGATIVE INCLUDED HERE. MISTAKE IN RAJAGOPALAN & TIEN.
	K3 = (2.0+3.0*PP**5.0)/WW
	K4 = -PP**5.0/WW
C     CALCULATE KAPPA, NOTE: IS FOR 1:1 ELECTROLYTE ONLY
      ERE0 = ER*E0            !ABSOLUTE PERMITTIVITY
 	NIO = IS*2*NA
	KAPPA = ((ECHG**2.0)*NIO*(ZI**2.0)/(ERE0*KB*T))**0.5
C     CALCULATE RZOIBULK: RADIUS OF ZONE OF INFLUENCE WITHOUT DEFORMATION
      RZOIBULK = 2.0*((1/KAPPA)*AP)**0.5
C     CALCULATE ACONTMAX: MAXIMUM RADIUS OF CONTACT USING JKR (NEGATIVE SIGN ADDED TO MAKE CONTACT AREA POSITIVE FOR ATTRACTIVE WORK OF ADHESION, W132<0)
      IF (W132.GT.0.0) THEN
          W132 = 0.0
      ENDIF
      ACONTMAX = (-6.0*PI*W132*(AP**2.0)/KINT)**(1.0/3.0)
C     CALCULATE MAXIMUM VERTICAL DEFORMATION OF THE COLLOID
      DELTAMAX = AP - SQRT(AP**2-ACONTMAX**2)
C     CALCULATE STERIC INTERACTION RADIUS
      ASTE=(ACONTMAX**2+2*LAMBDASTE*(AP+(AP**2-ACONTMAX**2)**0.5))**0.5
C     SET A132=0 FOR LAYERED SYTEMS TO SHOW IN OUTPUT THAT A132 IS NOT USED
      IF (VDWMODE.NE.1) THEN
          A132 = 0.0
      ENDIF

C     CALCULATE HFRIC - SEPARATION AT WHICH WE CONSIDER CONTACT TO OCCUR AND ZERO SLIP. DEFORMATION STARTS TO OCCUR FOR SEPARATION DISTANCES SMALLER
C                       THAN THIS VALUE. WE DEFINE THIS DISTANCE TO BE THAT WHERE EACH OF THE CONTACT FORCES HAVE REACHED 0.01% OF THEIR VALUE AT
C                       VACUUM MINIMUM SEPARATION OF 0.158 NM
      H = H0
      ASP0 = 0.0
      NASP0 = 0.0
      RMODE0 = 0
      CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
      CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
      CALL FORCEAB (PI,AG,AP,ASP0,NASP0,RMODE0,LAMBDAAB,
     &                                GAMMA0AB,H,H0,FAB)
      FBORNFRIC = 0.0001*FBORN
      FSTEFRIC = 0.0001*FSTE
      FABFRIC = 0.0001*FAB
      DO WHILE ((FBORN.GT.FBORNFRIC).OR.(FSTE.GT.FSTEFRIC)
     &              .OR.(ABS(FAB).GT.ABS(FABFRIC)))
          H = H + 1.0E-12
          CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
          CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
          CALL FORCEAB (PI,AG,AP,ASP0,NASP0,RMODE0,LAMBDAAB,
     &                                GAMMA0AB,H,H0,FAB)
          HFRIC = H
      ENDDO

C     CALCULATE HMIN - SEPARATION DISTANCE AT WHICH WE CONSIDER MAXIMUM DEFORMATION TO BE ACHIEVED. SEPARATION DISTANCES SMALLER THAN THIS VALUE CONTINUE
C                      TO HAVE MAXIMUM DEFORMATION. WE DEFINE THIS VALUE TO BE THE LOCATION OF THE ENERGY MINIMUM (CALCULATED FOR SMOOTH SURFACES) FOR ALL
C                      ATTRACTIVE INTERACTIONS WITH BORN AS THE BACKSTOP
      H = H0
      FCOLL = 1.0
      DO WHILE (FCOLL.GT.0.0)
          HMIN = H
          H = H + 1.0E-12
          CALL FORCEVDW (A132,AG,AP,ASP0,NASP0,RMODE0,H,LAMBDAVDW,A11,
     &                        A22,A33,AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)
          CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETACST,
     &                        ZETAPST,AG,AP,ASP0,NASP0,RMODE0,H,PI,FEDL)
          CALL FORCEAB (PI,AG,AP,ASP0,NASP0,RMODE0,LAMBDAAB,
     &                                GAMMA0AB,H,H0,FAB)
          CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
          IF (FVDW.GT.0.0) THEN
              FVDW = 0.0
          ENDIF
          IF (FEDL.GT.0.0) THEN
              FEDL = 0.0
          ENDIF
          IF (FAB.GT.0.0) THEN
              FAB = 0.0
          ENDIF
          FCOLL = FVDW + FEDL + FAB + FBORN
      ENDDO

C     SET COEFFICIENTS FOR UNIVERSAL HYDRODYNAMIC FUNCTIONS -UPDATED- 2017
      A1 = 0.9267             !FROM MASLIYAH & BHATTACHARJEE 2005
      B1 = -0.3990
      C1 = 0.1487
      D1 = -0.601
      E1 = 1.202

      A2 = 0.5695             !FROM MASLIYAH & BHATTACHARJEE 2005
      B2 = 1.355
      C2 = 1.36
      D2 = 0.875
      E2 = 0.525

      A3 = 0.2803             !FIT FROM GCB 1967 (SEE SPREADSHEET)
      B3 = -0.1430
      C3 = 1.472
      D3 = -0.6772
      E3 = 2.765

      A4 = 0.2607             !FIT FROM GCB 1967 (SEE SPREADSHEET)
      B4 = -0.3015
      C4 = 0.9006
      D4 = -0.5942
      E4 = 1.292
      
C     SET NUMBER OF PARTICLES TO 1 IF IN PARALLEL VERSION
      IF (CLUSTER.EQ.1) THEN
          NPARTLOOP = 1
C         MC read number of particles and ID of particle as a program argument for the cluster version
          call getarg(1,argv)
          read(argv,*)npart
          call getarg(2,argv)
          read(argv,*)ipart
      ELSE
          NPARTLOOP = NPART
      ENDIF

      IF (CLUSTER.EQ.0) THEN
C	    **************** OPEN THREE FLUX FILES FOR SINGLE CORE VERSION *********************************
C	    OPEN HAPHETFLUXEX.OUT FOR OUTPUT
          OPEN (UNIT=21,FILE='FLUXEX.OUT',STATUS='REPLACE')

C	    OPEN HAPHETFLUXATT.OUT FOR OUTPUT
          OPEN (UNIT=22,FILE='FLUXATT.OUT',STATUS='REPLACE')

C	    OPEN HAPHETFLUXREM.OUT FOR OUTPUT
	    OPEN (UNIT=23,FILE='FLUXREM.OUT',STATUS='REPLACE')
C	    **************** END OPEN THREE FLUX FILES FOR SINGLE CORE VERSION *****************************

C         **************** WRITE FLUX HEADERS FOR SINGLE CORE VERSION ************************************
C         EXIT FLUX FILE, UNIT=21
          WRITE (21,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (21,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
          WRITE (21,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (21,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
          WRITE (21,110)
          WRITE (21,206)
          
C         ATTACHMENT FLUX FILE, UNIT=22
          WRITE (22,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (22,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
          WRITE (22,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (22,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
          WRITE (22,110)
          WRITE (22,206)
          
C         REMAINING FLUX FILE, UNIT=23
          WRITE (23,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (23,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
          WRITE (23,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (23,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
          WRITE (23,110)
          WRITE (23,206)
C         **************** END WRITE FLUX HEADERS FOR SINGLE CORE VERSION ********************************
      ENDIF

	IF (CLUSTER.EQ.1) THEN
C         **************** OPEN SIX OUTPUT FILES FOR PARALLEL VERSION ************************************
C         THESE NEED TO BE OPENED OUTSIDE THE LOOP TO AVOID MULTIPLE UNITS BEING WRITTEN TO SIMULTANEOUSLY 
C         REMOVE THE !! FROM THE LINES IN THE LINES IN THE SECTION BELOW FOR THE CLUSTER VERSION

C         OPEN HAPHETTRAJEX.OUT FOR OUTPUT
          filenam='HAPHETTRAJEX.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=11,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETTRAJATT.OUT FOR OUTPUT
          filenam='HAPHETTRAJATT.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=12,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETTRAJREM.OUT FOR OUTPUT
          filenam='HAPHETTRAJREM.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=13,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETFLUXEX.OUT FOR OUTPUT
          filenam='HAPHETFLUXEX.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=21,FILE=filenam,STATUS='REPLACE')

C         OPEN HAPHETFLUXATT.OUT FOR OUTPUT
          filenam='HAPHETFLUXATT.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=22,FILE=filenam,STATUS='REPLACE')

C	    OPEN HAPHETFLUXREM.OUT FOR OUTPUT
          filenam='HAPHETFLUXREM.'//chri(ipart)//'.OUT'
          call chrpak(filenam,40,ilen)
          OPEN (UNIT=23,FILE=filenam,STATUS='REPLACE')
C         **************** END OPEN SIX OUTPUT FILES FOR PARALLEL VERSION ********************************
      END IF

C     ******************** LOOP THROUGH PARTICLES ********************************************************
      DO J = 1,NPARTLOOP

	  IF (CLUSTER.EQ.0) THEN
          ipart = J	
C         OPEN ATTACHED PARTICLES FLUX FILE TO OBTAIN ATTAHMENT LOCATIONS TO SET INITIAL POSITION OF PARTICLES
          IF (ATTMODE.EQ.-1) THEN  
              OPEN(99,file="FLUXATT.IN",status="OLD")  
          ENDIF

C         **************** OPEN THREE TRAJECTORY FILES FOR SINGLE CORE VERSION ***************************
C         OPEN HAPHETTRAJEX.OUT FOR OUTPUT
1001      FORMAT ('HAPHETTRAJEX.',I0,'.OUT')
          WRITE(FILESINGLE,1001) J
          OPEN (UNIT=11,FILE=FILESINGLE,STATUS='REPLACE')

C         OPEN HAPHETTRAJATT.OUT FOR OUTPUT
1002      FORMAT ('HAPHETTRAJATT.',I0,'.OUT')
          WRITE(FILESINGLE,1002) J
          OPEN (UNIT=12,FILE=FILESINGLE,STATUS='REPLACE')

C         OPEN HAPHETTRAJATT.OUT FOR OUTPUT
1003      FORMAT ('HAPHETTRAJREM.',I0,'.OUT')
          WRITE(FILESINGLE,1003) J
          OPEN (UNIT=13,FILE=FILESINGLE,STATUS='REPLACE')
C         **************** END OPEN THREE TRAJECTORY FILES FOR SINGLE CORE VERSION ***********************
        ENDIF

C       ****************** WRITE TRAJECTORY HEADERS ******************************************************
C       EXIT TRAJECTORY FILE, UNIT=11
        WRITE (11,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
        WRITE (11,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
        WRITE (11,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
        WRITE (11,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
        
C       ATTACHMENT TRAJECTORY FILE, UNIT=12
        WRITE (12,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
        WRITE (12,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
        WRITE (12,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
        WRITE (12,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
        
C       REMAINING TRAJECTORY FILE, UNIT=13
        WRITE (13,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
        WRITE (13,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
        WRITE (13,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
        WRITE (13,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
C       ****************** END WRITE TRAJECTORY HEADERS **************************************************
        
        IF (CLUSTER.EQ.1) THEN
C         **************** WRITE FLUX HEADERS FOR PARALLEL VERSION ***************************************
C         EXIT FLUX FILE, UNIT=21
          WRITE (21,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (21,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
          WRITE (21,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (21,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
          WRITE (21,110)
          WRITE (21,206)
          
C         ATTACHMENT FLUX FILE, UNIT=22
          WRITE (22,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (22,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
          WRITE (22,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (22,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
          WRITE (22,110)
          WRITE (22,206)
          
C         REMAINING FLUX FILE, UNIT=23
          WRITE (23,101) NPART,VSUP,RLIM,POROSITY,AG,RB,TTIME,ATTMODE,
     &                    B,RMODE,ASP,ASP2
          WRITE (23,102) AP,IS,ZI,ZETAPST,ZETACST,RHOP,RHOW,VISC,ER,
     &                        T,DIFFSCALE,GRAVFACT,CBGRAV
          WRITE (23,103) SCOV,ZETAHET,HETMODE,RHET0,RHET1,RHET2,
     &                     SCOVP,ZETAHETP,HETMODEP,RHETP0,RHETP1,
     &                    RZOIBULK,dTMRT,MULTB,MULTNS,MULTC,VDWMODE
          WRITE (23,104) A132,LAMBDAVDW,GAMMA0AB,LAMBDAAB,GAMMA0STE,
     &                LAMBDASTE,KINT,W132,ACONTMAX,BETA,DFACTNS,DFACTC,
     &				  A11,A22,A33,AC1C1,AC2C2,T1,T2
          WRITE (23,110)
          WRITE (23,206)
C         **************** END WRITE FLUX HEADERS FOR PARALLEL VERSION ***********************************
        ENDIF

C       ****************** WRITE FORMAT FOR OUTPUT FILES *************************************************
C       COMMON HEADERS FOR BOTH FLUX AND TRAJECTORY FILES
101     FORMAT ('NPART= ',I6,2X,'VSUP(m/s)= ',E15.8,2X,
     &        'RLIM(m)= ',E15.8,2X,'POROSITY= ',E15.8,2X,
     &        'AG(m)= ',E15.8,2X,'RB(m)= ',E15.8,2X,
     &        'TTIME(s)= ',E15.8,2X,'ATTMODE= ',I2,2X,
     &        'SLIP(m)= ',E15.8,2X,'RMODE= ',I2,2X,
     &        'ASP(m)= ',E15.8,2X,'ASP2(m)= ',E15.8)
102     FORMAT ('AP(m)= ',E15.8,2X,'IS(mol/m3)= ',E15.8,2X,
     &        'ZI= ',E15.8,2X,'ZETAPST(V)= ',E15.8,2X,
     &        'ZETACST(V)= ',E15.8,2X,'RHOP(kg/m3)= ',E15.8,2X,
     &        'RHOW(kg/m3)= ',E15.8,2X,'VISC(kg/m/s)= ',E15.8,2X,
     &        'ER= ',E15.8,2X,'T(K)= ',E15.8,2X,
     &        'DIFFSCALE= ',E15.8,2X,'GRAVFACT= ',E15.8,2X,
     &        'CBGRAV= ',I2)
103     FORMAT ('SCOV= ',E15.8,2X,'ZETAHET(V)= ',E15.8,2X,
     &        'HETMODE= ',I1,2X,'RHET0(m)= ',E15.8,2X,
     &        'RHET1(m)= ',E15.8,2X,'RHET2(m)= ',E15.8,2X,
     &        'SCOVP= ',E15.8,2X,'ZETAHETP(V)= ',E15.8,2X,
     &        'HETMODEP= ',I1,2X,'RHETP0(m)= ',E15.8,2X,
     &        'RHETP1(m)= ',E15.8,2X,
     &        'RZOIBULK(m)= ',E15.8,2X,'dTMRT(s)= ',E15.8,2X,
     &        'MULTB= ',E15.8,2X,'MULTNS= ',E15.8,2X,'MULTC= ',E15.8,2X,
     &        'VDWMODE= ',I2)
104     FORMAT ('A132(J)= ',E15.8,2X,'LAMBDAVDW(m)= ',E15.8,2X,
     &        'GAMMA0AB(J/m2)= ',E15.8,2X,'LAMBDAAB(m)= ',E15.8,2X,
     &        'GAMMA0STE(J/m2)= ',E15.8,2X,'LAMBDASTE(m)= ',E15.8,2X,
     &        'KINT(N/m2)= ',E15.8,2X,'W132(J/m2)= ',E15.8,2X,
     &        'ACONTMAX(m)= ',E15.8,2X,'BETA= ',E15.8,2X,
     &      'DFACTNS= ',E15.8,2X,'DFACTC= ',E15.8,2X,'A11(J)=',E15.8,2X,
     &       'A22(J)=',E15.8,2X,'A33(J)=',E15.8,2X,'AC1C1(J)=',E15.8,2X,
     &		'AC2C2(J)=',E15.8,2X,'T1(m)=',E15.8,2X,'T2(m)=',E15.8) 
	 	 

C       DEFINE ATTACHK VALUES FOR FLUX FILES
110     FORMAT ('ATTACHK1=EXIT,'
     &          'ATTACHK2=ATTACHED-BY-PERFECT-SINK-OR-TORQUE,'
     &          'ATTACHK3=REMAINING-UNRESOLVED-WHEN-SIMULATION-ENDS,'
     &          'ATTACHK4=TORQUE-WITH-SLOW-MOTION,'
     &          'ATTACHK5=IN-NEAR-SURFACE-WITH-SLOW-MOTION,'
     &          'ATTACHK6=CRASHED')

C       DECLARE ATTACHK VALUE FOR EACH PARTICLE TRAJECTORY FILE
105     FORMAT ('ATTACHK= ',I5)
      
C       LABEL AND WRITE VARIABLES FOR TRAJECTORY FILES
106     FORMAT ('I',19X,'X',19X,'Y',19X,'Z',19X,'R',19X,'H',19X,
     &        'ETIME',15X,'PTIMEF',14X,'FCOLL',15X,'FVDW',16X,
     &        'FEDL',16X,'FAB',17X,'FSTE',16X,'FBORN',15X,'UT',18X,
     &        'UN',18X,'VT',18X,'VN',18X,'FDRGT',15X,'FDRGN',15X,
     &        'FDIFX',15X,'FDIFY',15X,'FDIFZ',15X,'FGT',17X,'FGN',17X,
     &        'FLIFT',15X,'ACONT',15X,'RZOI',16X,'AFRACT')
107     FORMAT (I15.15,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8)
      
C       LABEL AND WRITE VARIABLES FOR FLUX FILES
206     FORMAT ('PARTICLE',3X,'ATTACHK',1X,'XINIT(m)',12X,
     &        'YINIT(m)',12X,'RINJ(m)',13X,'ZINIT(m)',12X,
     &        'RINIT(m)',12X,'HINIT(m)',12X,'XOUT(m)',13X,'YOUT(m)',13X,
     &        'ZOUT(m)',13X,'ROUT(m)',13X,'HOUT(m)',13X,'ETIME(s)',12X,
     &        'PTIMEIN(s)',10X,'PTIMEOUT(s)',9X,'TBULK(s)',12x,
     &        'TNEAR(s)',12x,'TFRIC(s)',12x,'NSVISIT',13X,
     &        'FRICVISIT',11X,'ACONT(m)',12x,'RZOI(m)',13X,'AFRACT',14X,
     &        'HETTYPE',1X,'HETFLAG',1X,'NSVEL(m/s)',10X,'HAVE(m)',
     &        1X,'XINNS(m)',12X,'YINNS(m)',12X,'ZINNS(m)')
207     FORMAT (I6.6,5X,I1,7X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,I15,5X,
     &          I15,5X,E15.8,5X,E15.8,5X,E15.8,5X,
     &          I1,7X,I1,7X,E15.8,5X,E15.8,5X,
     &          E15.8,5X,E15.8,5X,E15.8)
C       ****************** END WRITE FORMAT FOR OUTPUT FILES *********************************************

C       INITIALIZE RANDOM NUMBER GENERATOR SEED
        RMULT = 7654321
        CALL init_random_seed()
C       
C       INITIALIZE NEAR SURFACE ENTRY COORDINATES
        XINNS = 0
        YINNS = 0
        ZINNS = 0
  
C       SET INITIAL LOCATION AND PARAMETERS DEPENDENT ON MODE OF PERFECT-SINK/TORQUE OR PERTURBATION
        IF (ATTMODE.EQ.-1) THEN !PERTURBATION
C           SET INITIAL PARTICLE TIME TO BE 0
            PTIMEF = 0
C           COLLOID STARTS IN CONTACT
            dT = MULTC*dTMRT
            HFLAG = 3
C           FIND ATTACHED PARTICLE POSITION IN FLUX FILE , THIS STRUCTURE WORKS FOR BOTH CLUSTER AND SINGLE CORE VERSION (J = ipart set above)
            DO I=1,6 !SKIP HEADER
              READ (99,*)DUMMY
            ENDDO
            DO I=1,J
              IF (I.EQ.J) THEN
                READ(99,*) DUMMY,DUMMY,DUMMY,DUMMY,RINJ,DUMMY,DUMMY,
     &                    DUMMY,XINIT,YINIT,ZINIT,RINIT,HINIT,DUMMY,
     &                    DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,
     &                    ACONT,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY
                X = XINIT
                Y = YINIT
                Z = ZINIT
                R = RINIT
                H = HINIT
              ELSE
                !SKIP PREVIOUS PARTICLES
                READ (99,*) DUMMY
              ENDIF  
            END DO
C           CALCULATE FLUID VELOCITY COMPONENTS AND SET COLLOID NORMAL VELOCITY
            CALL HAPPELFF (X,Y,Z,AG,B,K1,K2,K3,K4,VxH1,VyH1,VzH1)
            VX = VxH1*VSUP
            VY = VyH1*VSUP
            VZ = VzH1*VSUP
            UZ = 0.0
        ELSE !PERFECT SINK OR CONTACT MODE          
C           SET INITIAL PARTICLE TIME (EVENLY DISTRIBUTED THROUGH TIME FOR FLUX) SET MAXIMUM INJECTION TIME 1/6 OF TOTAL SIMULATION TIME
            PTIMEF = (ipart-1)*TINJ/NPART
C           COLLOID STARTS IN BULK
            dT = MULTB*dTMRT
            HFLAG = 1
            ACONT = 0.0
C           INITIALIZE LOCATION OF PARTICLES
            CALL INITIAL (RLIM,AG,AP,ASP,RMODE,RB,XINIT,YINIT,RINJ,
     &                        ZINIT,RINIT,HINIT)
            X = XINIT
            Y = YINIT
            Z = ZINIT
            R = RINIT
            H = HINIT
C           SET FLUID VELOCITY COMPONENTS AND COLLOID NORMAL VELOCITY
            VX = 0.0
            VY = 0.0
            VZ = -VSUP
            UZ = VZ
        ENDIF !(ATTMODE.EQ.-1)

C       CALCULATE UNIT VECTORS
        ENX = (X-Xm0)/R
        ENY = (Y-Ym0)/R
        ENZ = (Z-Zm0)/R
        
C       INITIALIZE VELOCITIES
        UX = 0.0
        UY = 0.0
        UN = UX*ENX+UY*ENY+UZ*ENZ
        UNX = UN*ENX
        UNY = UN*ENY
        UNZ = UN*ENZ
        UTX = UX-UNX
        UTY = UY-UNY
        UTZ = UZ-UNZ
        UT = (UTX**2+UTY**2+UTZ**2)**(0.5)
        
C       FIT OMEGA*AP/UT AS FUNCTION OF H/AP USING GCB 1967b TABLES 2&3
        OMEGA = UT/AP*(0.5518+117.4*(H/AP))/
     &                (1+232.1*(H/AP)+237.7*(H/AP)**2.0)
        
        VN = VX*ENX+VY*ENY+VZ*ENZ
        VNX = VN*ENX
        VNY = VN*ENY
        VNZ = VN*ENZ
        VTX = VX-VNX
        VTY = VY-VNY
        VTZ = VZ-VNZ
        VT = (VTX*VTX+VTY*VTY+VTZ*VTZ)**0.5
        
C       CALCULATE RZOI AND RZOIAB
        RZOI = (ACONT**2+2/KAPPA*(AP+(AP**2-ACONT**2)**0.5))**0.5
        RZOIAB = (ACONT**2+2*LAMBDAAB*(AP+(AP**2-ACONT**2)**0.5))**0.5
C       CALCULATE THE NUMBER OF ASPERITIES WITHIN EACH ZOI
        NASP = 0.0
        NASPAB = 0.0
        ASPLIM = 0.5*(PI**0.5)*RZOI
        ASPLIMAB = 0.5*(PI**0.5)*RZOIAB
        IF (RMODE.GT.0) THEN
            IF (ASP.GT.ASPLIM) THEN
                NASP = 1.0
            ELSE
                NASP = (RZOI**2/ASP**2)*(PI/4)
            ENDIF
            IF (ASP.GT.ASPLIMAB) THEN    
                NASPAB = 1.0
            ELSE
                NASPAB = (RZOIAB**2/ASP**2)*(PI/4)
            END IF
        END IF
C       CALCULATE FORCES FOR INITIAL POSITION FOR FIRST TRAJECTORY POINT
        CALL FORCEVDW (A132,AG,AP,ASP,NASP,RMODE,H,LAMBDAVDW,A11,
     &                    A22,A33,AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)
 
C       FAVORABLE CONDITIONS IF BULK ZETAC AND ZETAP ARE OPPOSITE IN SIGN, THEN SET SCOV = 0.0 AND SCOVP = 0.0
        IF (((ZETACST.GE.0.0).AND.(ZETAPST.LE.0.0)).OR.
     &      ((ZETACST.LE.0.0).AND.(ZETAPST.GE.0.0))) THEN
            SCOV = 0.0
            SCOVP = 0.0
        END IF
C       UNDER UNFAVORABLE CONDITIONS HETERODOMIANS WILL BE SIMULATED IN EITHER COLLECTOR (HETC), OR COLLOID (HETP), OR BOTH
C       TO CALCULATE HETC AND HETP FRACTIONAL AREAS WITHIN ZOI, HETERODOMAINS WILL BE PROJECTED ONTO THE FRAME OF REFERENCE
C       WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER
        IF ((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)) THEN
C         CALCULATE PROJECTION OF COLLOID CENTER ON HAPPEL SPHERE
          XG = Xm0+ENX*AG
          YG = Ym0+ENY*AG
          ZG = Zm0+ENZ*AG
          AFRACT = 0.0
C         CALCULATE COLLOID RADIAL POSITION - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
          RO = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0)+(Z-Zm0)*(Z-Zm0))**0.5
C         CALCULATE COLLOID THETA ANGLE - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
          THETA = DACOS((Z-Zm0)/RO)
C         CALCULATE PROJECTION OF COLLOID POSITION ON XY PLANE
          ROXY = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0))**0.5
C         CALCULATE COLLOID PHI ANGLE - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
          IF (ROXY.EQ.0.0) THEN
              PHI = 0.0
          ELSE
              IF ((Y-Ym0).GE.0.0) THEN
                  PHI = DACOS((X-Xm0)/ROXY)
              ELSE
                  PHI = 2.0*PI-DACOS((X-Xm0)/ROXY)
              ENDIF
          END IF
C         HETEROGENEITY ON COLLOID (HETP) SUBROUTINE TO DETERMINE HETERODOMAIN PROJECTIONS
C         HETP PROJECTIONS WILL BE GENERATED ASSUMING THAT THE COLLOID CENTER COINCIDES WITH THE HAPPEL SPHERE CENTER
C         THEN HETP PROJECTIONS WILL BE TRANSLATED AND ROTATED TO THE FRAME OF REFERENCE
C         WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER  
          CALL HETTRACKP(Xm0,Ym0,Zm0,H,RZOIBULK,AP,HETMODEP,SCOVP,
     &                   RHETP0,RHETP1,NHETP,XHETP,YHETP,ZHETP,RHETP,
     &                   NPRO,XPRO,YPRO,ZPRO,RPRO)
C         PROJECTION MATRIX OF HETERODOMAINS ON COLLOID ONTO HAPPEL SPHERE
          IF (NPRO.EQ.0) THEN
              NPRO = 1
              ALLOCATE(MPRO(NPRO,4))
              MPRO = 0.0
              ALLOCATE(MPRO_T(NPRO,3))
              MPRO_T = 0.0
          ELSE
              ALLOCATE(MPRO(NPRO,4))
              CALL PROJECTION_MATRIX(NPRO,XPRO,YPRO,ZPRO,RPRO,MPRO)
              ALLOCATE(MPRO_T(NPRO,3))
              CALL MPRO_TRANSFORMATION(X,Y,Z,XG,YG,ZG,THETA,
     &                                 PHI,NPRO,MPRO,MPRO_T)
          END IF  
        END IF
C       CALCULATE HETERODOMAINS INFLUENCE 
        IF (((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(HFLAG.GT.1)) THEN
C         HETEROGENEITY ON COLLECTOR (HETC) SUBROUTINE TO DETERMINE CLOSEST HETERODOMAIN TO COLLOID
C         HETC WILL BE TRANSLATED TO THE FRAME OF REFERENCE WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER            
          IF (SCOV.GT.0.0) THEN
              CALL HETTRACK(X,Y,Z,Xm0,Ym0,Zm0,AG,RZOI,HETMODE,SCOV,
     &                      RHET0,RHET1,RHET2,XHET,YHET,ZHET,RHET)
              CALL HETC_TRANSFORMATION(XG,YG,ZG,XHET,YHET,ZHET,RHET,
     &                                 HETMODE,THETA,PHI,XHET_T,
     &                                 YHET_T,ZHET_T,RHET_T)
          ELSE
              XHET_T = 0.0
              YHET_T = 0.0
              ZHET_T = 0.0
              RHET_T = 0.0
          ENDIF
C         INITIALIZE FRACTIONAL AREAS
          AFRACT = 0.0       !TOTAL ATTRACTIVE FRACTIONAL AREA
          AFRACT_PZ = 0.0    !PRO-ZOI FRACTIONAL AREA
          AFRACT_ZH = 0.0    !ZOI-HET FRACTIONAL AREA
          AFRACT_PZH = 0.0   !PRO-ZOI-HET FRACTIONAL AREA
          AFRACT_Z = 0.0     !ZOI FRACTIONAL AREA NON-OVERLAPPED
C         CALCULATE OVERLAPING AREA OF HETERODOMAINS AND ZOI
C         GIVEN THAT THE PROJECTION OF COLLOID CENTER CORRESPONDS TO THE ORIGIN OF THE FRAME OF REFERENCE WITH X-Y PLANE 
C         MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER, VARIABLES
C         EQUAL TO 0.0 MUST BE PASSED TO THE FIRST TWO POSITIONS OF SUBROUTINE FRACTIONAL_AREA              
          CALL FRACTIONAL_AREA(Xm0,Ym0,RZOIBULK,Xm0,Ym0,Zm0,NPRO,MPRO_T,
     &                         AF_PZ,AF_ZH,AF_PZH,AF_Z)
          AFRACT = AF_PZ
          AFRACT_PZ = AF_PZ
          DO K=1,HETMODE
              CALL FRACTIONAL_AREA(Xm0,Ym0,RZOIBULK,XHET_T(K),YHET_T(K),
     &                             RHET_T(K),NPRO,MPRO_T,AF_PZ,AF_ZH,
     &                             AF_PZH,AF_Z)
              AFRACT = AFRACT + AF_ZH               !TOTAL ATTRACTIVE FRACTIONAL AREA
              IF (AF_ZH.GT.0.0) THEN
                  AFRACT = AFRACT - AF_PZH          !TOTAL ATTRACTIVE FRACTIONAL AREA
                  AFRACT_PZ = AFRACT_PZ - AF_PZH    !PRO-ZOI FRACTIONAL AREA
              ENDIF
              AFRACT_ZH = AFRACT_ZH + AF_ZH         !ZOI-HET FRACTIONAL AREA
              AFRACT_PZH = AFRACT_PZH + AF_PZH      !PRO-ZOI-HET FRACTIONAL AREA
              AFRACT_Z = 1 - AFRACT_PZ - AFRACT_ZH - AFRACT_PZH !ZOI FRACTIONAL AREA NON-OVERLAPPED    
          END DO
          !DEALLOCATE(M_PRO)
          IF (AFRACT.GT.0.0) THEN
              !CALCULATE PRO-ZOI ATTRACTIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETACST
              ZETAP = ZETAHETP
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                       AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_PZ = FEDL
              !CALCULATE ZOI-HET ATTRACTIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETAHET
              ZETAP = ZETAPST
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                      AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_ZH = FEDL
              !CALCULATE PRO-ZOI-HET REPULSIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETAHET
              ZETAP = ZETAHETP
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                       AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_PZH = FEDL
              !CALCULATE ZOI REPULSIVE CONTRIBUTION TO EDL FORCE
              ZETAC = ZETACST
              ZETAP = ZETAPST
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                       AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
              FEDL_Z = FEDL
              !CALCULATE NET EDL FORCE
              FEDL = AFRACT_PZ*FEDL_PZ + AFRACT_ZH*FEDL_ZH + 
     &               AFRACT_PZH*FEDL_PZH + AFRACT_Z*FEDL_Z
          ELSE !(AFRACT.GT.0.0)
              ZETAC = ZETACST
              ZETAP = ZETAPST
              CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                       AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
          ENDIF !(AFRACT.GT.0.0)
        ELSE !(((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(HFLAG.GT.1))
          AFRACT = -1.0
          ZETAC = ZETACST
          ZETAP = ZETAPST
          CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                   AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
        END IF !(((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(HFLAG.GT.1))
        
        CALL FORCEAB (PI,AG,AP,ASP,NASPAB,RMODE,LAMBDAAB,
     &                                GAMMA0AB,H,H0,FAB)
        CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
        CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
        FCOLL = FVDW + FEDL + FAB + FBORN + FSTE
        FDIFX = 0.0
        FDIFY = 0.0
        FDIFZ = 0.0
C
        CALL GRAVITY(GRAVFACT,AP,G,RHOP,RHOW,PI,FG)
C		
C       !calculate gravity for initial step
C       !gravity direction EGX EGY EGZ is set at the beginning of this code
C       !depending on GUI input (cbMZ cbPZ cbMX cbPX)
C       !the function below projects cartesian gravity toward normal and
C       !tangential axes. 
C		!+Normal points away from the collector surface,
C       !-Normal points towards collector surface
C       !+tangential is aligned with tangential velocity from Happel flow field
C       !-tangential is opposed to tangential velocity from Happel flow field 
		CALL GRAVVECT (FG,EGX,EGY,EGZ,ENX,ENY,ENZ,ETX,ETY,ETZ,
     &					FGN,FGT,FGNX,FGNY,FGNZ,FGTX,FGTY,FGTZ)				
C		
        CALL FORCELIFT (RHOW,R,AP,AG,VT,UT,OMEGA,FLIFT)
        HBAR = (H+B)/AP !REDUCED RETARDATION DUE TO ROUGHNESS
        FUN2=1.0+B2*EXP(-C2*HBAR)+D2*EXP(-E2*HBAR**A2)
        FUN3=1.0+B3*EXP(-C3*HBAR)+D3*EXP(-E3*HBAR**A3)
        FUN4=1.0+B4*EXP(-C4*HBAR)+D4*EXP(-E4*HBAR**A4)
        CALL FORCEDRAG (FUN2,FUN3,FUN4,M3,VN,VT,FDRGT,FDRGN)

C       RESTART TRANSLATION AND OUTPUT COUNTERS
        I = 0
        PCOUNT = 1
        OUTCOUNT = 1
        OUTFLAG = 1
        ATTACHK = 0 !INITIALIZE ATTACHK FLAG
        ARRESTFLAG = 0 !USED TO ALLOW COLLOID REACH EQUILIBRIUM SEPARATION DISTANCE
C       RESET STAGNANT PARTICLE INDICATOR
        IREF1 = 0
        IREF2 = 0
C       RESET CUMULATIVE BULK,NEAR-SURFACE, AND FRICTION TIMES
        TBULK = 0.0
        TNEAR = 0.0
        TFRIC = 0.0
        ETIME = 0.0
C       RESET NEAR-SURFACE AND FRICTION VISIT COUNTERS
        NSVISIT = 0
        FRICVISIT = 0
C       RESET AVERAGE SEPARATION DISTANCE AND NEAR-SURFACE VELOCITY PARAMETERS
        L = 0
        HSUM = 0
        HAVE = 0.0
        NSDIST = 0.0
        NSVEL = 0.0
C       EMPTY PROJECTION MATRIX
        IF ((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)) THEN
          DEALLOCATE(MPRO)
          DEALLOCATE(MPRO_T)
        ENDIF
C       ****************** TRANSLATION LOOP **************************************************************
        DO WHILE (ATTACHK.EQ.0)
C         OUTPUT TO ARRAY   
          IF ((PCOUNT.EQ.NOUT).OR.(I.EQ.0)) THEN
              PCOUNT = 0
              IOT(OUTCOUNT) = I
              XOT(OUTCOUNT) = X
              YOT(OUTCOUNT) = Y
              ZOT(OUTCOUNT) = Z
              ROT(OUTCOUNT) = R
              HOT(OUTCOUNT) = H
              ETIMEOT(OUTCOUNT) = ETIME
              PTIMEFOT(OUTCOUNT) = PTIMEF
              FCOLLOT(OUTCOUNT) = FCOLL
              FVDWOT(OUTCOUNT) = FVDW
              FEDLOT(OUTCOUNT) = FEDL
              FABOT(OUTCOUNT) = FAB
              FSTEOT(OUTCOUNT) = FSTE
              FBORNOT(OUTCOUNT) = FBORN
              UTOT(OUTCOUNT) = UT
              UNOT(OUTCOUNT) = UN
              VTOT(OUTCOUNT) = VT
              VNOT(OUTCOUNT) = VN
              FDRGTOT(OUTCOUNT) = FDRGT
              FDRGNOT(OUTCOUNT) = FDRGN
              FDIFXOT(OUTCOUNT) = FDIFX
              FDIFYOT(OUTCOUNT) = FDIFY
              FDIFZOT(OUTCOUNT) = FDIFZ
              FGTOT(OUTCOUNT) = FGT
              FGNOT(OUTCOUNT) = FGN
              FLIFTOT(OUTCOUNT) = FLIFT
              ACONTOT(OUTCOUNT) = ACONT
              RZOIOT(OUTCOUNT) = RZOI
              AFRACTOT(OUTCOUNT) = AFRACT
              OUTCOUNT = OUTCOUNT + 1
C             RESET OUTPUT COUNTER TO KEEP STORING NEW VALUE IN THE BEGINNING OF THE ARRAY
C             FLAG THIS EVENT TO OUTPUT ARRAY PROPERLY WHEN TRAJECTORY IS RESOLVED
              IF (OUTCOUNT.GT.OUTMAX) THEN
                  OUTFLAG = OUTFLAG + 1
C                 IF ARRAY REWRITE OCCURS OUTMAX TIMES, THEN OVERWRITE SECOND 
C                 TO LAST POSITION TO HOLD SPACE FOR FINAL RESOLVED POSITION
                  IF (OUTFLAG.EQ.OUTMAX) THEN
                      OUTFLAG = OUTFLAG - 1
                  END IF
                  OUTCOUNT = OUTFLAG
              END IF   
              IF (CLUSTER.EQ.0) THEN
                  PRINT 6001, J,I,R,Z,H,AFRACT
 6001             FORMAT ('J= ',I6,1X,'I= ',I15,1X,'R= ',E12.5,1X,
     &            'Z= ',E15.8,1X,'H= ',E12.5,1X,'AFRACT= ',E12.5)
              ENDIF
          END IF
          I = I + 1 !COUNT THE NUMBER OF TRANSLATIONS
          PCOUNT = PCOUNT + 1 !COUNT THE NUMBER OF TRANSLATIONS TO OUT
          PTIMEF = PTIMEF + dT !ADD TIME STEP TO TOAL TIME
C         CALCULATE ELAPSED TIME
          ETIME = PTIMEF-PTIMEFOT(1)
C         RECORD PREVIOUS VALUES
          XO = X
          YO = Y
          ZO = Z
C         TRANSLATE PARTICLE
          X = XO + UX*dT
          Y = YO + UY*dT
          Z = ZO + UZ*dT 
C         CALCULATE RADIAL DISTANCE
          R = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0)+
     &         (Z-Zm0)*(Z-Zm0))**0.5
C         CALCULATE VERTICAL DEFORMATION AS FUNCTION OF R
C         EQUATION OF LINE CONNECTING POINTS DELTA=0,Z=AP+HFRIC AND DELTA=DELTAMAX,Z=AP-DELTAMAX+HMIN (ADJUST TO INCLUDE ASPERITIES)
          IF (RMODE.EQ.0) THEN !SMOOTH-SMOOTH INTERACTION
              DELTA = DELTAMAX*(R-AG-AP-HFRIC)/(HMIN-HFRIC-DELTAMAX)
          ELSE IF ((RMODE.EQ.1).OR.(RMODE.EQ.2)) THEN !SMOOTH-ROUGH INTERACTION
              DELTA = DELTAMAX*(R-AG-AP-HFRIC-ASP)/(HMIN-HFRIC-DELTAMAX)
          ELSE IF (RMODE.EQ.3) THEN !ROUGH-ROUGH INTERACTION
              DELTA = DELTAMAX*(R-AG-AP-HFRIC-0.5*(2*ASP+3**0.5*ASP))/
     &                            (HMIN-HFRIC-DELTAMAX)
          END IF
          IF (DELTA.GT.DELTAMAX) THEN
              DELTA = DELTAMAX
          ENDIF
          IF (DELTA.LT.0.0) THEN
              DELTA = 0.0
          ENDIF
C         CALCULATE CONTACT AREA
          ACONT = BETA*SQRT(2.0*AP*DELTA-DELTA**2.0)
          RZOI = (ACONT**2+2/KAPPA*(AP+(AP**2-ACONT**2)**0.5))**0.5
          RZOIAB = (ACONT**2+2*LAMBDAAB*(AP+(AP**2-ACONT**2)**0.5))**0.5
          ASPLIM = 0.5*(PI**0.5)*RZOI
          ASPLIMAB = 0.5*(PI**0.5)*RZOIAB
          IF (RMODE.GT.0) THEN
              IF (ASP.GT.ASPLIM) THEN
                  NASP = 1.0
              ELSE
                  NASP = (RZOI**2/ASP**2)*(PI/4)
              ENDIF
              IF (ASP.GT.ASPLIMAB) THEN    
                  NASPAB = 1.0
              ELSE
                  NASPAB = (RZOIAB**2/ASP**2)*(PI/4)
              END IF
          END IF
          IF (RMODE.EQ.0) THEN !SMOOTH-SMOOTH INTERACTION
              H = R - AG - AP + DELTA
          ELSE IF ((RMODE.EQ.1).OR.(RMODE.EQ.2)) THEN !SMOOTH-ROUGH INTERACTION
              H = R - AG - AP + DELTA - ASP
          ELSE IF (RMODE.EQ.3) THEN !ROUGH-ROUGH INTERACTION
              H = R - AG - AP + DELTA - 0.5*(2*ASP+3**0.5*ASP) !THIRD TERM IS AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH SURFACES FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
          END IF

C         DETERMINE UNIT VECTORS
          ENX = (X-Xm0)/R
          ENY = (Y-Ym0)/R
          ENZ = (Z-Zm0)/R

!         INCREMENT BULK OR NEAR SURFACE TRAJECTORY TIME, TRACK PARTICLE TO STUCK INDICATOR IF IN NEAR SURFACE DOMAIN
          IF (H.GT.2.0E-7) THEN
              IF (HFLAG.EQ.2) THEN !Increment time in domain from which particle came
                  TNEAR = TNEAR + dT
                  dT = MULTB*dTMRT !change dT after accumulating timestep from near surface
                  HFLAG = 1 !flag particle in bulk
                  HFLAG = 1 !flag particle in bulk
                  IF(IREF1.GT.200) THEN !CALCULATE NSVEL FOR SIGNIFICANT RESIDENCE
                  ! CALCULATE ENTRY AND EXIT PROJECTION ON GRAIN
      				ENXEP = Xm0+ENXENTER*AG
	    			ENYEP = Ym0+ENYENTER*AG
		    		ENZEP = Zm0+ENZENTER*AG
			    	ENXP = Xm0+ENX*AG
				    ENYP = Ym0+ENY*AG
				    ENZP = Zm0+ENZ*AG
                      !DETERMINE CHORD TRAVELED IN NEAR SURFACE VISIT
                      CHORD = ((ENXEP-ENXP)**2.0 
     &                    +(ENYEP-ENYP)**2.0+(ENZEP-ENZP)**2.0)**0.5
				    !DETERMINE ANGLE (THETA) BETWEEN PROJECTED ENTRY AND EXIT (RADIANS)
				    != 2arcsin(c/2AG) where c is the chord and AG is the grain radius
				    !our chord is already normalized to AG so remove AG in above formula
				    !https://en.wikipedia.org/wiki/Circular_segment
				    NSTHETA =  2.0*(DASIN(CHORD/(2.0*AG))) ! ANGLE IN RADIANS
				    NSARC = AG*NSTHETA
				    !ACCUMULATE DISTANCE TRAVELED IN NEAR SURFACE VISIT
				    NSDIST = NSDIST+NSARC
                      !CALCULATE AVERAGE NEAR SURFACE VELOCITY
                      NSVEL = NSDIST/TNEAR
                  ENDIF
                  IREF1 = 0 !reset IREF1 if particle leaves near surface
              ELSE IF (HFLAG.EQ.1) THEN
                  TBULK = TBULK+dT
                  L = L+1
C                 CALCULATE AVERAGE COMBINED BULK + NEAR-SURFACE SEPARATION DISTANCE
				  HSUM = H + HSUM
                  HAVE = HSUM/L
              END IF
          ELSE IF ((H.LE.2.0E-7).AND.(H.GT.HFRIC)) THEN !H IS IN NEAR SURFACE
              IF (HFLAG.EQ.1) THEN !particle is coming from bulk
                  TBULK = TBULK + dT
                  dT = MULTNS*dTMRT !change dT after accumulating timestep from bulk
                  HFLAG = 2 !flag particle in near surface
                  NSVISIT = NSVISIT + 1 !COUNT NUMBER OF VISITS TO NEAR SURFACE FROM BULK
                  !SET NORMAL UNIT VECTOR FOR ENTRANCE TO NEAR SURFACE FOR CALCULATING AVERAGE VELOCITY
                  ENXENTER = ENX
                  ENYENTER = ENY
                  ENZENTER = ENZ
                  RENTER = R
				  XINNS = X
				  YINNS = Y 
				  ZINNS = Z 
              ELSE IF (HFLAG.EQ.3) THEN !particle is coming from friction
                  TFRIC = TFRIC + dT
                  dT = MULTNS*dTMRT !change dT after accumulating timestep from friction
                  HFLAG = 2 !flag particle in near surface
                  IREF2 = 0 !reset friction IREF
                  !SET NORMAL UNIT VECTOR FOR ENTRANCE TO NEAR SURFACE FOR CALCULATING AVERAGE VELOCITY
                  ENXENTER = ENX
                  ENYENTER = ENY
                  ENZENTER = ENZ
                  RENTER = R
              ELSE IF (HFLAG.EQ.2) THEN !particle is coming from near surface
                  TNEAR = TNEAR + dT !NEAR SURFACE RESIDENCE TIME
C                 NUMBER OF CONSECUTIVE TIME STEPS IN NEAR SURFACE
                  L = L+1
C                 CALCULATE AVERAGE COMBINED BULK + NEAR-SURFACE SEPARATION DISTANCE
                  HSUM = H + HSUM
                  HAVE = HSUM/L
!                 COMMENTED OUT TO REMOVE INSTANTANEOUS NSVEL
!                  !CALCULATE AVERAGE NEAR SURFACE VELOCITY
!                  !NOTE: BULK TANGENTIAL VELOCITY IS NOT INCLUDED EVEN IF COLLOID CROSSES NEAR-SURFACE BOUNDARY MULTIPLE TIMES
!                  NSVEL = (NSDIST+0.5*(RENTER+R)*
!     &                        2*DASIN(0.5*((ENXENTER-ENX)**2.0
!     &                        +(ENYENTER-ENY)**2.0
!     &                        +(ENZENTER-ENZ)**2.0)**0.5))/TNEAR
              END IF
                
              IF (IREF1.EQ.0) THEN !IDENTIFY REFERENCE POINT AND TIME
                  XREF1 = X 
                  YREF1 = Y
                  ZREF1 = Z
                  TREF1 = 0.0
                  IREF1 = 1
              ELSE
                  IREF1 = IREF1 + 1
                  TREF1 = TREF1 + dT
                  IF (IREF1.GT.1000) THEN
                      DREF1 = ((X-XREF1)*(X-XREF1)+(Y-YREF1)*
     &                    (Y-YREF1)+(Z-ZREF1)*(Z-ZREF1))**0.5   !COMPARE REFERENCE DISTANCE TO DIFFUSION ONLY DISPLACEMENT
                      IF (VN.GT.VT) THEN
                          DCOEF = FUN1
                      ELSE
                          DCOEF = FUN4
                      ENDIF
                      DIND3 = (6.0*DCOEF*KB*T*TREF1/M3)**0.5
                      DIND1 = DFACTNS*(6.0*DCOEF*KB*T*TREF1/M3)**0.5 !SCALE DISPLACEMENT TO DIFFUSION (WITHOUT DIFFSCALE)
                      IF (((DREF1.LT.DIND1).AND.(H.GT.5*HFRIC))
     &                    .OR.(ABS(Z+R).LE.AP/2)) THEN !TAG AS REMAIN IF AT REAR FLOW STAG ZONE
                          ATTACHK = 5 !RETENTION WITHOUT CONTACT IN NEAR SURFACE
                      ELSE
                          IREF1 = 0
                      ENDIF
                  ENDIF !If IREF.GT.1000
              ENDIF !IF IREF1.EQ.0
                
          ELSE IF ((H.LE.2.0E-7).AND.(H.LE.HFRIC)) THEN !particle is in friction
              IF (HFLAG.EQ.2) THEN
                  TNEAR = TNEAR + dT
                  dT = MULTC*dTMRT !change dT after accumulating timestep from near surface
                  HFLAG = 3 !flag particle in friction
				  IF (IREF1.GT.200) THEN
!	          		CALCULATE ENTRY AND EXIT PROJECTION ON GRAIN
					ENXEP = Xm0+ENXENTER*AG
					ENYEP = Ym0+ENYENTER*AG
					ENZEP = Zm0+ENZENTER*AG
					ENXP = Xm0+ENX*AG
					ENYP = Ym0+ENY*AG
					ENZP = Zm0+ENZ*AG
					!DETERMINE CHORD TRAVELED IN NEAR SURFACE VISIT
					CHORD = ((ENXEP-ENXP)**2.0 
     &                    +(ENYEP-ENYP)**2.0+(ENZEP-ENZP)**2.0)**0.5
					!DETERMINE ANGLE (THETA) BETWEEN PROJECTED ENTRY AND EXIT (RADIANS)
					!= 2arcsin(c/2AG) where c is the chord and AG is the grain radius
					!our chord is already normalized to AG so remove AG in above formula
					!https://en.wikipedia.org/wiki/Circular_segment
					NSTHETA =  2.0*(DASIN(CHORD/(2.0*AG))) ! ANGLE IN RADIANS
					NSARC = AG*NSTHETA
					!ACCUMULATE DISTANCE TRAVELED IN NEAR SURFACE VISIT
					NSDIST = NSDIST+NSARC
					!CALCULATE AVERAGE NEAR SURFACE VELOCITY
					NSVEL = NSDIST/TNEAR
				  ENDIF
				  FRICVISIT = FRICVISIT + 1 !count number of visits to friction
              ELSE IF (HFLAG.EQ.3) THEN
                  TFRIC = TFRIC + dT !friction residence time
              END IF
              IF (H.LT.H0) THEN
                  ATTACHK = 6 !Flag if particle runs into surface
              END IF
              IF (ATTMODE.EQ.0) THEN !attachment by perfect sink
                  ATTACHK = 2
              ELSE !TORQUE BALANCE MODE FOR ATTACHMENT AND DETACHMENT
                  IF ((UT.EQ.0.0).AND.(ARRESTFLAG.EQ.1)) THEN !UR=0.0 AND COLLOID HAS REACHED EQUILIBRIUM SEPARATION (FADH~FREP)
                      ATTACHK = 2 !PARTICLE ARRESTS
                  ENDIF
                  IF (IREF2.EQ.0) THEN !IDENTIFY REFERENCE POINT AND TIME
                      XREF2 = X
                      YREF2 = Y
                      ZREF2 = Z
                      TREF2 = 0.0
                      IREF2 = 1
                  ELSE
                      IREF2 = IREF2 + 1
                      TREF2 = TREF2 + dT
                      IF (IREF2.GT.1000) THEN !COMPARE REFERENCE DISTANCE TO DIFFUSION ONLY DISPLACEMENT 
                          DREF2 = ((X-XREF2)*(X-XREF2)+(Y-YREF2)*
     &                            (Y-YREF2)+(Z-ZREF2)*(Z-ZREF2))**0.5
                          IF (VN.GT.VT) THEN
                              DCOEF = FUN1
                          ELSE
                              DCOEF = FUN4
                          END IF
                          DIND2 = DFACTC*(6.0*DCOEF*KB*T*TREF2/M3)**0.5!SCALE DISPLACEMENT TO DIFFUSION (WITHOUT DIFFSCALE)
                          IF (DREF2.LT.DIND2) THEN 
                              ATTACHK = 4 !RETENTION WITH CONTACT
                          ELSE
                              IREF2 = 0
                          END IF
                      END IF
                  END IF !FOR IF IREF2.EQ.0
              ENDIF !FOR ATTMODE.EQ.0       
          ENDIF !FOR H.LT.2.0E-7

C         EXIT CONDITION IF PARTICLE IS IN BULK FLUID
          IF (((R.GT.RB).AND.(Z.LT.0.0)).AND.
     &	  ((CBGRAV.EQ.1).OR.(CBGRAV.EQ.2))) THEN
              ATTACHK = 1
          END IF
C		  REFLECT COLLOID BACK INTO PREVIOUS POSITION IF EXITED UPPER HEMISPHERE
          IF (((R.GT.RB).AND.(Z.GE.0.0)).AND.
     &	  ((CBGRAV.EQ.1).OR.(CBGRAV.EQ.2))) THEN
              X=XO
    	      Y=YO
	          Z=ZO
          ENDIF
C
C         EXIT any hemisphere after 5% of ZINIT if gravity orthogonal to flow
          IF (((R.GT.RB).AND.(Z.LT.ZINIT*0.95)).AND.
     &	  ((CBGRAV.EQ.3).OR.(CBGRAV.EQ.4))) THEN
            ATTACHK = 1;
          END IF

C         FINISH TRAJECTORY IF PARTICLE STILL IN THE SYSTEM WHEN TOTAL TIME IS REACHED (NO STAGNANT)
          IF (PTIMEF.GT.TTIME) THEN
              ATTACHK = 3
          ENDIF

C         SKIP FORCE AND INTEGRATION IF PARTICLE RESOLVES
          IF (ATTACHK.EQ.0) THEN

C             DETERMINE FORCES

C             CALCULATE COLLOIDAL FORCE (SPHERE-SPHERE GEOMETRY)
C             VIOLATES LINEAR APROXIMATION APPROACH, REASONABLE FOR LARGE COLLECTOR RADII

C             CALCULATE VDW FORCE
              CALL FORCEVDW (A132,AG,AP,ASP,NASP,RMODE,H,LAMBDAVDW,A11,
     &                        A22,A33,AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)

C             CALCULATE EDL 
C             FAVORABLE CONDITIONS IF BULK ZETAC AND ZETAP ARE OPPOSITE IN SIGN, THEN SET SCOV = 0.0 AND SCOVP = 0.0
              IF (((ZETACST.GE.0.0).AND.(ZETAPST.LE.0.0)).OR.
     &            ((ZETACST.LE.0.0).AND.(ZETAPST.GE.0.0))) THEN
                 SCOV = 0.0
                 SCOVP = 0.0
              END IF
C             UNDER UNFAVORABLE CONDITIONS HETERODOMIANS WILL BE SIMULATED IN EITHER COLLECTOR (HETC), OR COLLOID (HETP), OR BOTH
C             TO CALCULATE HETC AND HETP FRACTIONAL AREAS WITHIN ZOI, HETERODOMAINS WILL BE PROJECTED ONTO THE FRAME OF REFERENCE
C             WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER
              IF (((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(I.EQ.1)) THEN
              ! here fix to update colloid tranlation
C                CALCULATE PROJECTION OF COLLOID CENTER ON HAPPEL SPHERE
                 XG = Xm0+ENX*AG
                 YG = Ym0+ENY*AG
                 ZG = Zm0+ENZ*AG
                 AFRACT = 0.0
C                CALCULATE COLLOID RADIAL POSITION - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
                 RO = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0)+
     &                 (Z-Zm0)*(Z-Zm0))**0.5
C                CALCULATE COLLOID THETA ANGLE - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
                 THETA = DACOS((Z-Zm0)/RO)
C                CALCULATE PROJECTION OF COLLOID POSITION ON XY PLANE
                 ROXY = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0))**0.5
C                CALCULATE COLLOID PHI ANGLE - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
                 IF (ROXY.EQ.0.0) THEN
                    PHI = 0.0
                 ELSE
                    IF ((Y-Ym0).GE.0.0) THEN
                        PHI = DACOS((X-Xm0)/ROXY)
                    ELSE
                        PHI = 2.0*PI-DACOS((X-Xm0)/ROXY)
                    ENDIF
                 END IF
C                HETEROGENEITY ON COLLOID (HETP) SUBROUTINE TO DETERMINE HETERODOMAIN PROJECTIONS
C                HETP PROJECTIONS WILL BE GENERATED ASSUMING THAT THE COLLOID CENTER COINCIDES WITH THE HAPPEL SPHERE CENTER
C                THEN HETP PROJECTIONS WILL BE TRANSLATED AND ROTATED TO THE FRAME OF REFERENCE
C                WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER  
                 CALL HETTRACKP(Xm0,Ym0,Zm0,H,RZOIBULK,AP,HETMODEP,
     &                          SCOVP,RHETP0,RHETP1,NHETP,XHETP,YHETP,
     &                          ZHETP,RHETP,NPRO,XPRO,YPRO,ZPRO,RPRO)
C                PROJECTION MATRIX OF HETERODOMAINS ON COLLOID ONTO HAPPEL SPHERE
                 IF (NPRO.EQ.0) THEN
                    NPRO = 1
                    ALLOCATE(MPRO(NPRO,4))
                    MPRO = 0.0
                    ALLOCATE(MPRO_T(NPRO,3))
                    MPRO_T = 0.0
                 ELSE
                    ALLOCATE(MPRO(NPRO,4))
                    CALL PROJECTION_MATRIX(NPRO,XPRO,YPRO,ZPRO,RPRO,
     &                                     MPRO)
                    ALLOCATE(MPRO_T(NPRO,3))
                    CALL MPRO_TRANSFORMATION(X,Y,Z,XG,YG,ZG,THETA,
     &                                      PHI,NPRO,MPRO,MPRO_T)
                 END IF  
              ELSEIF (((SCOV.GT.0.0).OR.(SCOVP.GT.0)).AND.(I.GT.1)) THEN
C                CALCULATE PROJECTION OF COLLOID CENTER ON HAPPEL SPHERE
                 XG = Xm0+ENX*AG
                 YG = Ym0+ENY*AG
                 ZG = Zm0+ENZ*AG
                 AFRACT = 0.0
C                CALCULATE COLLOID RADIAL POSITION - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
                 RO = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0)+
     &                 (Z-Zm0)*(Z-Zm0))**0.5
C                CALCULATE COLLOID THETA ANGLE - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
                 THETA = DACOS((Z-Zm0)/RO)
C                CALCULATE PROJECTION OF COLLOID POSITION ON XY PLANE
                 ROXY = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0))**0.5
C                CALCULATE COLLOID PHI ANGLE - SPHERICAL COORDINATES AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
                 IF (ROXY.EQ.0.0) THEN
                    PHI = 0.0
                 ELSE
                    IF ((Y-Ym0).GE.0.0) THEN
                        PHI = DACOS((X-Xm0)/ROXY)
                    ELSE
                        PHI = 2.0*PI-DACOS((X-Xm0)/ROXY)
                    ENDIF
                 END IF
C                HETEROGENEITY ON COLLOID (HETP) SUBROUTINE TO DETERMINE HETERODOMAIN PROJECTIONS
C                HETP PROJECTIONS WILL BE GENERATED ASSUMING THAT THE COLLOID CENTER COINCIDES WITH THE HAPPEL SPHERE CENTER
C                THEN HETP PROJECTIONS WILL BE TRANSLATED AND ROTATED TO THE FRAME OF REFERENCE
C                WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER  
                 DEALLOCATE(MPRO_T)
                 ALLOCATE(MPRO_T(NPRO,3))
                 CALL MPRO_TRANSFORMATION(X,Y,Z,XG,YG,ZG,THETA,
     &                                    PHI,NPRO,MPRO,MPRO_T)
              END IF
C             CALCULATE HETERODOMAINS INFLUENCE 
              IF(((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(HFLAG.GT.1))THEN
C             HETEROGENEITY ON COLLECTOR (HETC) SUBROUTINE TO DETERMINE CLOSEST HETERODOMAIN TO COLLOID
C             HETC WILL BE TRANSLATED TO THE FRAME OF REFERENCE WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER            
                 IF (SCOV.GT.0.0) THEN
                    CALL HETTRACK(X,Y,Z,Xm0,Ym0,Zm0,AG,RZOI,HETMODE,
     &                            SCOV,RHET0,RHET1,RHET2,XHET,YHET,ZHET,
     &                            RHET)
                    CALL HETC_TRANSFORMATION(XG,YG,ZG,XHET,YHET,ZHET,
     &                                       RHET,HETMODE,THETA,
     &                                       PHI,XHET_T,YHET_T,
     &                                       ZHET_T,RHET_T)
                ELSE
                    XHET_T = 0.0
                    YHET_T = 0.0
                    ZHET_T = 0.0
                    RHET_T = 0.0
                ENDIF
C               INITIALIZE FRACTIONAL AREAS
                AFRACT = 0.0       !TOTAL ATTRACTIVE FRACTIONAL AREA
                AFRACT_PZ = 0.0    !PRO-ZOI FRACTIONAL AREA
                AFRACT_ZH = 0.0    !ZOI-HET FRACTIONAL AREA
                AFRACT_PZH = 0.0   !PRO-ZOI-HET FRACTIONAL AREA
                AFRACT_Z = 0.0     !ZOI FRACTIONAL AREA NON-OVERLAPPED
C               CALCULATE OVERLAPING AREA OF HETERODOMAINS AND ZOI
C               GIVEN THAT THE PROJECTION OF COLLOID CENTER CORRESPONDS TO THE ORIGIN OF THE FRAME OF REFERENCE WITH X-Y PLANE 
C               MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER, VARIABLES 
C               EQUAL TO 0.0 MUST BE PASSED TO THE FIRST TWO POSITIONS OF SUBROUTINE FRACTIONAL_AREA              
                CALL FRACTIONAL_AREA(Xm0,Ym0,RZOIBULK,Xm0,Ym0,Zm0,NPRO,
     &                               MPRO_T,AF_PZ,AF_ZH,AF_PZH,AF_Z)
                AFRACT = AF_PZ
                AFRACT_PZ = AF_PZ
                DO K=1,HETMODE
                    CALL FRACTIONAL_AREA(Xm0,Ym0,RZOIBULK,XHET_T(K),
     &                                   YHET_T(K),RHET_T(K),NPRO,
     &                                   MPRO_T,AF_PZ,AF_ZH,AF_PZH,AF_Z)
                    AFRACT = AFRACT + AF_ZH               !TOTAL ATTRACTIVE FRACTIONAL AREA
                    IF (AF_ZH.GT.0.0) THEN
                        AFRACT = AFRACT - AF_PZH          !TOTAL ATTRACTIVE FRACTIONAL AREA
                        AFRACT_PZ = AFRACT_PZ - AF_PZH    !PRO-ZOI FRACTIONAL AREA
                    ENDIF
                    AFRACT_ZH = AFRACT_ZH + AF_ZH         !ZOI-HET FRACTIONAL AREA
                    AFRACT_PZH = AFRACT_PZH + AF_PZH      !PRO-ZOI-HET FRACTIONAL AREA
                    AFRACT_Z = 1 - AFRACT_PZ - AFRACT_ZH - AFRACT_PZH !ZOI FRACTIONAL AREA NON-OVERLAPPED    
C                   DETERMINE TYPE OF HETERODOMAIN COLLOID IS OVERLAPPING (NONE=0, LARGE=1, MEDIUM=2, SMALL=3, LARGE AND MEDIUM=4, LARGE AND SMALL=5, MEDIUM AND SMALL=6)
                    IF ((AF_ZH.GT.0.0).AND.(K.EQ.1)) THEN
                       HETTYPE = 1
                    END IF
                    IF ((HETMODE.EQ.5).OR.(HETMODE.EQ.9)) THEN
                       IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.0)
     &                      .AND.(K.GT.1))THEN
                            HETTYPE = 2
                       END IF
                       IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.1)
     &                      .AND.(K.GT.1))THEN
                            HETTYPE = 4
                       END IF
                    ELSEIF (HETMODE.EQ.73) THEN
                       IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.0)
     &                      .AND.(K.GT.1.AND.K.LE.9))THEN
                            HETTYPE = 2
                       END IF
                       IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.0)
     &                      .AND.(K.GT.9))THEN
                            HETTYPE = 3
                       END IF
                       IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.1)
     &                      .AND.(K.GT.1.AND.K.LE.9))THEN
                            HETTYPE = 4
                       END IF
                       IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.1)
     &                      .AND.(K.GT.9))THEN
                            HETTYPE = 5
                       END IF
                       IF ((AF_ZH.GT.0.0).AND.(HETTYPE.EQ.2)
     &                      .AND.(K.GT.9))THEN
                            HETTYPE = 6
                       END IF
                    ENDIF                    
                END DO
                !DEALLOCATE(M_PRO)
                IF (AFRACT.GT.0.0) THEN
                    !CALCULATE PRO-ZOI ATTRACTIVE CONTRIBUTION TO EDL FORCE
                    ZETAC = ZETACST
                    ZETAP = ZETAHETP
                    CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                             AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
                    FEDL_PZ = FEDL
                    !CALCULATE ZOI-HET ATTRACTIVE CONTRIBUTION TO EDL FORCE
                    ZETAC = ZETAHET
                    ZETAP = ZETAPST
                    CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                             AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
                    FEDL_ZH = FEDL
                    !CALCULATE PRO-ZOI-HET REPULSIVE CONTRIBUTION TO EDL FORCE
                    ZETAC = ZETAHET
                    ZETAP = ZETAHETP
                    CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                             AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
                    FEDL_PZH = FEDL
                    !CALCULATE ZOI REPULSIVE CONTRIBUTION TO EDL FORCE
                    ZETAC = ZETACST
                    ZETAP = ZETAPST
                    CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                             AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
                    FEDL_Z = FEDL
                    !CALCULATE NET EDL FORCE
                    FEDL = AFRACT_PZ*FEDL_PZ + AFRACT_ZH*FEDL_ZH + 
     &               AFRACT_PZH*FEDL_PZH + AFRACT_Z*FEDL_Z
                ELSE !(AFRACT.GT.0.0)
                    ZETAC = ZETACST
                    ZETAP = ZETAPST
                    CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                             AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
                ENDIF !(AFRACT.GT.0.0)
              ELSE !(((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(HFLAG.GT.1))
                AFRACT = -1.0
                ZETAC = ZETACST
                ZETAP = ZETAPST
                CALL FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                         AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
              END IF !(((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)).AND.(HFLAG.GT.1))

C             CALCULATE ACID-BASE, BORN, AND STERIC REPULSION
              CALL FORCEAB (PI,AG,AP,ASP,NASPAB,RMODE,LAMBDAAB,
     &                                GAMMA0AB,H,H0,FAB)
              CALL FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                            A22,A33,AC1C1,AC2C2,VDWMODE)
              CALL FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
              
              FCOLL = FVDW + FEDL + FAB + FBORN + FSTE
              
C             CALCULATE NON-COLLOIDAL FORCES (DRAG,DIFFUSION,GRAVITY,LIFT)

C             CALCULATE DRAG FORCE
C             CALCULATE FLUID VELOCITY AT GIVEN LOCATION BEFORE CALCULATING DRAG FORCE
              IF (R.LE.RB) THEN
                  CALL HAPPELFF (X,Y,Z,AG,B,K1,K2,K3,K4,VxH1,VyH1,VzH1)
                  VX = VxH1*VSUP
                  VY = VyH1*VSUP
                  VZ = VzH1*VSUP
              ELSE
                  VX = 0.0
                  VY = 0.0
                  VZ = -VSUP
              ENDIF

C             CALCULATE NORMAL AND TANGENTIAL COMPONENTS
	        VN = VX*ENX+VY*ENY+VZ*ENZ
	        VNX = VN*ENX
	        VNY = VN*ENY
              VNZ = VN*ENZ
	        VTX = VX-VNX
              VTY = VY-VNY
	        VTZ = VZ-VNZ
              VT = (VTX*VTX+VTY*VTY+VTZ*VTZ)**0.5
C             DEFINE TANGENTIAL FLUID VELOCITY UNIT VECTORS FOR CARTESIAN COMPONENTS DETERMINED BELOW
              IF (VT.EQ.0) THEN
                  ETX = 0.0
                  ETY = 0.0
                  ETZ = 0.0
              ELSE
                  ETX = VTX/VT
                  ETY = VTY/VT
                  ETZ = VTZ/VT
              ENDIF
C             UNIVERSAL HYDRODYNAMIC FUNCTIONS
	        HBAR = (H+B)/AP
	        FUN1=1.0+B1*EXP(-C1*HBAR)+D1*EXP(-E1*HBAR**A1)
	        FUN2=1.0+B2*EXP(-C2*HBAR)+D2*EXP(-E2*HBAR**A2)
	        FUN3=1.0+B3*EXP(-C3*HBAR)+D3*EXP(-E3*HBAR**A3)
	        FUN4=1.0+B4*EXP(-C4*HBAR)+D4*EXP(-E4*HBAR**A4)
C             NORMAL AND TANGENTIAL DRAG FORCES ARE CALCULATED WITH CORRECTED FUN2 AND FUN3 IN THE SUBROUTINE
              CALL FORCEDRAG (FUN2,FUN3,FUN4,M3,VN,VT,FDRGT,FDRGN)

C             CALCULATE DIFFUSION FORCE 
              CALL FORCEDIFF(DIFFSCALE,PI,VISC,AP,KB,T,dT,FDIFX,FDIFY,
     &                        FDIFZ)
              IF (H.LE.HFRIC) THEN
C                 DIFFUSION FORCES EQUAL TO ZERO IN CONTACT 
                  FDIFX=0.0
	            FDIFY=0.0
	            FDIFZ=0.0
              END IF

C             CALCULATE GRAVITATIONAL FORCE  
              CALL GRAVITY(GRAVFACT,AP,G,RHOP,RHOW,PI,FG)
              
C             CALCULATE LIFT FORCE
              CALL FORCELIFT (RHOW,R,AP,AG,VT,UT,OMEGA,FLIFT)

C             BREAK FORCES INTO CARTESIAN COMPONENTS
C             WHEN EXAMINING NORMAL AND TANGENTIAL: POSITIVE NORMAL IS AWAY FROM THE SURFACE, 
C             NEGATIVE NORMAL IS TOWARDS THE SURFACE
C             GRAVITATIONAL 
C		
C		       !calculate gravity for initial step
C		       !gravity direction EGX EGY EGZ is set at the beginning of this code
C		       !depending on GUI input (cbMZ cbPZ cbMX cbPX)
C		       !the function below projects cartesian gravity toward normal and
C		       !tangential axes. 
C			   !+Normal points away from the collector surface,
C		       !-Normal points towards collector surface
C		       !+tangential is aligned with tangential velocity from Happel flow field
C		       !-tangential is opposed to tangential velocity from Happel flow field 
			   CALL GRAVVECT (FG,EGX,EGY,EGZ,ENX,ENY,ENZ,ETX,ETY,ETZ,
     &					FGN,FGT,FGNX,FGNY,FGNZ,FGTX,FGTY,FGTZ)				
C	
C             COLLOIDAL
	        FCOLLX=FCOLL*ENX
	        FCOLLY=FCOLL*ENY
	        FCOLLZ=FCOLL*ENZ
C             DRIVING DRAG FORCE
	        FDRGNX=FDRGN*ENX
	        FDRGNY=FDRGN*ENY
	        FDRGNZ=FDRGN*ENZ
	        FDRGTX=FDRGT*ETX
	        FDRGTY=FDRGT*ETY
	        FDRGTZ=FDRGT*ETZ    
              FDRGX = FDRGNX + FDRGTX
              FDRGY = FDRGNY + FDRGTY
              FDRGZ = FDRGNZ + FDRGTZ
C             LIFT 
              FLIFTX=FLIFT*ENX
	        FLIFTY=FLIFT*ENY
	        FLIFTZ=FLIFT*ENZ

C             DIFFUSION FORCES OPERATE WHEN NOT IN CONTACT
              FDIFN=FDIFX*ENX+FDIFY*ENY+FDIFZ*ENZ
	        FDIFNX=FDIFN*ENX
	        FDIFNY=FDIFN*ENY
	        FDIFNZ=FDIFN*ENZ
	        FDIFTX=(FDIFX-FDIFNX)
	        FDIFTY=(FDIFY-FDIFNY)
              FDIFTZ=(FDIFZ-FDIFNZ)

C             INTEGRATE
C             INTEGRATION ADDS AN EXTRA TERM TO ACCOUNT FOR FLOW DISTURBANCE
C             DUE TO PRESENCE OF STATIONARY PARTICLE, 
C             REF. MA ET AL. 2009 SI -Hemispheres-in-cell geometry to predict colloid deposition in porous media 
C	        INTEGRATE NORMAL AND TANGENTIAL(x,y,z) FORCES TO PARTICLE VELOCITIES
C
C             STEADY STATE FORMULATION
!        	    UNX = (FUN1/M3)*(FGNX+FCOLLX+FDIFNX+FLIFTX+FDRGNX)
!        	    UNY = (FUN1/M3)*(FGNY+FCOLLY+FDIFNY+FLIFTY+FDRGNY)
!        	    UNZ = (FUN1/M3)*(FGNZ+FCOLLZ+FDIFNZ+FLIFTZ+FDRGNZ)
!C
!             UTX = (FUN4*(FGTX+FDIFTX)+FDRGTX)/M3
!             UTY = (FUN4*(FGTY+FDIFTY)+FDRGTY)/M3
!             UTZ = (FUN4*(FGTZ+FDIFTZ)+FDRGTZ)/M3

C             SAVE VELOCITIES FROM PREVIOUS TIME STEP
              !IF (I.EQ.1) THEN  !NEED TO APPLY AT  I=1 SINCE FIRST TRANSLATION IS ALREADY DONE
              !    UN = UX*ENX+UY*ENY+UZ*ENZ
              !    UNX = UN*ENX
              !    UNY = UN*ENY
              !    UNZ = UN*ENZ
              !    UTX = UX-UNX
              !    UTY = UY-UNY
              !    UTZ = UZ-UNZ
              !END IF
	        UXO = UNX + UTX
	        UYO = UNY + UTY
	        UZO = UNZ + UTZ
              UNO = UXO*ENX+UYO*ENY+UZO*ENZ
              UNXO = UNO*ENX
              UNYO = UNO*ENY
              UNZO = UNO*ENZ
              UTXO = UXO-UNXO
              UTYO = UYO-UNYO
              UTZO = UZO-UNZO

C             INTEGRATION UTILIZING AN IMPLICIT APPROACH, I.E., RESISITNG DRAG PARTICLE VELOCITY CORRESPONDS
c             TO THE FUTURE LOCATION WHILE FORCES CORRESPOND TO ACTUAL LOCATION.
C             EXPLICIT APPROACH WAS DISCARDED BECAUSE THE MODEL BECOMES UNSTABLE AND EXTREMELY DEPENDENT ON dT

        	    UNX = ((MP+VM)*UNXO+(FGNX+FCOLLX+FDIFNX+FLIFTX+FDRGNX)*dT)/
     &                 (MP+VM+M3/FUN1*dT)
        	    UNY = ((MP+VM)*UNYO+(FGNY+FCOLLY+FDIFNY+FLIFTY+FDRGNY)*dT)/
     &                 (MP+VM+M3/FUN1*dT)
        	    UNZ = ((MP+VM)*UNZO+(FGNZ+FCOLLZ+FDIFNZ+FLIFTZ+FDRGNZ)*dT)/
     &                 (MP+VM+M3/FUN1*dT)
C             NORMAL VELOCITY IS NEGATIVE IF THE VELOCITY VECTOR POINTS 
C                         TO THE COLLECTOR WHEN PROJECTED ON THE COLLOID POSITION VECTOR
              UN = SIGN((UNX**2+UNY**2+UNZ**2)**0.5,
     &                            (ENX*UNX+ENY*UNY+ENZ*UNZ))

C             TANGENTIAL VELOCITY FROM MA ET AL. 2009 EQUATION S14
              IF (H.GT.HFRIC) THEN
        	        UTX = ((MP+VM)*UTXO+(FGTX+FDIFTX+FDRGTX)*dT)/
     &                  (MP+VM+M3/FUN4*dT)
        	        UTY = ((MP+VM)*UTYO+(FGTY+FDIFTY+FDRGTY)*dT)/
     &                  (MP+VM+M3/FUN4*dT)
        	        UTZ = ((MP+VM)*UTZO+(FGTZ+FDIFTZ+FDRGTZ)*dT)/
     &                  (MP+VM+M3/FUN4*dT)
C                 TANGENTIAL VELOCITY IS NEGATIVE IF THE TANGENTIAL VELOCITY VECTOR POINTS 
C                                 TO THE ENTRANCE OF THE CELL (+Z) WHEN PROJECTED ON THE Z-AXIS
C                                 SIGN(A,B) returns the value of A with the sign of B
                  UT = SIGN((UTX**2+UTY**2+UTZ**2)**0.5,-UTZ)
C                 FIT OMEGA*AP/UT AS FUNCTION OF H/AP USING GCB 1967b TABLES 2&3
                  OMEGA = ABS(UT)/AP*(0.5518+117.4*(H/AP))/
     &                    (1+232.1*(H/AP)+237.7*(H/AP)**2.0)
              ENDIF  

C             INTEGRATION IF PARTICLE IS IN CONTACT
              IF (H.LE.HFRIC)THEN

C                 CALCULATE NORMAL ADHESIVE AND REPULSIVE FORCES FOR RESISTING TORQUE
                  FADH = FVDW + FEDL + FGN + FLIFT + FDRGN
                  FREP = FBORN
                  IF (FAB.LT.0.0) THEN
                      FADH = FADH + FAB
                  ELSE
                      FREP = FREP + FAB
                  END IF
                  IF (FSTE.LT.0.0) THEN
                      FADH = FADH + FSTE
                  ELSE
                      FREP = FREP + FSTE
                  END IF                 
                  IF (FADH.GT.0.0) THEN
                      FADH = 0.0;
                  ELSE
C                     SINCE ATTRACTIVE FORCES ARE NEGATIVE IN SIGN, FLIP THE SIGN OF FADH TO MAKE IT POSITIVE
                      FADH = -FADH;                     
                  END IF                 
C                 CALCULATE ADHESIVE TORQUE LEVER ARM
                  RLEV = AP*ASP2/(AP+ASP2)
                  IF (RLEV.LE.ACONT) THEN
                      RLEV = ACONT !LARGER RESISTING LEVER ARM DUE TO DEFORMATION THAN ROUGHNESS
                  ENDIF                  
                    
C                 FORCE AND TORQUE COMPONENTS FROM GCB 1967A/B AS H/AP GOES TO 0
                  FSHRT = 1.7005
                  TSHRY = 0.9440
                  FTRT = (8.0/15.0)*LOG(H/AP)-0.9588
                  FROT = -(2.0/15.0)*LOG(H/AP)-0.2526	
                  TTRY = -(1.0/10.0)*LOG(H/AP)-0.1895
                  TROY = (2.0/5.0)*LOG(H/AP)-0.3817
                  
C                 INTEGRATE TANGENTIAL VELOCITY
C                 By ignoring FG AND FDIFF TANGENTIAL, the influence of gravity and Brownian motion are ignored. 
C                 However we need to do this because determining the direction in the tangential axis is not straight forward.
C                 This is a point for future exploration
                  UTO = (UTXO*UTXO+UTYO*UTYO+UTZO*UTZO)**0.5
                  
c                 THE TERM IN THE VELOCITY INTEGRATION APPEAR ALL POSITIVE, RESISTING FORCES AND TORQUES NEGATIVE SIGN IS DETERMINED BY THE 
C                 DIMENSIONLESS HYDRODYNAMIC CORRECTION FACTOR CALCULATED ABOVE, THE NORMAL FORCE MUST BE NEGATIVE (ATRACTIVE) FOR ADHESION TO OCCUR (EQUAL TO ATRACTIVE COLLOIDAL FORCES)
C                 TANGENTIAL VELOCITY FROM MA ET AL. 2011 EQUATION S6 - NOTE THAT MISTAKES ARE CORRECTED
                  UT = (1.4*(MP+VM)*UTO
     &                    -FADH*RLEV/AP*(AP-DELTA)/AP*dT
     &                    +6.0*PI*VISC*(AP-DELTA)*VT*dT*
     &                    (FSHRT+2.0/3.0*AP/(H+AP)*TSHRY))
     &                /(1.4*(MP+VM)-6.0*PI*VISC*(AP-DELTA)*dT*
     &                        (FTRT+FROT+4.0/3.0*(TTRY+TROY)))
C                 ASSIGN NEGATIVE TANGENTIAL VELOCITY AS ZERO
                  IF (UT.LT.0.0) THEN
                      UT = 0.0
                      ARRESTFLAG = 1
                  ENDIF
C                 RESET ARRESTFLAG IF COLLOID IS NOT IN EQUILIBRIUM
                  IF ((FADH.LT.0.995*FREP).OR.
     &                        (FADH.GT.1.005*FREP)) THEN
                      ARRESTFLAG = 0
                  ENDIF
                  UTX = ETX*UT
                  UTY = ETY*UT
                  UTZ = ETZ*UT
C                 NO SLIP SO OMEGA*AP/UT=1
                  OMEGA = UT/AP
              END IF !(H.LT.HFRIC)
C
C             RECOMPOSE CARTESIAN VELOCITIES
	        UX=UNX+UTX
	        UY=UNY+UTY
	        UZ=UNZ+UTZ
              
          ELSE !ATTACHK.GT.0
C             STORE FINAL TRAJECTORY VALUES
              ETIME = PTIMEF-PTIMEFOT(1) !Calculate final elapsed time
              IOT(OUTCOUNT) = I
              XOT(OUTCOUNT) = X
              YOT(OUTCOUNT) = Y
              ZOT(OUTCOUNT) = Z
              ROT(OUTCOUNT) = R
              HOT(OUTCOUNT) = H
              ETIMEOT(OUTCOUNT) = ETIME
              PTIMEFOT(OUTCOUNT) = PTIMEF
              FCOLLOT(OUTCOUNT) = FCOLL
              FVDWOT(OUTCOUNT) = FVDW
              FEDLOT(OUTCOUNT) = FEDL
              FABOT(OUTCOUNT) = FAB
              FSTEOT(OUTCOUNT) = FSTE
              FBORNOT(OUTCOUNT) = FBORN
              UTOT(OUTCOUNT) = UT
              UNOT(OUTCOUNT) = UN
              VTOT(OUTCOUNT) = VT
              VNOT(OUTCOUNT) = VN
              FDRGTOT(OUTCOUNT) = FDRGT
              FDRGNOT(OUTCOUNT) = FDRGN
              FDIFXOT(OUTCOUNT) = FDIFX
              FDIFYOT(OUTCOUNT) = FDIFY
              FDIFZOT(OUTCOUNT) = FDIFZ
              FGTOT(OUTCOUNT) = FGT
              FGNOT(OUTCOUNT) = FGN
              FLIFTOT(OUTCOUNT) = FLIFT
              ACONTOT(OUTCOUNT) = ACONT
              RZOIOT(OUTCOUNT) = RZOI
              AFRACTOT(OUTCOUNT) = AFRACT
          END IF !IF ATTACHK.EQ.0

        END DO !TRAJECTORY LOOP (ATTACHK=0)

C       WRITE ARRAY TO FILE 

        WRITE (11,105) ATTACHK
        WRITE (11,106)
        WRITE (12,105) ATTACHK
        WRITE (12,106)
        WRITE (13,105) ATTACHK
        WRITE (13,106)
     
C       WRITE DATA TO FLUX AND TRAJECTORY FILES
        NPRINT = INT(OUTCOUNT/PRINTMAX)+1
        
        IF (ATTACHK.EQ.1)THEN !EXITED PARTICLE
C           WRITE TO TRACTORY FILE
            DO K=1,OUTFLAG-1
                WRITE (11,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO
            DO K=OUTFLAG,OUTCOUNT-2,NPRINT
                WRITE (11,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO
            DO K=OUTCOUNT-1-MOD(OUTCOUNT-2-OUTFLAG,NPRINT),OUTCOUNT
                WRITE (11,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO

C           WRITE TO FLUX FILE
            WRITE (21,207)ipart,ATTACHK,XINIT,YINIT,RINJ,ZINIT,RINIT,
     &            HINIT,X,Y,Z,R,H,ETIME,PTIMEFOT(1),PTIMEF,TBULK,TNEAR,
     &            TFRIC,NSVISIT,FRICVISIT,ACONT,RZOI,AFRACT,HETTYPE,
     &            HETFLAG,NSVEL,HAVE,XINNS,YINNS,ZINNS
            
        END IF

        IF ((ATTACHK.EQ.2).OR.(ATTACHK.EQ.4).OR.(ATTACHK.EQ.6)) THEN !ATTACHED PARTICLE
C           WRITE TO TRACTORY FILE
            DO K=1,OUTFLAG-1
                WRITE (12,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO
            DO K=OUTFLAG,OUTCOUNT-2,NPRINT
                WRITE (12,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO
            DO K=OUTCOUNT-1-MOD(OUTCOUNT-2-OUTFLAG,NPRINT),OUTCOUNT
                WRITE (12,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO

C           WRITE TO FLUX FILE
            WRITE (22,207)ipart,ATTACHK,XINIT,YINIT,RINJ,ZINIT,RINIT,
     &            HINIT,X,Y,Z,R,H,ETIME,PTIMEFOT(1),PTIMEF,TBULK,TNEAR,
     &            TFRIC,NSVISIT,FRICVISIT,ACONT,RZOI,AFRACT,HETTYPE,
     &            HETFLAG,NSVEL,HAVE,XINNS,YINNS,ZINNS

        END IF

        IF ((ATTACHK.EQ.3).OR.(ATTACHK.EQ.5)) THEN !REMAINING PARTICLE
C           WRITE TO TRACTORY FILE
            DO K=1,OUTFLAG-1
                WRITE (13,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO
            DO K=OUTFLAG,OUTCOUNT-2,NPRINT
                WRITE (13,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO
            DO K=OUTCOUNT-1-MOD(OUTCOUNT-2-OUTFLAG,NPRINT),OUTCOUNT
                WRITE (13,107)IOT(K),XOT(K),YOT(K),ZOT(K),ROT(K),HOT(K),
     &          ETIMEOT(K),PTIMEFOT(K),FCOLLOT(K),FVDWOT(K),FEDLOT(K),
     &          FABOT(K),FSTEOT(K),FBORNOT(K),UTOT(K),UNOT(K),VTOT(K),
     &          VNOT(K),FDRGTOT(K),FDRGNOT(K),FDIFXOT(K),FDIFYOT(K),
     &          FDIFZOT(K),FGTOT(K),FGNOT(K),FLIFTOT(K),ACONTOT(K),
     &          RZOIOT(K),AFRACTOT(K)
            END DO

C           WRITE TO FLUX FILE
            WRITE (23,207)ipart,ATTACHK,XINIT,YINIT,RINJ,ZINIT,RINIT,
     &            HINIT,X,Y,Z,R,H,ETIME,PTIMEFOT(1),PTIMEF,TBULK,TNEAR,
     &            TFRIC,NSVISIT,FRICVISIT,ACONT,RZOI,AFRACT,HETTYPE,
     &            HETFLAG,NSVEL,HAVE,XINNS,YINNS,ZINNS
        END IF

C       CLOSE ATTACHED PARTICLES FLUX FILES TO RELOAD FILE FOR NEXT PARTICLE LOOP
        IF (ATTMODE.EQ.-1) THEN
            CLOSE(99)
        ENDIF

C       EMPTY PROJECTION MATRIX
        IF ((SCOV.GT.0.0).OR.(SCOVP.GT.0.0)) THEN
           DEALLOCATE(MPRO)
           DEALLOCATE(MPRO_T)
        ENDIF        
        
      END DO !LOOP TO NEXT PARTICLE

 5001 FORMAT (E15.8,2X,E15.8,2X,E15.8,2X,I10) 
 
      END PROGRAM HAPHETLN


C     SUBROUTINES FOR FORCES ON COLLOID (VDW,EDL,AB,BORN,STERIC,DRAG,DIFFUSION,GRAVITY,LIFT)

C     SUBROUTINE VDW FORCE (N)
      SUBROUTINE FORCEVDW (A132,AG,AP,ASP,NASP,RMODE,H,LAMBDAVDW,A11,
     &                     A22,A33,AC1C1,AC2C2,T1,T2,VDWMODE,FVDW)
	 
      INTEGER VDWMODE,RMODE
      DOUBLE PRECISION A132,AG,AP,ASP,NASP,H,H2,LAMBDAVDW,A11,A22,A33,
     &                 AC1C1,AC2C2,T1,T2,FVDW,FVDW1,FVDW2
      DOUBLE PRECISION A12,A1C2,A13,AC12,AC1C2,
     &                 AC13,A23,AC23
      DOUBLE PRECISION COEFH1,COEFH2,COEFH3,COEFH4,COEFA1,COEFA2
     &                 COEF,COEF2,COEF3,COEF4,COEF5,ACP,ACG
      
      A12 = (A11**0.5)*(A22**0.5)
      A1C2 = (A11**0.5)*(AC2C2**0.5) 
      A13 = (A11**0.5)*(A33**0.5)
      AC12 = (AC1C1**0.5)*(A22**0.5)
      AC1C2 = (AC1C1**0.5)*(AC2C2**0.5)
      AC13 = (AC1C1**0.5)*(A33**0.5)
      A23 = (A22**0.5)*(A33**0.5)
      AC23 = (AC2C2**0.5)*(A33**0.5)   
C	CALC VDW (SPHERE-SPHERE GEOMETRY JUSTIFIED BY LINEAR APPROXIMATION) Gregory retarded vdw energy 1981 from Elimelech Part. Dep book
	IF (VDWMODE.EQ.1) THEN
          IF (RMODE.EQ.0) THEN !SMOOTH SURFACE ON BOTH
              FVDW = -(A132*AP*AG/(6.0*(AP+AG)*H**2.0)) !(SPHERE-SPHERE GEOMETRY) -RETARDED VAN DER WAALS EXPRESSION DERIVED FROM ENERGY GIVEN BY NIR 1977 INCLUDING RETARDATION FROM GREGORY 1981
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
          END IF
          IF (RMODE.EQ.1) THEN !ASPERITIES ON COLLOID
              H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C             CALCULATE VDW INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-SPHERE)
              FVDW1 = -(A132*AP*AG/(6.0*(AP+AG)*H2**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H2))
C             CALCULATE VDW INTERACITON BETWEEN ASPERTIES AND COLLECTOR (SPHERE-SPHERE)
			  IF (H.LE.ASP) THEN 
				 FVDW2 = -(A132*ASP*AG/(6.0*(ASP+AG)*H**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
			  ELSE
				 FVDW2 = 0.0
			  END IF	 
C             CALCULATE TOTAL INTERACTION
              FVDW = FVDW1 + NASP*FVDW2
          END IF
          IF (RMODE.EQ.2) THEN !ASPERITIES ON COLLECTOR
              H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C             CALCULATE VDW INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-SPHERE)
              FVDW1 = -(A132*AP*AG/(6.0*(AP+AG)*H2**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H2))
C             CALCULATE VDW INTERACITON BETWEEN ASPERTIES AND COLLOID (SPHERE-SPHERE)
			  IF (H.LE.ASP) THEN 
				 FVDW2 = -(A132*ASP*AP/(6.0*(ASP+AP)*H**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
			  ELSE
				 FVDW2 = 0.0
			  END IF	
C             CALCULATE TOTAL INTERACTION
              FVDW = FVDW1 + NASP*FVDW2
          END IF
          IF (RMODE.EQ.3) THEN  !ASPERITIES ON BOTH SURFACES
              H2 = H + 0.5*(2*ASP+3**0.5*ASP) !AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
C             CALCULATE VDW INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-SPHERE)
              FVDW1 = -(A132*AP*AG/(6.0*(AP+AG)*H2**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H2))
C             CALCULATE VDW INTERACTION BETWEEN ASPERITIES (SPHERE-SPHERE GEOMETRY JUSTIFIED BY LINEAR APPROXIMATION) Gregory retarded vdw energy 1981 from Elimelech Part. Dep book
			  IF (H.LE.ASP) THEN 
				 FVDW2 = -(A132*ASP*ASP/(6.0*(ASP+ASP)*H**2.0))
     &                *(LAMBDAVDW/(LAMBDAVDW+5.32*H))
			  ELSE
				 FVDW2 = 0.0
			  END IF	              
C             CALCULATE TOTAL INTERACTION
              FVDW = FVDW1 + 2.5*NASP*FVDW2
          END IF
      END IF
C     VDW EXPRESSION DERIVED FROM EXPRESION DEVELOPED BY Nir 1977 AND Vincent 1973. RETARDATION FACTOR AS SUGGESTED BY Ho AND Higuchi 1968
      IF (VDWMODE.EQ.2) THEN
          ACP = AP-T1
          ACG = AG-T2
          COEFH1 = H 
          COEFH2 = H+T1
          COEFH3 = H+T2
          COEFH4 = H+T1+T2
          COEFA1 = ACP+T1
          COEFA2 = ACG+T2
          COEF = ACP+ACG+T1+T2
          COEF2 = ACP+ACG+T2
          COEF3 = ACP+ACG+T1
          COEF4 = ACP+ACG
          COEF5 = H+ACP+ACG+T1+T2
          FVDW = -(AC1C2-AC23-AC13+A33)*
     &        (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH1)*
     &        (4*COEFA1*COEFA2*COEF5*(1/(COEFH1**2+2*COEFH1*COEF)**2
     &        +1/(COEFH1**2+2*COEFH1*COEF+4*COEFA1*COEFA2)**2)
     &        -2*COEF5*(1/(COEFH1**2+2*COEFH1*COEF)
     &        -1/(COEFH1**2+2*COEFH1*COEF+4*COEFA1*COEFA2)))
     &        +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH1)**2*
     &        (2*COEFA1*COEFA2/(COEFH1**2+2*COEFH1*COEF)
     &        +2*COEFA1*COEFA2/(COEFH1**2+2*COEFH1*COEF
     &        +4*COEFA1*COEFA2)
     &        +LOG((COEFH1**2+2*COEFH1*COEF)/
     &        (COEFH1**2+2*COEFH1*COEF+4*COEFA1*COEFA2))))/6
     &        -(A1C2-AC1C2-A13+AC13)*
     &        (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH2)*
     &        (4*ACP*COEFA2*COEF5*(1/(COEFH2**2+2*COEFH2*COEF2)**2
     &        +1/(COEFH2**2+2*COEFH2*COEF2+4*ACP*COEFA2)**2)
     &        -2*COEF5*(1/(COEFH2**2+2*COEFH2*COEF2)
     &        -1/(COEFH2**2+2*COEFH2*COEF2+4*ACP*COEFA2)))
     &        +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH2)**2*
     &        (2*ACP*COEFA2/(COEFH2**2+2*COEFH2*COEF2)
     &        +2*ACP*COEFA2/(COEFH2**2+2*COEFH2*COEF2
     &        +4*ACP*COEFA2)
     &        +LOG((COEFH2**2+2*COEFH2*COEF2)/
     &        (COEFH2**2+2*COEFH2*COEF2+4*ACP*COEFA2))))/6
     &        -(AC12-A23-AC1C2+AC23)*
     &        (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH3)*
     &        (4*COEFA1*ACG*COEF5*(1/(COEFH3**2+2*COEFH3*COEF3)**2
     &        +1/(COEFH3**2+2*COEFH3*COEF3+4*COEFA1*ACG)**2)
     &        -2*COEF5*(1/(COEFH3**2+2*COEFH3*COEF3)
     &        -1/(COEFH3**2+2*COEFH3*COEF3+4*COEFA1*ACG)))
     &        +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH3)**2*
     &        (2*COEFA1*ACG/(COEFH3**2+2*COEFH3*COEF3)
     &        +2*COEFA1*ACG/(COEFH3**2+2*COEFH3*COEF3
     &        +4*COEFA1*ACG)
     &        +LOG((COEFH3**2+2*COEFH3*COEF3)/
     &        (COEFH3**2+2*COEFH3*COEF3+4*COEFA1*ACG))))/6          
     &        -(A12-AC12-A1C2+AC1C2)*
     &        (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH4)*
     &        (4*ACP*ACG*COEF5*(1/(COEFH4**2+2*COEFH4*COEF4)**2
     &        +1/(COEFH4**2+2*COEFH4*COEF4+4*ACP*ACG)**2)
     &        -2*COEF5*(1/(COEFH4**2+2*COEFH4*COEF4)
     &        -1/(COEFH4**2+2*COEFH4*COEF4+4*ACP*ACG)))
     &        +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH4)**2*
     &        (2*ACP*ACG/(COEFH4**2+2*COEFH4*COEF4)
     &        +2*ACP*ACG/(COEFH4**2+2*COEFH4*COEF4
     &        +4*ACP*ACG)
     &        +LOG((COEFH4**2+2*COEFH4*COEF4)/
     &        (COEFH4**2+2*COEFH4*COEF4+4*ACP*ACG))))/6 
      END IF
      IF (VDWMODE.EQ.3) THEN
          ACP = AP
          ACG = AG-T2
          COEFH1 = H 
          COEFH2 = H+T2
          COEFA2 = ACG+T2
          COEF = ACP+ACG+T2
          COEF2 = ACP+ACG
          COEF3 = H+ACP+ACG+T2
          FVDW = -(A1C2-AC23-A13+A33)*
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH1)*
     &         (4*ACP*COEFA2*COEF3*(1/(COEFH1**2+2*COEFH1*COEF)**2
     &         +1/(COEFH1**2+2*COEFH1*COEF+4*ACP*COEFA2)**2)
     &         -2*COEF3*(1/(COEFH1**2+2*COEFH1*COEF)
     &         -1/(COEFH1**2+2*COEFH1*COEF+4*ACP*COEFA2)))
     &         +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH1)**2*
     &         (2*ACP*COEFA2/(COEFH1**2+2*COEFH1*COEF)
     &         +2*ACP*COEFA2/(COEFH1**2+2*COEFH1*COEF
     &         +4*ACP*COEFA2)
     &         +LOG((COEFH1**2+2*COEFH1*COEF)/
     &         (COEFH1**2+2*COEFH1*COEF+4*ACP*COEFA2))))/6
     &         -(A12-A23-A1C2+AC23)*
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH2)*
     &         (4*ACP*ACG*COEF3*(1/(COEFH2**2+2*COEFH2*COEF2)**2
     &         +1/(COEFH2**2+2*COEFH2*COEF2+4*ACP*ACG)**2)
     &         -2*COEF3*(1/(COEFH2**2+2*COEFH2*COEF2)
     &         -1/(COEFH2**2+2*COEFH2*COEF2+4*ACP*ACG)))
     &         +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH2)**2*
     &         (2*ACP*ACG/(COEFH2**2+2*COEFH2*COEF2)
     &         +2*ACP*ACG/(COEFH2**2+2*COEFH2*COEF2
     &         +4*ACP*ACG)
     &         +LOG((COEFH2**2+2*COEFH2*COEF2)/
     &         (COEFH2**2+2*COEFH2*COEF2+4*ACP*ACG))))/6
      END IF
      IF (VDWMODE.EQ.4) THEN
          ACP = AP-T1
          ACG = AG
          COEFH1 = H 
          COEFH2 = H+T1
          COEFA1 = ACP+T1
          COEF = ACP+ACG+T1
          COEF2 = ACP+ACG
          COEF3 = H+ACP+ACG+T1
          FVDW = -(AC12-A23-AC13+A33)*
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH1)*
     &         (4*COEFA1*ACG*COEF3*(1/(COEFH1**2+2*COEFH1*COEF)**2
     &         +1/(COEFH1**2+2*COEFH1*COEF+4*COEFA1*ACG)**2)
     &         -2*COEF3*(1/(COEFH1**2+2*COEFH1*COEF)
     &         -1/(COEFH1**2+2*COEFH1*COEF+4*COEFA1*ACG)))
     &         +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH1)**2*
     &         (2*COEFA1*ACG/(COEFH1**2+2*COEFH1*COEF)
     &         +2*COEFA1*ACG/(COEFH1**2+2*COEFH1*COEF
     &         +4*COEFA1*ACG)
     &         +LOG((COEFH1**2+2*COEFH1*COEF)/
     &         (COEFH1**2+2*COEFH1*COEF+4*COEFA1*ACG))))/6
     &         -(A12-AC12-A13+AC13)*
     &         (LAMBDAVDW/(LAMBDAVDW+11.12*COEFH2)*
     &         (4*ACP*ACG*COEF3*(1/(COEFH2**2+2*COEFH2*COEF2)**2
     &         +1/(COEFH2**2+2*COEFH2*COEF2+4*ACP*ACG)**2)
     &         -2*COEF3*(1/(COEFH2**2+2*COEFH2*COEF2)
     &         -1/(COEFH2**2+2*COEFH2*COEF2+4*ACP*ACG)))
     &         +11.12*LAMBDAVDW/(LAMBDAVDW+11.12*COEFH2)**2*
     &         (2*ACP*ACG/(COEFH2**2+2*COEFH2*COEF2)
     &         +2*ACP*ACG/(COEFH2**2+2*COEFH2*COEF2
     &         +4*ACP*ACG)
     &         +LOG((COEFH2**2+2*COEFH2*COEF2)/
     &         (COEFH2**2+2*COEFH2*COEF2+4*ACP*ACG))))/6
      END IF   
      END SUBROUTINE FORCEVDW

C     SUBROUTINE FORCE EDL (N) (SPHERE-SPHERE GEOMETRY) (DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
      SUBROUTINE FORCEEDL (KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                     AG,AP,ASP,NASP,RMODE,H,PI,FEDL)
      DOUBLE PRECISION KAPPA,KB,ERE0,T,ZI,ECHG,ZETAC,ZETAP,
     &                 AG,AP,ASP,NASP,H,H2,PI,FEDL1,FEDL2,FEDL
      DOUBLE PRECISION COEF1,COEF2,J
      INTEGER RMODE
      
      J = 1-(PI/4) !CALCULATE AREA OF SURFACE NOT OCCUPIED BY ASPERITIES USING JAMMING LIMIT FOR CUBIC PACKED SPHERES
      IF (RMODE.EQ.0) THEN !SMOOTH SURFACE ON BOTH (SPHERE-SPHERE GEOMETRY) (DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*AP*AG/(AP+AG)*(KB*T/ZI/ECHG)**2.0
     &            *TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL = COEF1*KAPPA*EXP(-KAPPA*H)
      END IF    
      IF (RMODE.EQ.1) THEN !ASPERITIES ON COLLOID
          H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C         CALCULATE EDL INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-SPHERE DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*AP*AG/(AP+AG)*(KB*T/ZI/ECHG)**2.0
     &            *TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL1 = COEF1*KAPPA*EXP(-KAPPA*H2)
C         CALCULATE EDL INTERACITON BETWEEN ASPERTIES AND COLLECTOR (SPHERE-SPHERE) 
          COEF2 = 64.0*PI*ERE0*ASP*AG/(ASP+AG)*(KB*T/ZI/ECHG)**2.0
     &            *TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
		  IF (H.LE.ASP) THEN 
			 FEDL2 = COEF2*KAPPA*EXP(-KAPPA*H)
		  ELSE
			 FEDL2 = 0.0
		  END IF	              
C         CALCULATE TOTAL INTERACTION (MULTIPLY OFFSET SMOOTH SURFACE BY 1-JAMMING LIMIT OF SURFACE COVERED BY ASPERITIES)
          FEDL = J*FEDL1 + NASP*FEDL2 
      END IF
      IF (RMODE.EQ.2) THEN !ASPERITIES ON COLLECTOR
          H2 = H + ASP !SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID
C         CALCULATE EDL INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-SPHERE DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*AP*AG/(AP+AG)*(KB*T/ZI/ECHG)**2.0
     &            *TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL1 = COEF1*KAPPA*EXP(-KAPPA*H2)
C         CALCULATE EDL INTERACITON BETWEEN ASPERTIES AND COLLOID (SPHERE-SPHERE) 
          COEF2 = 64.0*PI*ERE0*ASP*AP/(ASP+AP)*(KB*T/ZI/ECHG)**2.0*
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T) 
		  IF (H.LE.ASP) THEN 
			 FEDL2 = COEF2*KAPPA*EXP(-KAPPA*H)
		  ELSE
			 FEDL2 = 0.0
		  END IF
C         CALCULATE TOTAL INTERACTION (MULTIPLY OFFSET SMOOTH SURFACE BY 1-JAMMING LIMIT OF SURFACE COVERED BY ASPERITIES)
          FEDL = J*FEDL1 + NASP*FEDL2 
      END IF
      IF (RMODE.EQ.3) THEN  !ASPERITIES ON BOTH SURFACES 
          H2 = H+0.5*(2*ASP+3**0.5*ASP) !AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH COLLECTOR AND COLLOID FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
C         CALCULATE EDL INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-SPHERE (DERIVED FROM ENERGY GIVEN BY LIN & WIESNER 2012)
          COEF1 = 64.0*PI*ERE0*AP*AG/(AP+AG)*(KB*T/ZI/ECHG)**2.0
     &            *TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T)
          FEDL1 = COEF1*KAPPA*EXP(-KAPPA*H2)
C         CALCULATE EDL INTERACTION BETWEEN ASPERITIES (SPHERE-SPHERE JUSTIFIED BY LINEAR APPROXIMATION)
          COEF2 = 64.0*PI*ERE0*ASP*ASP/(ASP+ASP)*(KB*T/ZI/ECHG)**2.0*
     &            TANH(ZI*ECHG*ZETAC/4/KB/T)*TANH(ZI*ECHG*ZETAP/4/KB/T) 
		  IF (H.LE.ASP) THEN 
			 FEDL2 = COEF2*KAPPA*EXP(-KAPPA*H)
		  ELSE
			 FEDL2 = 0.0
		  END IF
C         CALCULATE TOTAL INTERACTION (MULTIPLY OFFSET SMOOTH SURFACE BY 1-JAMMING LIMIT OF SURFACE COVERED BY ASPERITIES)          
          FEDL = J*FEDL1 + 2.5*NASP*FEDL2 
      END IF
      IF (ABS(FEDL).LT.1.0E-30) THEN
          FEDL = 0.0
      ENDIF
      END SUBROUTINE FORCEEDL

C     SUBROUTINE LEWIS ACID-BASE FORCE (N) (DERIVED FROM WOOD & REHMANN 2014)
      SUBROUTINE FORCEAB (PI,AG,AP,ASP,NASPAB,RMODE,LAMBDAAB,
     &                                GAMMA0AB,H,H0,FAB)
      DOUBLE PRECISION PI,AG,AP,LAMBDAAB,GAMMA0AB,H,H0,FAB
      DOUBLE PRECISION AEFF,LOWGEO,HIGHGEO,ASP,NASPAB,COEFF,FAB1
      INTEGER RMODE
      
      IF (RMODE.EQ.0) THEN !SMOOTH COLLOID AND COLLECTOR
C         CALCULATE THE EFFECTIVE RADIUS USING COLLOID AND COLLECTOR RADIUS
          AEFF = 2*(AP*AG)/(AP+AG)
C         LOWER BOUND ON GEOMETRIC CORRECTION - SPHERE-PLATE APPROXIMATION USING EFFECTIVE RADIUS
          LOWGEO = 1-LAMBDAAB/AEFF+(1+LAMBDAAB/AEFF)*
     &                EXP(-2*AEFF/LAMBDAAB)
C         UPPER BOUND ON GEOMETRIC CORRECTION - SAME SIZE SPHERE-SPHERE APPROXIMATION USING EFFECTIVE RADIUS
          HIGHGEO = 1-LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0)-
     &      (4*AEFF/(3*LAMBDAAB))*EXP(-2*AEFF/LAMBDAAB)-
     &      (1+LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0))*
     &      EXP(-4*AEFF/LAMBDAAB)
C         GEOMETRIC CORRECTION FOR SPHERE-SPHERE
          COEFF = ((1-AP/AG)*LOWGEO+AP/AG*HIGHGEO)
C         CALCULATE AB INTERACTION BETWEEN COLLOID AND COLLECTOR (SPHERE-SPHERE)
          FAB = COEFF*PI*AEFF*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)
      END IF
      IF (RMODE.EQ.1) THEN !ASPERITIES ON COLLOID
C         CALCULATE THE EFFECTIVE RADIUS USING ASPERITY AND COLLECTOR RADIUS
          AEFF = 2*(ASP*AG)/(ASP+AG)
C         LOWER BOUND ON GEOMETRIC CORRECTION - SPHERE-PLATE APPROXIMATION USING EFFECTIVE RADIUS
          LOWGEO = 1-LAMBDAAB/AEFF+(1+LAMBDAAB/AEFF)*
     &                EXP(-2*AEFF/LAMBDAAB)
C         UPPER BOUND ON GEOMETRIC CORRECTION - SAME SIZE SPHERE-SPHERE APPROXIMATION USING EFFECTIVE RADIUS
          HIGHGEO = 1-LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0)-
     &      (4*AEFF/(3*LAMBDAAB))*EXP(-2*AEFF/LAMBDAAB)-
     &      (1+LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0))*
     &      EXP(-4*AEFF/LAMBDAAB)
C         GEOMETRIC CORRECTION FOR SPHERE-SPHERE
          COEFF = ((1-ASP/AG)*LOWGEO+ASP/AG*HIGHGEO)
C         CALCULATE AB INTERACTION BETWEEN ASPERITIES AND COLLOID (SPHERE-SPHERE)
		  IF (H.LE.ASP) THEN 
			 FAB1 = COEFF*PI*AEFF*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)
		  ELSE
			 FAB1 = 0.0
		  END IF
C         CALCULATE TOTAL INTERACTION
          FAB = NASPAB*FAB1
      END IF
      IF (RMODE.EQ.2) THEN !ASPERITIES ON COLLECTOR
C         CALCULATE THE EFFECTIVE RADIUS USING ASPERITY AND COLLOID RADIUS
          AEFF = 2*(ASP*AP)/(ASP+AP)
C         LOWER BOUND ON GEOMETRIC CORRECTION - SPHERE-PLATE APPROXIMATION USING EFFECTIVE RADIUS
          LOWGEO = 1-LAMBDAAB/AEFF+(1+LAMBDAAB/AEFF)*
     &                EXP(-2*AEFF/LAMBDAAB)
C         UPPER BOUND ON GEOMETRIC CORRECTION - SAME SIZE SPHERE-SPHERE APPROXIMATION USING EFFECTIVE RADIUS
          HIGHGEO = 1-LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0)-
     &      (4*AEFF/(3*LAMBDAAB))*EXP(-2*AEFF/LAMBDAAB)-
     &      (1+LAMBDAAB/AEFF+LAMBDAAB**2.0/(2*AEFF**2.0))*
     &      EXP(-4*AEFF/LAMBDAAB)
C         GEOMETRIC CORRECTION FOR SPHERE-SPHERE
          COEFF = ((1-ASP/AP)*LOWGEO+ASP/AP*HIGHGEO)
C         CALCULATE AB INTERACTION BETWEEN ASPERITIES AND COLLOID (SPHERE-SPHERE)
		  IF (H.LE.ASP) THEN 
			 FAB1 = COEFF*PI*AEFF*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)
		  ELSE
			 FAB1 = 0.0
		  END IF
C         CALCULATE TOTAL INTERACTION
          FAB = NASPAB*FAB1
      END IF
      IF (RMODE.EQ.3) THEN  !ASPERITIES ON BOTH SURFACES
C         GEOMETRIC CORRECTION FOR SAME SIZE SPHERE
          COEFF = 1-LAMBDAAB/ASP+LAMBDAAB**2.0/(2*ASP**2.0)-
     &      (4*ASP/(3*LAMBDAAB))*EXP(-2*ASP/LAMBDAAB)-
     &      (1+LAMBDAAB/ASP+LAMBDAAB**2.0/(2*ASP**2.0))*
     &      EXP(-4*ASP/LAMBDAAB)
C         CALCULATE AB INTERACTION BETWEEN ASPERITIES (SAME SIZE SPHERE-SPHERE)
		  IF (H.LE.ASP) THEN 
			 FAB1 = COEFF*PI*ASP*GAMMA0AB*EXP(-(H-H0)/LAMBDAAB)
		  ELSE
			 FAB1 = 0.0
		  END IF
C         CALCULATE TOTAL INTERACTION
          FAB = 2.5*NASPAB*FAB1
      END IF
      END SUBROUTINE FORCEAB

C     SUBROUTINE BORN FORCE (N) (DERIVED FROM ENERGY GIVEN BY RUCKENSTEIN & PRIEVE 1976)
      SUBROUTINE FORCEBORN (A132,SIGMAC,AP,H,FBORN,A11,
     &                     A22,A33,AC1C1,AC2C2,VDWMODE)
      INTEGER VDWMODE
      DOUBLE PRECISION A132,SIGMAC,AP,H,FBORN
      DOUBLE PRECISION A11,A22,A33,AC1C1,AC2C2
      DOUBLE PRECISION A1C2,A13,AC12,AC1C2,
     &                 AC13,A23,AC23
   
      A1C2 = (A11**0.5)*(AC2C2**0.5) 
      A13 = (A11**0.5)*(A33**0.5)
      AC12 = (AC1C1**0.5)*(A22**0.5)
      AC1C2 = (AC1C1**0.5)*(AC2C2**0.5)
      AC13 = (AC1C1**0.5)*(A33**0.5)
      A23 = (A22**0.5)*(A33**0.5)
      AC23 = (AC2C2**0.5)*(A33**0.5)
      IF (VDWMODE.EQ.1) THEN
          FBORN = (A132*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      IF (VDWMODE.EQ.2) THEN
          FBORN = ((AC1C2-AC23-AC13+A33)*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      IF (VDWMODE.EQ.3) THEN
          FBORN = ((A1C2-AC23-A13+A33)*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      IF (VDWMODE.EQ.4) THEN
          FBORN = ((AC12-A23-AC13+A33)*SIGMAC**6/1260)*
     &        ((7*AP-H)/H**8+(9*AP+H)/(2*AP+H)**8)
      END IF
      END SUBROUTINE FORCEBORN

C     SUBROUTINE STERIC FORCE
      SUBROUTINE FORCESTE (PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE)
      DOUBLE PRECISION PI,GAMMA0STE,LAMBDASTE,ASTE,H,FSTE
      
      FSTE = GAMMA0STE/LAMBDASTE*EXP(-H/LAMBDASTE)*PI*ASTE**2
      END SUBROUTINE FORCESTE     
      
C     SUBROUTINE DRIVING DRAG FORCE
      SUBROUTINE FORCEDRAG (FUN2,FUN3,FUN4,M3,VN,VT,FDRGT,FDRGN)
      DOUBLE PRECISION FUN2,FUN3,FUN4,M3,VT,VN,FDRGT,FDRGN
      
C	CALCULATE DRAG FORCES (TANGENTIAL AND NORMAL)
	FDRGT = FUN3/FUN4*M3*VT
      FDRGN = FUN2*M3*VN
      END SUBROUTINE FORCEDRAG      
      
C     SUBROUTINE DIFFUSION FORCE
      SUBROUTINE FORCEDIFF(DIFFSCALE,PI,VISC,AP,KB,T,dT,
     &                       FDIFX,FDIFY,FDIFZ)
      DOUBLE PRECISION DIFFSCALE,PI,VISC,AP,KB,T,dT,
     &                FDIFX,FDIFY,FDIFZ,rsign1,rnum1,rsign2,rnum2,
     &                rsign3,rnum3,bigni,ni
      INTEGER nrand
      
C     CALL SUBROUTINE generate_unif WHICH USES SEED TO GENERATE TWO RANDOM NUMBERS IN 
C     THE RANGE 0 TO 1 (UNIFORM DISTRIBUTION) AND WHICH GENERATES NEW SEED
      CALL generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &                   nrand)
C     ONLY POSITIVE DOMAIN LOWER LIMIT = 0.5 UPPER LIMIT FOR  + 2*STDEV= 0.9771 , SPAN = 0.4771
      rnum1 = rnum1 * 0.4771+ 0.5
      rnum2 = rnum2 * 0.4771+ 0.5
      rnum3 = rnum3 * 0.4771+ 0.5
C     CONVERT UNIFORM DISTRIBUTION TO GAUSSIAN DISTRIBUTION WITH ZERO MEAN AND VARIANCE OF UNITY   
      
      bigni = rnum1
      CALL calc_ni(bigni,ni)
      randm1 = ni*rsign1
C
      bigni = rnum2
      CALL calc_ni(bigni,ni)
      randm2 = ni*rsign2
C
      bigni = rnum3   
      CALL calc_ni(bigni,ni)
      randm3 = ni*rsign3
      
C     KIM AND ZYDNEY (2004) INDICATE FORMULAS USED ABOVE APPLY TO Z AND R AND ARE ADDITIVE 
	FDIFZ = DIFFSCALE*(randm1)*((12.0*PI*AP*VISC*KB*T/(dT))**0.5)
C     DIFFUSION APPLIED IN 3DIMENSIONS
	FDIFX = DIFFSCALE*(randm2)*((12.0*PI*AP*VISC*KB*T/(dT))**0.5)
	FDIFY = DIFFSCALE*(randm3)*((12.0*PI*AP*VISC*KB*T/(dT))**0.5)
      END SUBROUTINE FORCEDIFF

C     SUBROUTINE GRAVITY
C     GRAVITATIONAL FORCE - GRAVFACT IS A FACTOR OF GRAVITY ACCELERATION
      SUBROUTINE GRAVITY(GRAVFACT,AP,G,RHOP,RHOW,PI,FG)
      DOUBLE PRECISION GRAVFACT,AP,G,RHOP,RHOW,PI,FG
      FG = GRAVFACT*(4.0/3.0)*(PI)*(AP**3)*(RHOP-RHOW)*G
      END SUBROUTINE GRAVITY 
	  
C     SUBROUTINE GRAVVECT
C     GRAVTIY VECTOR PROJECTIONS ON NORMAL AND TANGENTIAL 	  
      SUBROUTINE GRAVVECT (FG,EGX,EGY,EGZ,ENX,ENY,ENZ,ETX,ETY,ETZ,
     &						FGN,FGT,FGNX,FGNY,FGNZ,FGTX,FGTY,FGTZ)
	  DOUBLE PRECISION FG,EGX,EGY,EGZ,ENX,ENY,ENZ,ETX,ETY,ETZ
	  DOUBLE PRECISION FGN,FGT,FGNX,FGNY,FGNZ,FGTX,FGTY,FGTZ,PGN,PGT
	  ! calculates projection of gravity vector un normal and tangential
	  ! directions
	  ! calculate projection on normal and tangential
		PGN = EGX*ENX+EGY*ENY+EGZ*ENZ;
		PGT = EGX*ETX+EGY*ETY+EGZ*ETZ;
		! calculate FG vector in normal and tangential
		FGN = PGN*FG;
		FGT = PGT*FG;
		! calculate components
		! NORMAL
		FGNX = ENX*FGN;
		FGNY = ENY*FGN;
		FGNZ = ENZ*FGN;
		! TANGENTIAL
		FGTX = ETX*FGT;
		FGTY = ETY*FGT;
		FGTZ = ETZ*FGT;
		! FGX = FG*EGX;
		! FGY = FG*EGY;
		! FGZ = FG*EGZ;
	  END SUBROUTINE GRAVVECT 

C     LIFT FORCE SUBROUTINE (NORMALIZED TO THE CLOSTEST SURFACE)
      SUBROUTINE FORCELIFT (RHOW,R,AP,AG,VT,UT,OMEGA,FLIFT)
      DOUBLE PRECISION RHOW,R,AP,AG,VT,UT,OMEGA,FLIFT
      DOUBLE PRECISION KS,LNZAP,LS,LR,LT,LRT,LSR,LST
      
C     (Yahiaoui&Feuillebois2010)
C     CONSIDER LIFT FORCE IF PARTICLE IS WITHIN 100 RADII OF THE SURFACE
      IF ((R-AG).LE.(100.0*AP)) THEN
          KS = VT/(R-AG)                                                !SHEAR RATE  
          LNZAP = LOG((R-AG)/AP)
          LS = EXP(2.221+1.565*LNZAP+0.06602*LNZAP**2.0)                !LIFT FORCE ON FIXED SPHERE IN LINEAR SHEAR FLOW
          LR = EXP(-1.0*(0.6390+1.408*LNZAP)/                           !LIFT FORCE ON ROTATING SPHERE IN FLUID AT REST
     &            (1.0-0.1036*LNZAP+0.01136*LNZAP**2.0))
          LT = (1.751+6.147*LNZAP+3.299*LNZAP**2.0-2.485*LNZAP**3.0+    !LIFT FORCE ON TRANSLATING SPHERE IN FLUID AT REST
     &            1.952*LNZAP**4.0)/(1.0+3.714*LNZAP+1.481*LNZAP**2.0-
     &            1.278*LNZAP**3.0+1.0905*LNZAP**4.0)
          LRT = -LNZAP*(10.97+439.4*LNZAP+355.0*LNZAP**2.0+             !LIFT FORCE COUPLING TERM FOR ROTATING AND TRANSLATING SPHERE IN FLUID AT REST
     &            171.6*LNZAP**3.0)/(1.0+7.309*LNZAP+284.7*LNZAP**2.0+
     &            86.45*LNZAP**3.0+77.45*LNZAP**4.0)
          LSR = EXP((-4.723-11.11*LNZAP+41.76*LNZAP**2.0)/              !LIFT FORCE COUPLING TERM FOR ROTATING SPHERE IN LINEAR SHEAR FLOW
     &            (1.0+20.31*LNZAP))
          LST = (-10.76-2.158*LNZAP-4.218*LNZAP**2.0)/(1.0-0.1749*LNZAP)!LIFT FORCE COUPLING TERM FOR TRANSLATING SPHERE IN LINEAR SHEAR FLOW
          
          FLIFT = RHOW*AP**2.0*((AP*KS)**2.0*LS+(AP*OMEGA)**2.0*LR+
     &            (UT)**2.0*LT+(AP*OMEGA*UT)*LRT+
     &            (AP**2.0*OMEGA*KS)*LSR+(AP*KS*UT)*LST)
      ELSE
          FLIFT = 0.0
      ENDIF
      END SUBROUTINE FORCELIFT
      
C     SUBROUTINE TO OBTAIN INITIAL PARTICLE LOCATIONS
      SUBROUTINE INITIAL (RLIM,AG,AP,ASP,RMODE,RB,XINIT,YINIT,RINJ,
     &                        ZINIT,RINIT,HINIT)
      DOUBLE PRECISION RLIM,AG,AP,ASP,RB,XINIT,YINIT,RINJ,ZINIT,
     &                        RINIT,HINIT
      DOUBLE PRECISION rsign1,rnum1,rsign2,rnum2,rsign3,rnum3
      INTEGER  nrand,RMODE
      
      RINJ = 2.0*RLIM !INITIALIZE VALUE TO EXECUTE DO WHILE LOOP
      DO WHILE (RINJ.GT.RLIM)
C         CALL RANDOM NUMBER FOR LOCATIONS
          CALL generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &                        nrand)
          XINIT = (rsign1 * rnum1)*RLIM  
          YINIT = (rsign2 * rnum2)*RLIM
          RINJ = (XINIT**2.0 + YINIT**2.0)**0.5
      END DO 
C     PROJECT INJECTION PLANE COORDINATES TO FLUID SHELL ENVELOPE
      RINIT = RB
      ZINIT = (RINIT*RINIT-XINIT*XINIT-YINIT*YINIT)**0.5
      IF (RMODE.EQ.0) THEN !SMOOTH-SMOOTH INTERACTION
          HINIT = RINIT - AG - AP
      ELSE IF ((RMODE.EQ.1).OR.(RMODE.EQ.2)) THEN !SMOOTH-ROUGH INTERACTION
          HINIT = RINIT - AG - AP - ASP
      ELSE IF (RMODE.EQ.3) THEN !ROUGH-ROUGH INTERACTION
          HINIT = RINIT - AG - AP - 0.5*(2*ASP+3**0.5*ASP) !THIRD TERM IS AVERAGE SEPARATION DISTANCE BETWEEN UNDERLYING SMOOTH SURFACES FOR OPPOSED AND COMPLIMENTARY ASPERITY PACKING
      END IF
      END SUBROUTINE INITIAL 

C     SUBROUTINE HAPPEL REVISED REAL COORDINATES INPUT
C     FLOW FIELD IS FROM POSITIVE Z TO NEGATIVE Z
      SUBROUTINE HAPPELFF (X,Y,Z,AG,B,K1,K2,K3,K4,VxH1,VyH1,VzH1)
	IMPLICIT NONE
	DOUBLE PRECISION, INTENT(IN):: X,Y,Z,AG,B,K1,K2,K3,K4
	DOUBLE PRECISION, INTENT(OUT):: VxH1,VyH1,VzH1
	DOUBLE PRECISION RO,RDIS,RDISSLIP,ROXY,FT,FN
      
      RO = (X**2+Y**2+Z**2)**0.5      !REAL UNITS
      RDIS = RO/AG                    !DIMENSIONLESS
      RDISSLIP = (RO+B)/AG            !DIMENSIONLESS INCLUDING SLIP LENGTH
      ROXY = (X**2+Y**2)**0.5         !REAL UNITS   
      FT = (-K1/(2.0*RDISSLIP**3.0)+K2/(2.0*RDISSLIP)
     & +K3+2.0*K4*RDISSLIP**2.0)
      FN = K1/RDIS**3.0+K2/RDIS+K3+K4*RDIS**2.0
C     Obtain velocity components via differentiating streamline functions (REVISED DERIVATION)
C     Velocity components are dimensionless
      VxH1 = (X*Z/RO**2)*(-FN+FT)
	VyH1 = (Y*Z/RO**2)*(-FN+FT)
	VzH1 = ((Z/RO)**2)*(-FN)+((ROXY/RO)**2.0)*(-FT)    
      END SUBROUTINE HAPPELFF

C     SUBROUTINE HETTRACK COLLECTOR   
      SUBROUTINE HETTRACK(X,Y,Z,Xm0,Ym0,Zm0,AG,RZOI,HETMODE,SCOV,
     &                    RHET0,RHET1,RHET2,XHET,YHET,ZHET,RHET)
      DIMENSION XHET(100),YHET(100),ZHET(100)
      DIMENSION RHET(100),THETAT(100),PHIT(100)
      DOUBLE PRECISION XHET,YHET,ZHET,RHET,THETAT,PHIT
      DOUBLE PRECISION X,Y,Z,Xm0,Ym0,Zm0
      DOUBLE PRECISION NHETREAL0
      DOUBLE PRECISION RO,R1,AG,RZOI,SCOV,SCOV0,RHET0,RHET1,RHET2
      DOUBLE PRECISION RRING,ROXY
      DOUBLE PRECISION THETA,THETAP,THETA1,THETA2,DTHETA,DTHETA1,DTHETA2
      DOUBLE PRECISION PHI,PHIP,PHI1,PHI2,DPHI1,DPHI2
      DOUBLE PRECISION ARCL
      DOUBLE PRECISION PI,HM1,HM2
      DOUBLE PRECISION NRINGREAL,NHRINGREAL
C
      INTEGER NHET,HETMODE,HMODEREAL,NRING,NHETRING,NTHETA,NPHI,N,M,J
      DATA PI/3.14159265359/

C     SET NUMNER OF HETERODOMAINS PER TILE
      HETMODE = HETMODE
      HMODEREAL = HETMODE
C     EQUIVALENT SURFACE COVERAGE CORRESPONDING TO UNIFORM HETERODOMAINS IS USED IN CALCULATION, EQUALS HALF OF BIMODAL SURFACE COVERAGE
      IF (HETMODE.EQ.1) THEN
          HM1 = 0.0
          HM2 = 0.0
      ELSEIF (HETMODE.EQ.5) THEN
          HM1 = 4.0
          HM2 = 0.0
      ELSEIF (HETMODE.EQ.9) THEN
          HM1 = 8.0
          HM2 = 0.0
      ELSEIF (HETMODE.EQ.73) THEN
          HM1 = 8.0
          HM2 = 64.0
      END IF
      SCOV0 = SCOV*(RHET0**2)/(RHET0**2+HM1*RHET1**2+HM2*RHET2**2)
      
C     CALCULATE APPROXIMATE NUMBER OF HETERODOMAINS REQUIRED
C     ACTUAL SURFACE COVERAGE HAS TO BE CALCULATED IN HETSAMEARC
C     AFTER ALL HETERODOMAINS ARE EXPLICITLY GENERATED
C     APPROXIMATION IS GOOD TO WITHIN 5% OR BETTER
      NHET0 = NINT(SCOV0*(4.0*AG**2.0)/(RHET0**2.0))
      NHET1 = HM1*NHET0
      NHET2 = HM2*NHET0
      
C     CALCULATE NUMBER OF RINGS THAT YIELD NHET ASSUMING EVEN SPACING 
      NHETREAL0 = NHET0
C     THE DENOMINATOR 1/1.2 WAS CALIBRATED TO YIELD EVEN SPACING DISTRIBUTION OF HETDOMAINS MATCING SCOV
      NRING = NINT((NHETREAL0/1.3)**0.5)
      NRINGREAL = NRING
      
C     SPHERICAL COORDINATES: RADIUS, THETA (POLAR ANGLE), PHI (AZIMUTHAL ANGLE)
C     AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
C     CALCULATE THETA ANGLE STEP AND CONSTANT ARC LENGTH
      DTHETA =  PI/(NRINGREAL-1.0)
      ARCL = DTHETA*AG  
      
C     CALCULATE COLLOID RADIAL DISTANCE AND SEPARATION DISTANCE
      RO = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0)+(Z-Zm0)*(Z-Zm0))**0.5
      
C     CALCULATE COLLOID THETA ANGLE
      THETAP = DACOS((Z-Zm0)/RO)
C     CALCULATE PROJECTION OF COLLOID POSITION ON XY PLANE
      ROXY = ((X-Xm0)*(X-Xm0)+(Y-Ym0)*(Y-Ym0))**0.5
C     CALCULATE COLLOID PHI ANGLE
      IF (ROXY.EQ.0.0) THEN
        PHIP = 0.0
      ELSE
        IF ((Y-Ym0).GE.0.0) THEN
            PHIP = DACOS((X-Xm0)/ROXY)
        ELSE
            PHIP = 2.0*PI-DACOS((X-Xm0)/ROXY)
        ENDIF
      END IF
C     NTHETAP IS CLOSEST RING TO COLLOID PROJECTION
      NTHETAP = NINT(THETAP/DTHETA)+1
      
C     AT POLES
      IF ((NTHETAP.EQ.1).OR.(NTHETAP.EQ.NRING)) THEN 
        DTHETA1 = 1.0/3.0*DTHETA
        DPHI = 0.0
        RRING = 0.0
        IF (NTHETAP.EQ.1) THEN 
            THETA = 0
        ELSEIF (NTHETAP.EQ.NRING) THEN
            THETA = PI
        END IF
C       POPULATE HETDOMAINS AT POLE
        DO J=1,HETMODE
            IF (J.EQ.1) THEN !GENERATE LARGE HETDOMAIN
                PHI = 0
                R1 = RRING
                XHET(J) = R1*DCOS(PHI)+Xm0
                YHET(J) = R1*DSIN(PHI)+Ym0
                ZHET(J) = AG*DCOS(THETA)+Zm0  
                RHET(J) = RHET0
                THETAT(J) = THETA
                PHIT(J) = PHI
            ELSE !GENERATE MEDIUM AND SMALL HETDOMAINS AROUND LARGE HETERODOMAIN
                IF (HETMODE.EQ.5) THEN !1:4
                    THETA1 = THETA + DTHETA1  
                    PHI = (J-2)*PI/2.0
                    R1 = AG*DSIN(THETA1)
                    XHET(J) = R1*DCOS(PHI)+Xm0
                    YHET(J) = R1*DSIN(PHI)+Ym0
                    ZHET(J) = AG*DCOS(THETA1)+Zm0
                    RHET(J) = RHET1
                    THETAT(J) = THETA1
                    PHIT(J) = PHI
                ELSEIF (HETMODE.EQ.9) THEN !1:8
                    THETA1 = THETA + DTHETA1
                    R1 = AG*DSIN(THETA1)
                    PHI = (J-2)*PI/4.0
                    XHET(J) = R1*DCOS(PHI)+Xm0
                    YHET(J) = R1*DSIN(PHI)+Ym0
                    ZHET(J) = AG*DCOS(THETA1)+Zm0
                    RHET(J) = RHET1
                    THETAT(J) = THETA1
                    PHIT(J) = PHI
                ELSEIF (HETMODE.EQ.73) THEN !1:8:64
                    IF (J.GE.2.AND.J.LE.9) THEN
                        THETA1 = THETA + DTHETA1
                        R1 = AG*DSIN(THETA1)
                        PHI = (J-2)*PI/4.0
                        XHET(J) = R1*DCOS(PHI)+Xm0
                        YHET(J) = R1*DSIN(PHI)+Ym0
                        ZHET(J) = AG*DCOS(THETA1)+Zm0
                        RHET(J) = RHET1
                        THETAT(J) = THETA1
                        PHIT(J) = PHI
                    ELSEIF (J.GE.10.AND.J.LE.17) THEN
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                                 1.155*SIN(2.094*(J-9)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (2-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                                1.115*SIN(0.5236*(J-9)+3.927)
     &                               +0.2989*SIN(3.665*(J-9)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.18.AND.J.LE.25) THEN
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(J-17)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (3-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                            1.115*SIN(0.5236*(J-17)+3.927)
     &                           +0.2989*SIN(3.665*(J-17)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.26.AND.J.LE.33) THEN
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(J-25)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (4-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                            1.115*SIN(0.5236*(J-25)+3.927)
     &                           +0.2989*SIN(3.665*(J-25)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.34.AND.J.LE.41) THEN
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(J-33)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (5-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                            1.115*SIN(0.5236*(J-33)+3.927)
     &                           +0.2989*SIN(3.665*(J-33)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.42.AND.J.LE.49) THEN
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(J-41)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (6-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                            1.115*SIN(0.5236*(J-41)+3.927)
     &                           +0.2989*SIN(3.665*(J-41)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.50.AND.J.LE.57) THEN
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(J-49)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (7-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                            1.115*SIN(0.5236*(J-49)+3.927)
     &                           +0.2989*SIN(3.665*(J-49)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.58.AND.J.LE.65) THEN
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(J-57)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (8-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                            1.115*SIN(0.5236*(J-57)+3.927)
     &                           +0.2989*SIN(3.665*(J-57)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.66.AND.J.LE.73) THEN 
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(J-65)+3.142))
                        THETA2 = THETA1 + F_THETA1*DTHETA2
                        PHI = (9-2)*PI/4.0
                        DPHI1 = 1.0/3.0*(PI/4.0)
                        F_PHI = NINT(
     &                            1.115*SIN(0.5236*(J-65)+3.927)
     &                           +0.2989*SIN(3.665*(J-65)-7.069))
                        PHI1 = PHI + F_PHI*DPHI1
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI1
                    ENDIF
                ENDIF   
            END IF                      
        END DO
      ELSE 
C       NOT AT POLES 
C       THETA ANGLE       
        THETA = (NTHETAP-1)*DTHETA
C       CALCULATE RING RADIUS
        RRING = AG*DSIN(THETA)
C       CALCULATE NUMBER OF HETERODOMAINS IN RING
        NHETRING = NINT(2.0*PI*RRING/ARCL)
        IF (NHETRING.LT.3) THEN
            NHETRING = 3
        ENDIF
        NHRINGREAL = NHETRING
C       RECALCULATE STEP IN PHI BASED ON NHETRING
        DPHI = 2.0*PI/NHRINGREAL
C       CALCULATE OFFSET AS 10% OF THE STEP IN PHI IF RING IS ODD OR EVEN
        M = MOD(NTHETAP,2)
        IF (M.EQ.0) THEN
            PHIOFF = 0.1*DPHI 
        ELSE
            PHIOFF = -0.1*DPHI 
        ENDIF
C       CALCULATE PHI ANGLE BASED ON COLLOID PHI ANGLE
        PHI = DPHI*NINT((PHIP-PHIOFF)/DPHI)+PHIOFF
C       FORTRAN DOES NOT RECOGNIZE ANGLE VALUES GT.2.0*PI RADIANS
        IF (PHI.GT.(2.0*PI)) THEN 
            PHI = 2.0*PI*((PHI)/(2.0*PI)-INT(PHI/(2.0*PI)))
        ENDIF
        DO J=1,HETMODE
            IF (J.EQ.1) THEN !GENERATE LARGE HETDOMAIN
                XHET(J) = RRING*DCOS(PHI)+Xm0
                YHET(J) = RRING*DSIN(PHI)+Ym0
                ZHET(J) = AG*DCOS(THETA)+Zm0  
                RHET(J) = RHET0
                THETAT(J) = THETA
                PHIT(J) = PHI
            ELSE !GENERATE MEDIUM AND SMALL HETDOMAINS AROUND LARGE HETERODOMAIN 
                IF (HETMODE.EQ.5) THEN !1:4
                    DTHETA1 = 1.0/3.0*DTHETA
                    DPHI1 = 1.0/3.0*DPHI
                    IF (J.EQ.2) THEN
                        PHI1 = PHI-DPHI1
                        THETA1 = THETA+DTHETA1
                    ENDIF
                    IF (J.EQ.3) THEN
                        PHI1 = PHI+DPHI1
                        THETA1 = THETA+DTHETA1
                    ENDIF
                    IF (J.EQ.4) THEN
                        PHI1 = PHI+DPHI1
                        THETA1 = THETA-DTHETA1
                    ENDIF
                    IF (J.EQ.5) THEN
                        PHI1 = PHI-DPHI1
                        THETA1 = THETA-DTHETA1
                    ENDIF
                    R1 = AG*DSIN(THETA1)
                    XHET(J) = R1*DCOS(PHI1)+Xm0
                    YHET(J) = R1*DSIN(PHI1)+Ym0
                    ZHET(J) = AG*DCOS(THETA1)+Zm0
                    RHET(J) = RHET1
                    THETAT(J) = THETA1
                    PHIT(J) = PHI1
                ELSEIF (HETMODE.EQ.9) THEN !1:8
                    DTHETA1 = 1.0/3.0*DTHETA
                    F_THETA1 = NINT(
     &                         1.155*SIN(2.094*(J-1)+3.142))
                    THETA1 = THETA + F_THETA1*DTHETA1
                    DPHI1 = 1.0/3.0*DPHI
                    F_PHI1 = NINT(
     &                       1.115*SIN(0.5236*(J-1)+3.927)
     &                       +0.2989*SIN(3.665*(J-1)-7.069))
                    PHI1 = PHI + F_PHI1*DPHI1
                    R1 = AG*DSIN(THETA1)
                    XHET(J) = R1*DCOS(PHI1)+Xm0
                    YHET(J) = R1*DSIN(PHI1)+Ym0
                    ZHET(J) = AG*DCOS(THETA1)+Zm0
                    RHET(J) = RHET1
                    THETAT(J) = THETA1
                    PHIT(J) = PHI1
                ELSEIF (HETMODE.EQ.73) THEN !1:8:64
                    IF (J.GE.2.AND.J.LE.9) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                             1.155*SIN(2.094*(J-1)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(J-1)+3.927)
     &                           +0.2989*SIN(3.665*(J-1)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        R1 = AG*DSIN(THETA1)
                        XHET(J) = R1*DCOS(PHI1)+Xm0
                        YHET(J) = R1*DSIN(PHI1)+Ym0
                        ZHET(J) = AG*DCOS(THETA1)+Zm0
                        RHET(J) = RHET1
                        THETAT(J) = THETA1
                        PHIT(J) = PHI1
                    ELSEIF (J.GE.10.AND.J.LE.17) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(1)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-9)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(1)+3.927)
     &                           +0.2989*SIN(3.665*(1)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-9)+3.927)
     &                           +0.2989*SIN(3.665*(J-9)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ELSEIF (J.GE.18.AND.J.LE.25) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(2)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-17)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(2)+3.927)
     &                           +0.2989*SIN(3.665*(2)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-17)+3.927)
     &                           +0.2989*SIN(3.665*(J-17)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ELSEIF (J.GE.26.AND.J.LE.33) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(3)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-25)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(3)+3.927)
     &                           +0.2989*SIN(3.665*(3)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-25)+3.927)
     &                           +0.2989*SIN(3.665*(J-25)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ELSEIF (J.GE.34.AND.J.LE.41) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(4)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-33)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(4)+3.927)
     &                           +0.2989*SIN(3.665*(4)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-33)+3.927)
     &                           +0.2989*SIN(3.665*(J-33)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ELSEIF (J.GE.42.AND.J.LE.49) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(5)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-41)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(5)+3.927)
     &                           +0.2989*SIN(3.665*(5)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-41)+3.927)
     &                           +0.2989*SIN(3.665*(J-41)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ELSEIF (J.GE.50.AND.J.LE.57) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(6)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-49)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(6)+3.927)
     &                           +0.2989*SIN(3.665*(6)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-49)+3.927)
     &                           +0.2989*SIN(3.665*(J-49)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ELSEIF (J.GE.58.AND.J.LE.65) THEN
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(7)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-57)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(7)+3.927)
     &                           +0.2989*SIN(3.665*(7)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-57)+3.927)
     &                           +0.2989*SIN(3.665*(J-57)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ELSEIF (J.GE.66.AND.J.LE.73) THEN 
                        DTHETA1 = 1.0/3.0*DTHETA
                        F_THETA1 = NINT(
     &                              1.155*SIN(2.094*(8)+3.142))
                        THETA1 = THETA + F_THETA1*DTHETA1
                        DTHETA2 = 1.0/3.0*DTHETA1
                        F_THETA2 = NINT(
     &                              1.155*SIN(2.094*(J-65)+3.142))
                        THETA2 = THETA1 + F_THETA2*DTHETA2
                        DPHI1 = 1.0/3.0*DPHI
                        F_PHI1 = NINT(
     &                            1.115*SIN(0.5236*(8)+3.927)
     &                           +0.2989*SIN(3.665*(8)-7.069))
                        PHI1 = PHI + F_PHI1*DPHI1
                        DPHI2 = 1.0/3.0*DPHI1
                        F_PHI2 = NINT(
     &                            1.115*SIN(0.5236*(J-65)+3.927)
     &                           +0.2989*SIN(3.665*(J-65)-7.069))
                        PHI2 = PHI1 + F_PHI2*DPHI2
                        R1 = AG*DSIN(THETA2)
                        XHET(J) = R1*DCOS(PHI2)+Xm0
                        YHET(J) = R1*DSIN(PHI2)+Ym0
                        ZHET(J) = AG*DCOS(THETA2)+Zm0
                        RHET(J) = RHET2
                        THETAT(J) = THETA2
                        PHIT(J) = PHI2
                    ENDIF
                END IF
            END IF                      
        END DO
      END IF
      
      END SUBROUTINE HETTRACK
      
C     SUBROUTINE TRANSFORMATION FOR HETERODOMAINS ON COLLECTOR
      SUBROUTINE HETC_TRANSFORMATION(XG,YG,ZG,XHET,YHET,ZHET,RHET,
     &                               HETMODE,THETA,PHI,XHET_T,
     &                               YHET_T,ZHET_T,RHET_T)
      
      DOUBLE PRECISION XHET(100),YHET(100),ZHET(100),RHET(100)
      DOUBLE PRECISION XHET_T(100),YHET_T(100),ZHET_T(100),RHET_T(100)
      DOUBLE PRECISION XG,YG,ZG
      DOUBLE PRECISION THETA,PHI
      DOUBLE PRECISION, DIMENSION(100,3) :: MHET,MHET_T
      INTEGER I,HETMODE

C     PROJECTION MATRIX
      MHET(:,1) = XHET
      MHET(:,2) = YHET
      MHET(:,3) = ZHET
C     TRANSFORM HETC POSITIONS TO THE FRAME OF REFERENCE WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER
      CALL TRANSFORMATION(XG,YG,ZG,PHI,THETA,SIZE(XHET),MHET,MHET_T)
C     GET ARRAYS OF HETC TRANSFORMED POSITIONS
      XHET_T = MHET_T(:,1)
      YHET_T = MHET_T(:,2)
      ZHET_T = MHET_T(:,3)
      RHET_T = RHET
      
      END SUBROUTINE HETC_TRANSFORMATION
      
C     SUBROUTINE GENERATION AND PROJECTION OF HETERODOMAINS ON COLLOID WRITTEN BY CESAR RON - ISO CONVENTION USED FOR SPHERICAL COORDINATES [R,THETA,PHI] (RADIAL, POLAR, AZIMUTAHL) 
      SUBROUTINE HETTRACKP(X,Y,Z,H,RZOI,AP,HETMODEP,SCOVP,RHETP0,RHETP1,
     &                     NHETP,XHETP,YHETP,ZHETP,RHETP,NPRO,XPRO,YPRO,
     &                     ZPRO,RPRO)
      
      DOUBLE PRECISION XHETP(10000000),YHETP(10000000),ZHETP(10000000)
      DOUBLE PRECISION RHETP(10000000),THETAP(10000000),PHIP(10000000)
      DOUBLE PRECISION XPRO(10000000),YPRO(10000000),ZPRO(10000000)
      DOUBLE PRECISION RPRO(10000000)
      DOUBLE PRECISION X,Y,Z,XmP0,YmP0,ZmP0,H
      DOUBLE PRECISION XHET,YHET,ZHET,RHET
      DOUBLE PRECISION ALPHA,BETA,A,B,RDHET
      DOUBLE PRECISION NHETREAL0,HMODEREAL,NRINGREAL,NHRINGREAL
      DOUBLE PRECISION PI,AP,RZOI,RHETP0,RHETP1,RPRO0,RPRO1
      DOUBLE PRECISION SCOVP,SCOVP0,SCOVP1
      DOUBLE PRECISION RRING,R1
      DOUBLE PRECISION THETA,THETA1,DTHETA
      DOUBLE PRECISION PHI,PHI1,DPHI,ARCL,PHIOFF
      DOUBLE PRECISION OMEGA0,OMEGA1
      DOUBLE PRECISION DAP,DC,DX,DY,ZU,ZL,RPL
      INTEGER NHETP0,NHETP1,NHETP,HETMODEP
      INTEGER NRING,NHETRING,NTHETA,NPHI,NPRO
      INTEGER I,J,K,M,N,HC 
      DATA PI/3.14159265359/ 
      
C     DEFINE COLLOID CENTER IN COLLECTOR FRAME OF REFERENCE
      XmP0 = X 
      YmP0 = Y 
      ZmP0 = Z 
C     RADIAL LIMIT WITHIN HETERODOMAINS WILL BE PROJECTED
      RPL = RZOI + RHETP0
C     LIMITS IN Z AXIS FOR THE RANGE WITHIN WHICH HETERODOMIANS WILL NOT BE PROJECTED
      ZU = AP + ZmP0 
      ZL = ZmP0 
C     HETMODEP TO BE USED IN DOUBLE PRECISION CALCULATIONS
      HMODEREAL = HETMODEP
C     CALCULATE OPENING ANGLE FOR ARC LENGTH OF SINGLE HETDOMAIN
      OMEGA0 = RHETP0/AP
      OMEGA1 = RHETP1/AP 
C     CALCULATE DIFFERENCE BETWEEN AP AND AP'
      DAP = AP*(1-DCOS(OMEGA0))
C     CALCULATE PROJECTED HETDOMAIN MAJOR AXIS
      RPRO0 = AP*DSIN(OMEGA0)
      RPRO1 = AP*DSIN(OMEGA1)
C     EQUIVALENT SURFACE COVERAGE CORRESPONDING TO UNIFORM HETDOMAINS IS USED IN CALCULATION
      IF (HETMODEP.EQ.1) THEN
          SCOVP0 = SCOVP
      ELSE 
          SCOVP0 = SCOVP*((1.0-DCOS(OMEGA0))
     &            /((1.0-DCOS(OMEGA0))
     &            +(HMODEREAL-1.0)*(1.0-DCOS(OMEGA1))))
      END IF     
C     CALCULATE THEORETICAL NUMBER OF HETDOMAINS
      NHETP0 = NINT(SCOVP0*4.0
     &        /(2.0*(1.0-DCOS(OMEGA0))))
      NHETP1 = (HMODEREAL-1.0)*NHETP0
C     INITIALIZE COUNT OF HETERODOMAINS
      HC = 0
C     CALCULATE NUMBER OF RINGS THAT YIELD NHET ASSUMING EVEN SPACING 
      NHETREAL0 = NHETP0
      NRING = NINT((NHETREAL0/1.3)**0.5)
      NRINGREAL = NRING
      SCOVP = (NHETREAL0*2.0*(1-DCOS(OMEGA0))+
     &       (HMODEREAL-1.0)*NHETREAL0*2.0*(1-DCOS(OMEGA1)))
     &       /(4.0)

C     SPHERICAL COORDINATES: RADIUS, THETA (POLAR ANGLE), PHI (AZIMUTHAL ANGLE)
C     AS USED IN PHYSICS (ISO 80000-2:2019 CONVENTION)
C     CALCULATE THETA ANGLE STEP AND CONSTANT ARC LENGTH
      DTHETA =  PI/(NRINGREAL-1.0)
C     INITITIALIZE THETA COLLOID ANGLE
      THETA = 0.0
C     CALCULATE ARCLENGHT CONSTANT 
      ARCL = DTHETA*AP
C     INITIALIZE PROJECTION ARRAYS
      IF (NHETP0.EQ.0) THEN
          XPRO(1) = 0.0
          YPRO(1) = 0.0
          RPRO(1) = 0.0
      ENDIF
C     GENERATE HETDOMAINS FROM 0.0 TO PI THETA DOMAIN     
      DO I=1,NRING            
          THETA = (I-1)*DTHETA  
          IF ((I.EQ.1).OR.(I.EQ.NRING)) THEN !AT POLES
              RRING = 0.0 !IN POLE NO RING AND ONLY ONE HETDOMAIN
              NHETRING = 1
              DPHI = 0.0
              IF (I.EQ.1) THEN
                  THETA = 0.0 
              ELSEIF (I.EQ.NRING) THEN
                  THETA = PI
              ENDIF
              !POPULATE HETDOMAINS AT POLE
              DO J=1,HETMODEP
                  HC = HC + 1
                  IF (J.EQ.1) THEN !GENERATE LARGE HETDOMAIN
                      PHI = 0
                      XHET = RRING*DCOS(PHI)+XmP0
                      YHET = RRING*DSIN(PHI)+YmP0
                      ZHET = AP*DCOS(THETA)+ZmP0  
                      RHET = RHETP0
                      BETA = ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETERODOMAIN RESPECT TO PROJECTION PLANE
                      ARG = (ZmP0-ZHET)/AP
                      IF (ARG.GE.1.0) THEN
                          ARG = 1.0
                          BETA = ACOS(ARG)
                      ELSEIF (ARG.LE.-1.0) THEN
                          ARG = -1.0
                          BETA = ACOS(ARG)
                      ENDIF
                      RDHET = ((XHET-XmP0)**2+
     &                        (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                      XHETP(HC) = XHET
                      YHETP(HC) = YHET
                      ZHETP(HC) = ZHET
                      RHETP(HC) = RHET
                      THETAP(HC) = THETA
                      PHIP(HC) = PHI
                      IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL)) THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                          XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                      ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                          IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE PROJECTION RADIAL LIMIT
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                              ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION
                          ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE PROJECTION RADIAL LIMIT AND LOWER HEMISPHERE OF COLLOID
                              DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                              DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                              DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                              A = RPRO0 !ELLIPSE MAJOR AXIS
                              B = RPRO0*DCOS(BETA) !ELLIPSE MINOR AXIS
                              XPRO(HC) = XHET-DX
                              YPRO(HC) = YHET-DY
                              ZPRO(HC) = -(AP + H)
                              RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS
                          ENDIF
                      ENDIF
                  ELSE !GENERATE MEDIUME AND SMALL HETDOMAINS AROUND LARGE HETERODOMAIN 
                      IF (HETMODEP.EQ.5) THEN !1:4
                          THETA1 = THETA+(1.0/3.0*DTHETA)  
                          PHI = (J-2)*PI/2.0
                          R1 = AP*DSIN(THETA1)
                          XHET = R1*DCOS(PHI)+XmP0
                          YHET = R1*DSIN(PHI)+YmP0
                          ZHET = AP*DCOS(THETA1)+ZmP0
                          RHET = RHETP1
                          BETA = ACOS((ZmP0-ZHET)/AP)!ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                          ARG = (ZmP0-ZHET)/AP
                          IF (ARG.GE.1.0) THEN
                              ARG = 1.0
                              BETA = ACOS(ARG)
                          ELSEIF (ARG.LE.-1.0) THEN
                              ARG = -1.0
                              BETA = ACOS(ARG)
                          ENDIF
                          RDHET = ((XHET-XmP0)**2+
     &                            (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                          XHETP(HC) = XHET
                          YHETP(HC) = YHET
                          ZHETP(HC) = ZHET
                          RHETP(HC) = RHET
                          THETAP(HC) = THETA1
                          PHIP(HC) = PHI
                          IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL))THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                              IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION
                              ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                  DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                  DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                  DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                  A = RPRO1 !ELLIPSE MAJOR AXIS
                                  B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                  XPRO(HC) = XHET-DX
                                  YPRO(HC) = YHET-DY
                                  ZPRO(HC) = -(AP + H)
                                  RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS
                              ENDIF
                          ENDIF
                      ELSEIF (HETMODEP.EQ.9) THEN !1:8
                          THETA1 = THETA + (1.0/3.0*DTHETA)
                          R1 = AP*DSIN(THETA1)
                          IF (J.EQ.2) THEN
                              PHI = 0.0
                          ENDIF
                          IF (J.EQ.3) THEN
                              PHI = PI/4.0
                          ENDIF
                          IF (J.EQ.4) THEN
                              PHI = PI/2.0
                          ENDIF
                          IF (J.EQ.5) THEN
                              PHI = 3.0/4.0*PI
                          END IF 
                          IF (J.EQ.6) THEN
                              PHI = PI
                          ENDIF
                          IF (J.EQ.7) THEN
                              PHI = 5.0/4.0*PI
                          ENDIF
                          IF (J.EQ.8) THEN
                              PHI = 3.0/2.0*PI
                          ENDIF
                          IF (J.EQ.9) THEN
                              PHI = 7.0/4.0*PI
                          ENDIF
                          XHET = R1*DCOS(PHI)+XmP0
                          YHET = R1*DSIN(PHI)+YmP0
                          ZHET = AP*DCOS(THETA1)+ZmP0
                          RHET = RHETP1
                          BETA =ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                          ARG = (ZmP0-ZHET)/AP
                          IF (ARG.GE.1.0) THEN
                              ARG = 1.0
                              BETA = ACOS(ARG)
                          ELSEIF (ARG.LE.-1.0) THEN
                              ARG = -1.0
                              BETA = ACOS(ARG)
                          ENDIF
                          RDHET = ((XHET-XmP0)**2+
     &                            (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                          XHETP(HC) = XHET
                          YHETP(HC) = YHET
                          ZHETP(HC) = ZHET
                          RHETP(HC) = RHET
                          THETAP(HC) = THETA1
                          PHIP(HC) = PHI
                          IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL))THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                              IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION
                              ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                  DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                  DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                  DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                  A = RPRO1 !ELLIPSE MAJOR AXIS
                                  B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                  XPRO(HC) = XHET-DX
                                  YPRO(HC) = YHET-DY
                                  ZPRO(HC) = -(AP + H)
                                  RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS
                              ENDIF
                          ENDIF
                      ENDIF
                  ENDIF
              ENDDO
          ELSE !NOT AT POLES
              RRING = AP*DSIN(THETA) 
              NHETRING = NINT(2.0*PI*RRING/ARCL)
              IF (NHETRING.LT.3) THEN
                  NHETRING = 3
              ENDIF
              NHRINGREAL = NHETRING
              !CALCULATE STEP IN PHI (AZIMUTHAL ANGLE) BASED ON NHETRING
              DPHI = 2.0*PI/NHRINGREAL
              !CALCULATE OFFSET AS 10% OF THE STEP IN PHI IF RING IS ODD OR EVEN
              M = MOD(I,2)
              IF (M.EQ.0) THEN
                  PHIOFF = 0.1*DPHI 
              ELSE
                  PHIOFF = -0.1*DPHI 
              ENDIF  
              !POPULATE HETERODOMAINS ON RINGS     
              DO K=1,NHETRING
              !CALCULATE PHI ANGLE
                  PHI = (K-1)*DPHI+PHIOFF
                  !FORTRAN DOES NOT RECOGNIZE ANGLE VALUES GT.2.0*PI RADIANS
                  IF (PHI.GT.(2.0*PI)) THEN 
                      PHI = 2.0*PI*((PHI)/(2.0*PI)-INT(PHI/(2.0*PI)))
                  ENDIF
                  DO J=1,HETMODEP
                      HC = HC + 1
                      IF (J.EQ.1) THEN !GENERATE LARGE HETDOMAIN
                          XHET = RRING*DCOS(PHI)+XmP0 
                          YHET = RRING*DSIN(PHI)+YmP0
                          ZHET = AP*DCOS(THETA)+ZmP0
                          RHET = RHETP0
                          BETA =ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                          ARG = (ZmP0-ZHET)/AP
                          IF (ARG.GE.1.0) THEN
                              ARG = 1.0
                              BETA = ACOS(ARG)
                          ELSEIF (ARG.LE.-1.0) THEN
                              ARG = -1.0
                              BETA = ACOS(ARG)
                          ENDIF
                          RDHET = ((XHET-XmP0)**2+
     &                            (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                          XHETP(HC) = XHET
                          YHETP(HC) = YHET
                          ZHETP(HC) = ZHET
                          RHETP(HC) = RHET
                          THETAP(HC) = THETA
                          PHIP(HC) = PHI
                          IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL))THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                              XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                          ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                              IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT
                                  ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION 
                              ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                  DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                  DX = DC*DCOS(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                  DY = DC*DSIN(PHI) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                  A = RPRO0 !ELLIPSE MAJOR AXIS
                                  B = RPRO0*DCOS(BETA) !ELLIPSE MINOR AXIS
                                  XPRO(HC) = XHET-DX
                                  YPRO(HC) = YHET-DY
                                  ZPRO(HC) = -(AP + H)
                                  RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS 
                              ENDIF
                          ENDIF
                      ELSE !GENERATE MEDIUME AND SMALL HETDOMAINS AROUND LARGE HETERODOMAIN 
                          IF (HETMODEP.EQ.5) THEN !1:4
                              IF (J.EQ.2) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.3) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.4) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.5) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              R1 = AP*DSIN(THETA1)
                              XHET = R1*DCOS(PHI1)+XmP0
                              YHET = R1*DSIN(PHI1)+YmP0
                              ZHET = AP*DCOS(THETA1)+ZmP0
                              RHET = RHETP1
                              BETA = ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                              ARG = (ZmP0-ZHET)/AP
                              IF (ARG.GE.1.0) THEN
                                  ARG = 1.0
                                  BETA = ACOS(ARG)
                              ELSEIF (ARG.LE.-1.0) THEN
                                  ARG = -1.0
                                  BETA = ACOS(ARG)
                              ENDIF
                              RDHET = ((XHET-XmP0)**2+
     &                                (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                              XHETP(HC) = XHET
                              YHETP(HC) = YHET
                              ZHETP(HC) = ZHET
                              RHETP(HC) = RHET
                              THETAP(HC) = THETA1
                              PHIP(HC) = PHI1
                              IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL)) THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                                  IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                      XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                      RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION 
                                  ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                      DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                      DX = DC*DCOS(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                      DY = DC*DSIN(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                      A = RPRO1 !ELLIPSE MAJOR AXIS
                                      B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                      XPRO(HC) = XHET-DX
                                      YPRO(HC) = YHET-DY
                                      ZPRO(HC) = -(AP + H)
                                      RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS 
                                  ENDIF
                              ENDIF
                          ELSEIF (HETMODEP.EQ.9) THEN !1:8
                              IF (J.EQ.2) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.3) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA+(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.4) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.5) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.6) THEN
                                  PHI1 = PHI-(1.0/3.0*DPHI)
                                  THETA1 = THETA
                              ENDIF
                              IF (J.EQ.7) THEN
                                  PHI1 = PHI
                                  THETA1 = THETA + (1.0/3.0*DTHETA)
                              ENDIF
                              IF (J.EQ.8) THEN
                                  PHI1 = PHI+(1.0/3.0*DPHI)
                                  THETA1 = THETA
                              ENDIF
                              IF (J.EQ.9) THEN
                                  PHI1 = PHI
                                  THETA1 = THETA-(1.0/3.0*DTHETA)
                              ENDIF
                              R1 = AP*DSIN(THETA1)
                              XHET = R1*DCOS(PHI1)+XmP0
                              YHET = R1*DSIN(PHI1)+YmP0
                              ZHET = AP*DCOS(THETA1)+ZmP0
                              RHET = RHETP1
                              BETA = ACOS((ZmP0-ZHET)/AP) !ELEVATION ANGLE OF THE HETDOMAIN RESPECT TO PROJECTION PLANE
                              ARG = (ZmP0-ZHET)/AP
                              IF (ARG.GE.1.0) THEN
                                  ARG = 1.0
                                  BETA = ACOS(ARG)
                              ELSEIF (ARG.LE.-1.0) THEN
                                  ARG = -1.0
                                  BETA = ACOS(ARG)
                              ENDIF
                              RDHET = ((XHET-XmP0)**2+
     &                                (YHET-YmP0)**2)**0.5 !RADIAL DISTANCE OF HETERODOMAIN CENTER
                              XHETP(HC) = XHET
                              YHETP(HC) = YHET
                              ZHETP(HC) = ZHET
                              RHETP(HC) = RHET
                              THETAP(HC) = THETA1
                              PHIP(HC) = PHI1
                              IF ((ZHET.LE.ZU).AND.(ZHET.GE.ZL)) THEN !NOT TO PROJECT HETDOMAIN IN UPPER HEMISPHERE OF THE COLLOID
                                  XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                  RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                              ELSE !GENERATE PROJECTION OF HETDOMAINS IN LOWER HEMISPHERE OF THE COLLOID
                                  IF (RDHET.GE.RPL) THEN !NOT TO PROJECT HETDOMAIN OUTSIDE RADIAL LIMIT
                                      XPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      YPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT 
                                      ZPRO(HC) = 0.0 !0.0 FOR PROJECTION OF HETERODOMAINS LOCATED IN UPPER HEMISPHERE OF THE COLLOID
                                      RPRO(HC) = 0.0 !EQUIVALENT CIRCLE RADIUS, 0.0 FOR PROJECTION OF HETERODOMAINS LOCATED OUTSIDE RADIAL LIMIT OF PROJECTION 
                                  ELSE !GENERATE PROJECTION OF HETDOMAIN INSIDE RADIAL LIMIT
                                      DC = DAP*DSIN(BETA) !TOTAL DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-Y PLANE
                                      DX = DC*DCOS(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN X-AXIS
                                      DY = DC*DSIN(PHI1) !DISPLACEMENT OF PROJECTION CENTER RESPECT HETDOMAIN CENTER IN Y-AXIS
                                      A = RPRO1 !ELLIPSE MAJOR AXIS
                                      B = RPRO1*DCOS(BETA) !ELLIPSE MINOR AXIS
                                      XPRO(HC) = XHET-DX
                                      YPRO(HC) = YHET-DY
                                      ZPRO(HC) = -(AP + H)
                                      RPRO(HC) = (A*B)**0.5 !EQUIVALENT CIRCLE RADIUS 
                                  ENDIF
                              ENDIF
                          ENDIF
                      ENDIF
                  ENDDO  
              ENDDO 
          ENDIF
      ENDDO
C     REAL NUMBER OF HETDOMAINS
      NHETP = COUNT(RHETP.NE.0.0)
C     NUMBER OF PROJECTIONS
      NPRO = COUNT(RPRO.NE.0.0)
      
      END SUBROUTINE HETTRACKP
      
C     PROJECTION MATRIX FOR HETERODOMAINS ON COLLOID 
      SUBROUTINE PROJECTION_MATRIX(NPRO,XPRO,YPRO,ZPRO,RPRO,MPRO)
      
      DOUBLE PRECISION XPRO(10000000),YPRO(10000000),ZPRO(10000000)
      DOUBLE PRECISION RPRO(10000000)
      DOUBLE PRECISION X,Y,Z,XmP0,YmP0,ZmP0
      INTEGER I,J,NPRO
      DOUBLE PRECISION, DIMENSION(NPRO,4) :: MPRO 
      DOUBLE PRECISION, DIMENSION(NPRO) :: M_X,M_Y,M_Z,M_R

C     INITIALIZE PROJECTIONS COUNTER      
      J = 0
C     EXTRACT PROJECTION POSITION AND RADIUS
      DO I=1,SIZE(RPRO)
          IF (RPRO(I).NE.0.0) THEN
              J = J + 1 
              M_X(J) = XPRO(I)
              M_Y(J) = YPRO(I)
              M_Z(J) = ZPRO(I)
              M_R(J) = RPRO(I)
          END IF
      END DO
C     PROJECTION MATRIX
      MPRO(:,1) = M_X(:) 
      MPRO(:,2) = M_Y(:)
      MPRO(:,3) = M_Z(:)
      MPRO(:,4) = M_R(:)

      END SUBROUTINE PROJECTION_MATRIX   

C     SUBROUTINE TRANSFORMATION FOR PROJECTIONS OF HETERODOMAINS ON COLLOID
      SUBROUTINE MPRO_TRANSFORMATION(X,Y,Z,XG,YG,ZG,THETA,PHI,NPRO,MPRO,
     &                               MPRO_T)
      
      DOUBLE PRECISION X,Y,Z,XG,YG,ZG
      DOUBLE PRECISION THETA,PHI
      DOUBLE PRECISION, DIMENSION(NPRO,4) :: MPRO
      DOUBLE PRECISION, DIMENSION(NPRO,3) :: MI,MI_T,MPRO_T
      DOUBLE PRECISION, DIMENSION(NPRO,1) :: XT,YT,ZT,RT
      DOUBLE PRECISION, DIMENSION(3,3) :: MR
      INTEGER NPRO,I

C     GET POSITIONS OF HETP PROJECTIONS THAT WERE GENERATED USING THE ORIGING OF THE COLLECTOR FRAME OF REFERENCE AS CENTER OF COLLOID
      MI(:,1) = MPRO(:,1)
      MI(:,2) = MPRO(:,2)
      MI(:,3) = MPRO(:,3)
C     POSITIONS OF HETP PROJECTION ROTATED TO FACE THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER 
      CALL ROTATION(PHI,THETA,MR)
      MI = MATMUL(MI,MR)
C     POSITIONS OF HETP PROJECTION IN COLLECTOR FRAME OF REFERENCE AFTER ROTATION RELATIVE TO COLLOID CENTER
      MI(:,1) = MI(:,1) + SPREAD(X,1,NPRO)
      MI(:,2) = MI(:,2) + SPREAD(Y,1,NPRO)
      MI(:,3) = MI(:,3) + SPREAD(Z,1,NPRO)
C     TRANSFORM POSITIONS OF HETP PROJECTIONS TO THE FRAME OF REFERENCE WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER
      CALL TRANSFORMATION(XG,YG,ZG,PHI,THETA,NPRO,MI,MI_T)
C     TRANFORMED PROJECTION MATRIX 
      XT(:,1) = MI_T(:,1)
      YT(:,1) = MI_T(:,2)
      ZT(:,1) = MI_T(:,3)
      RT(:,1) = MPRO(:,4)
      MPRO_T(:,1) = XT(:,1)
      MPRO_T(:,2) = YT(:,1)
      MPRO_T(:,3) = RT(:,1)
      
      END SUBROUTINE MPRO_TRANSFORMATION

C     SUBROUTINE CALCULATE UNIT VECTORS DEFINING THE FRAME OF REFERENCE WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT OF PROJECTION OF THE COLLOID CENTER
      SUBROUTINE TRANSFORMATION(XG,YG,ZG,PHI,THETA,N,M0,MF)
      
      DOUBLE PRECISION XG,YG,ZG
      DOUBLE PRECISION PHI,THETA,PHI_R,THETA_R,PSI_R
      DOUBLE PRECISION q0,q1,q2,q3
      DOUBLE PRECISION, DIMENSION(1,3) :: EX_C,EY_C,EZ_C
      DOUBLE PRECISION, DIMENSION(1,3) :: EX_G,EY_G,EZ_G
      DOUBLE PRECISION, DIMENSION(3,3) :: MR,MT
      INTEGER N
      DOUBLE PRECISION, DIMENSION(N,4) :: M0,MF
      DOUBLE PRECISION, DIMENSION(N,3) :: MI
      DATA PI/3.14159265359/ 

C     UNIT VECTORS DEFINING THE COLLECTOR FRAME OF REFERENCE
      EX_C(1,:) = [1, 0, 0] 
      EY_C(1,:) = [0, 1, 0]
      EZ_C(1,:) = [0, 0, 1]
C     ROTATION ANGLES BASED ON COLLOID SPHERICAL COORDINATES (X-CONVENTION, Z-X-Z SEQUENCE ROTATION IS COUNTER=CLOCKWISE) (GOLDSTEIN, 2001, P.152 AND P.601)
      PHI_R   = 0.5*PI + PHI
      THETA_R = THETA 
      PSI_R   = 1.5*PI - PHI
C     CALCULATE QUATERNIONS FOR ROTATION MATRIX 
      q0 = DCOS(0.5*PHI_R + 0.5*PSI_R)*DCOS(0.5*THETA_R);
      q1 = DCOS(0.5*PHI_R - 0.5*PSI_R)*DSIN(0.5*THETA_R);
      q2 = DSIN(0.5*PHI_R - 0.5*PSI_R)*DSIN(0.5*THETA_R);
      q3 = DSIN(0.5*PHI_R + 0.5*PSI_R)*DCOS(0.5*THETA_R);
C     CALCULATE ROTATION MATRIX
      MR(1,:) = [1-2*(q2**2+q3**2), 2*(q1*q2-q0*q3), 2*(q1*q3-q2*q0)]
      MR(2,:) = [2*(q1*q2-q3*q0), 1-2*(q1**2+q3**2), 2*(q0*q1+q2*q3)]
      MR(3,:) = [2*(q0*q2+q1*q3), 2*(q2*q3-q0*q1), 1-2*(q1**2+q2**2)]
C     UNIT VECTOR DEFINING THE FRAME OF REFERENCE WITH X-Y PLANE MATCHING THE PLANE PARALLEL TO THE HAPPEL SPHERE AT THE POINT WHERE THE COLLOID CENTER IS PROJECTED
      EX_G = MATMUL(EX_C,MR) 
      EY_G = MATMUL(EY_C,MR) 
      EZ_G = MATMUL(EZ_C,MR) 
C     TRANSFORMATION MATRIX BASED ON PREVIOUS UNIT VECTORS
      MT(1,:) = [EX_G(1,1), EY_G(1,1), EZ_G(1,1)]
      MT(2,:) = [EX_G(1,2), EY_G(1,2), EZ_G(1,2)]
      MT(3,:) = [EX_G(1,3), EY_G(1,3), EZ_G(1,3)]
C     GET POSITION COLUMNS ONLY AND TRASLATE POSITIONS (WHICH IS REQUIRED PREVIOUS TO APPLY THE TRANSFORMATION)
      MI(:,1) = M0(:,1) - SPREAD(XG,1,N)
      MI(:,2) = M0(:,2) - SPREAD(YG,1,N)
      MI(:,3) = M0(:,3) - SPREAD(ZG,1,N)
C     APPLY THE TRANSFORMATION
      MI = MATMUL(MI,MT)
C     ADD RADIUS COLUMN TO POSITION MATRIX
      MF(:,1) = MI(:,1)
      MF(:,2) = MI(:,2)
      MF(:,3) = MI(:,3)
      MF(:,4) = M0(:,4)
      
      END SUBROUTINE TRANSFORMATION

C     SUBROUTINE CALCULATE ROTATION MATRIX BASED ON COLLOID SPHERICAL COORDINATES
      SUBROUTINE ROTATION(PHI,THETA,MR)

      DOUBLE PRECISION, DIMENSION(3,3) :: MR 
      DOUBLE PRECISION PHI,THETA,PHI_R,THETA_R,PSI_R
      DOUBLE PRECISION q0,q1,q2,q3
      INTEGER N
      DATA PI/3.14159265359/ 
      
C     ROTATION ANGLES BASED ON COLLOID SPHERICAL COORDINATES (X-CONVENTION, Z-X-Z SEQUENCE ROTATION IS COUNTER=CLOCKWISE) (GOLDSTEIN, 2001, P.152 AND P.601)
      PHI_R   = 0.5*PI + PHI
      THETA_R = THETA 
      PSI_R   = 1.5*PI - PHI
      
C     CALCULATE QUATERNIONS FOR ROTATION MATRIX 
      q0 = DCOS(0.5*PHI_R + 0.5*PSI_R)*DCOS(0.5*THETA_R);
      q1 = DCOS(0.5*PHI_R - 0.5*PSI_R)*DSIN(0.5*THETA_R);
      q2 = DSIN(0.5*PHI_R - 0.5*PSI_R)*DSIN(0.5*THETA_R);
      q3 = DSIN(0.5*PHI_R + 0.5*PSI_R)*DCOS(0.5*THETA_R);
      
C     CALCULATE ROTATION MATRIX
      MR(1,:) = [1-2*(q2**2+q3**2), 2*(q1*q2-q0*q3), 2*(q1*q3-q2*q0)]
      MR(2,:) = [2*(q1*q2-q3*q0), 1-2*(q1**2+q3**2), 2*(q0*q1+q2*q3)]
      MR(3,:) = [2*(q0*q2+q1*q3), 2*(q2*q3-q0*q1), 1-2*(q1**2+q2**2)]
      
      END SUBROUTINE ROTATION

C     SUBROUTINE TO DETERMINE FRACTIONAL AREA WRITTEN BY CESAR RON     
      SUBROUTINE FRACTIONAL_AREA(XP,YP,RZOI,XHET,YHET,RHET,NPRO,M1,
     &                           AF_PZ,AF_ZH,AF_PZH,AF_Z)
      
      DOUBLE PRECISION XP,YP,XmP0,YmP0,RZOI,XHET,YHET,RHET
      DOUBLE PRECISION RZ,RH,DXZH,DYZH,DZH,SUMRZH,DIFFRZH
      DOUBLE PRECISION R1,R2,D,A1,A2
      DOUBLE PRECISION R1_2,R2_2,D_2
      DOUBLE PRECISION DX12,DY12,D12,PHI12,OMEGA1_12,OMEGA2_12
      DOUBLE PRECISION X1_12,Y1_12,X2_12,Y2_12
      DOUBLE PRECISION Ao3,AF_PZ,AF_ZH,AF_PZH,AF_Z
      DOUBLE PRECISION, ALLOCATABLE :: DX(:,:),DY(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: SUMR(:,:),DIFFR(:,:),DIST(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_1(:,:),Ao2_2(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_PZ(:,:),Ao2_PH(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_ZH(:,:),Ao3_F(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_PZF(:,:),Ao2_PHF(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: Ao2_ZHF(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: IZH(:,:),IPZ(:,:),IPH(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: POINTS_IP(:,:),POINTS_IZ(:,:)
      DOUBLE PRECISION, ALLOCATABLE :: POINTS_IH(:,:)
      INTEGER, ALLOCATABLE :: PAIRS_O(:,:),PAIRS_PO(:,:),PAIRS_CO(:,:)
      INTEGER, ALLOCATABLE :: PAIRS_NO(:,:),OM_P(:,:),OM_ZH(:,:)
      INTEGER, ALLOCATABLE :: IPI(:,:),IPIP(:,:),IPIH(:,:),IPIZ(:,:)
      INTEGER NPRO,S1,S2
      INTEGER I,J,OO,PO,CO,NO,O,N,P,C,NF
      INTEGER AZH,APZ,APH
      INTEGER IPI_1,IPI_2
      INTEGER IPIP_O,IPIH_O,IPIZ_O,LOCATOR_IP,LOCATOR_IH,LOCATOR_IZ
      DOUBLE PRECISION, DIMENSION(NPRO,3) :: M1                       !PRO
      DOUBLE PRECISION, DIMENSION(2,3) :: M2                          !ZOI AND HET
      DATA PI/3.14159265359/ 
      
C     DEFINE COLLOID CENTER IN COLLECTOR FRAME OF REFERENCE
      XmP0 = XP 
      YmP0 = YP 
C     DEFINE PRO MATRIX AND ZOI-HET MATRIX
      M2(1,:) = [XmP0, YmP0, RZOI]   !ZOI
      M2(2,:) = [XHET, YHET, RHET] !HET
C     ZOI AND HET RADII
      RZ = M2(1,3)
      RH = M2(2,3)
C     ZOI-HET DISTANCES
      DXZH = M2(2,1)-M2(1,1)
      DYZH = M2(2,2)-M2(1,2)
      DZH = (DXZH**2+DYZH**2)**0.5
      SUMRZH = RZ+RH
      DIFFRZH = RZ-RH
C     ROWS IN M1 AND M2
      S1 = SIZE(M1,1)
      S2 = SIZE(M2,1)
C     X AND Y DISTANCE BETWEEN PRO AND BOTH ZOI AND HET
      ALLOCATE(DX(S1,S2))
      ALLOCATE(DY(S1,S2))
      DX(:,1) = M1(:,1)-M2(1,1)
      DX(:,2) = M1(:,1)-M2(2,1)
      DY(:,1) = M1(:,2)-M2(1,2)
      DY(:,2) = M1(:,2)-M2(2,2)
C     RADIUS SUM AND DIFFERENCE BETWEEN PRO AND BORH ZOI AND HET
      ALLOCATE(SUMR(S1,S2))
      ALLOCATE(DIFFR(S1,S2))
      SUMR(:,1) = M1(:,3)+M2(1,3) 
      SUMR(:,2) = M1(:,3)+M2(2,3)
      DIFFR(:,1) = M1(:,3)-M2(1,3)
      DIFFR(:,2) = M1(:,3)-M2(2,3)
C     TOTAL DISTANCE BETWEEN PRO AND BOTH ZOI AND HET
      ALLOCATE(DIST(S1,S2))
      DIST = (DX**2+DY**2)**0.5
C     PAIRS PRO-ZOI AND PRO-HET WHICH OVERLAP, PARTIALLY OVERLAP, AND COMPLETELY OVERLAP
      !ALLOCATE(PAIRS_O(0,2))
      OO = 0
      PO = 0
      CO = 0
      NO = 0
      DO I=1,S2
          DO J=1,S1
              IF (DIST(J,I).LT.SUMR(J,I)) THEN
                  OO = OO + 1
                  IF (DIST(J,I).GT.ABS(DIFFR(J,I))) THEN
                      PO = PO + 1
                  ELSEIF (DIST(J,I).LE.ABS(DIFFR(J,I))) THEN
                      CO = CO + 1
                  ENDIF
              ElSE
                  NO = NO + 1
              ENDIF
          ENDDO
      ENDDO
      ALLOCATE(PAIRS_O(OO,2))
      ALLOCATE(PAIRS_PO(PO,2))
      ALLOCATE(PAIRS_CO(CO,2))
      ALLOCATE(PAIRS_NO(NO,2))
      O = 0
      P = 0
      C = 0
      N = 0
      DO I=1,S2
          DO J=1,S1
              IF (DIST(J,I).LT.SUMR(J,I)) THEN
                  O = O + 1
                  PAIRS_O(O,:) = [J, I]
                  IF (DIST(J,I).GT.ABS(DIFFR(J,I))) THEN
                      P = P + 1
                      PAIRS_PO(P,:) = [J, I]
                  ELSEIF (DIST(J,I).LE.ABS(DIFFR(J,I))) THEN
                      C = C + 1
                      PAIRS_CO(C,:) = [J, I]
                  ENDIF
              ELSE
                  N = N + 1
                  PAIRS_NO(N,:) = [J, I]
              ENDIF
          ENDDO
      ENDDO
C     PRO OVERLAP MATRIX: 1 FOR PARTIAL OVERLAP, -1 FOR COMPLETE OVERLAP, 0 FOR NO OVERLAP
      ALLOCATE(OM_P(S1,S2))
      OM_P(:,:) = 0 !COLUMN 1: PRO-ZOI OVERLAP, COLUMN 2: PRO-HET OVERLAP
      DO I=1,PO
          OM_P(PAIRS_PO(I,1),PAIRS_PO(I,2)) = 1
      ENDDO
      DO I=1,CO
          OM_P(PAIRS_CO(I,1),PAIRS_CO(I,2)) = -1
      ENDDO
C     ZOI-HET OVERLAP MATRIX: 1 FOR PARTIAL OVERLAP, -1 FOR COMPLETE OVERLAP, 0 FOR NO OVERLAP  
      ALLOCATE(OM_ZH(1,1))
      OM_ZH = 0
      IF (DZH.GT.SUMRZH) THEN !NO 2 OVERLAP FOR ZOI-HET
          OM_ZH = OM_ZH
      ELSE !2 OVERLAP FOR ZOI-HET
          IF (ABS(DIFFRZH).GE.DZH) THEN !ZOI-HET COMPLETE OVERLAP
              OM_ZH = -1
          ELSE !ZOI-HET PARTIAL OVERLAP
              OM_ZH = 1
          ENDIF
      ENDIF
C     CALCULATE 2 OVERLAP AREA FOR PRO-ZOI AND PRO-HET
      ALLOCATE(Ao2_1(S1,S2))
      Ao2_1 = 0.0      
      !PRO-ZOI AND PRO-HET PARTIAL OVERLAP
      DO I=1,SIZE(PAIRS_PO(:,1))
          R1 = M1(PAIRS_PO(I,1),3)
          D = DIST(PAIRS_PO(I,1),PAIRS_PO(I,2))
          IF (PAIRS_PO(I,2).EQ.1) THEN
              R2 = M2(1,3)
          ELSE
              R2 = M2(2,3)
          ENDIF
          R1_2 = R1**2
          R2_2 = R2**2
          D_2 = D**2
          A1 = ACOS((D_2+R1_2-R2_2)/(2*D*R1))
          ARG = (D_2+R1_2-R2_2)/(2*D*R1)
          IF (ARG.GE.1.0) THEN
              ARG = 1.0
              A1 = ACOS(ARG)
          ELSEIF (ARG.LE.-1.0) THEN
              ARG = -1.0
              A1 = ACOS(ARG)
          ENDIF
          A2 = ACOS((D_2+R2_2-R1_2)/(2*D*R2))
          ARG = (D_2+R2_2-R1_2)/(2*D*R2)
          IF (ARG.GE.1.0) THEN
              ARG = 1.0
              A2 = ACOS(ARG)
          ELSEIF (ARG.LE.-1.0) THEN
              ARG = -1.0
              A2 = ACOS(ARG)
          ENDIF
          Ao2_1(PAIRS_PO(I,1),PAIRS_PO(I,2)) = R1_2*A1+R2_2*A2-0.5*
     &                                       (((-D+R1+R2)*(D+R1-R2)
     &                                       *(D-R1+R2)*(D+R1+R2))**0.5)
      ENDDO
      !PRO-ZOI AND PRO-HET COMPLETE OVERLAP    
      DO I=1,SIZE(PAIRS_CO(:,1))
          R1 = M1(PAIRS_CO(I,1),3)
          D = DIST(PAIRS_CO(I,1),PAIRS_CO(I,2))
          IF (PAIRS_CO(I,2).EQ.1) THEN
              R2 = M2(1,3)
          ELSE
              R2 = M2(2,3)
          ENDIF
          IF (R1.GT.R2) THEN
              Ao2_1(PAIRS_CO(I,1),PAIRS_CO(I,2)) = PI*(R2**2)
          ELSE
              Ao2_1(PAIRS_CO(I,1),PAIRS_CO(I,2)) = PI*(R1**2)
          ENDIF
      ENDDO
C     CALCULATE 2 OVERLAP AREA FOR PRO-ZOI AND PRO-HET
      ALLOCATE(Ao2_2(1,1))
      Ao2_2 = 0
      R1 = RZ
      R2 = RH
      R1_2 = RZ**2
      R2_2 = RH**2
      D = DZH
      D_2 = DZH**2
      IF (D.LT.(R1+R2)) THEN 
          IF (ABS(R1-R2).GE.D) THEN
              IF (R1.GT.R2) THEN
                  Ao2_2 = PI*R2**2
              ELSE
                  Ao2_2 = PI*R1**2
              ENDIF
          ELSE
              A1 = ACOS((D_2+R1_2-R2_2)/(2*D*R1))
              ARG = (D_2+R1_2-R2_2)/(2*D*R1)
              IF (ARG.GE.1.0) THEN
                  ARG = 1.0
                  A1 = ACOS(ARG)
              ELSEIF (ARG.LE.-1.0) THEN
                  ARG = -1.0
                  A1 = ACOS(ARG)
              ENDIF
              A2 = ACOS((D_2+R2_2-R1_2)/(2*D*R2))
              ARG = (D_2+R2_2-R1_2)/(2*D*R2)
              IF (ARG.GE.1.0) THEN
                  ARG = 1.0
                  A2 = ACOS(ARG)
              ELSEIF (ARG.LE.-1.0) THEN
                  ARG = -1.0
                  A2 = ACOS(ARG)
              ENDIF
              Ao2_2 = R1_2*A1+R2_2*A2-0.5*(((-D+R1+R2)*(D+R1-R2)
     &                 *(D-R1+R2)*(D+R1+R2))**0.5)
          ENDIF
      ENDIF
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI
      ALLOCATE(Ao2_PZ(S1,1))
      Ao2_PZ = 0.0
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI    
      ALLOCATE(Ao2_PH(S1,1))
      Ao2_PH = 0.0
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI 
      ALLOCATE(Ao2_ZH(S1,1))
      Ao2_ZH = 0.0
C     MATRIX FOR 2 OVERLAP AREA PRO-ZOI 
      ALLOCATE(Ao3_F(S1,1))
      Ao3_F = 0.0
C     DETERMINE 2 OR 3 OVERLAP AREA FOR EACH PRO
      DO I=1,S1 ![1] LOOP THROUGH EACH PRO
          AZH = OM_ZH(1,1)
          APZ = OM_P(I,1)
          APH = OM_P(I,2)
          IF ((APZ.EQ.1).AND.(APH.EQ.1)) THEN ![2] PRO-ZOI PARTIAL OVERLAP, PRO-HET PARTIAL OVERLAP
              IF (AZH.EQ.0) THEN ![3] NO ZOI-HET OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !ZOI-HET INTERSECTION POINTS
                  ALLOCATE(IZH(2,2))
                  CALL INTERSECTION_POINTS(RZ,RH,M2(1,1),M2(1,2),
     &                                     M2(2,1),M2(2,2),
     &                                     XP,YP,X1_12,Y1_12,
     &                                     X2_12,Y2_12)
                  IZH(1,:) = [X1_12, Y1_12]
                  IZH(2,:) = [X2_12, Y2_12]
                  !ZOI-HET INTERSECTION POINTS INSIDE PRO: 1 FOR INSIDE, 0 FOR OUTSIDE
                  ALLOCATE(IPIP(2,1))
                  CALL INSIDE_CIRCLE(M1(I,1),M1(I,2),M1(I,3),
     &                               IZH,IPI_1,IPI_2)
                  IPIP(1,1) = IPI_1
                  IPIP(2,1) = IPI_2
                  !PRO-ZOI INTERSECTION POINTS
                  ALLOCATE(IPZ(2,2))
                  CALL INTERSECTION_POINTS(RZ,M1(I,3),M2(1,1),M2(1,2),
     &                                     M1(I,1),M1(I,2),             
     &                                     XP,YP,X1_12,Y1_12,
     &                                     X2_12,Y2_12)
                  IPZ(1,:) = [X1_12, Y1_12]
                  IPZ(2,:) = [X2_12, Y2_12]
                  !PRO-ZOI INTERSECTION POINTS INSIDE HET: 1 FOR INSIDE, 0 FOR OUTSIDE
                  ALLOCATE(IPIH(2,1))
                  CALL INSIDE_CIRCLE(M2(2,1),M2(2,2),M2(2,3),
     &                               IPZ,IPI_1,IPI_2)
                  IPIH(1,1) = IPI_1
                  IPIH(2,1) = IPI_2
                  !PRO-HET INTERSECTION POINTS
                  ALLOCATE(IPH(2,2))
                  CALL INTERSECTION_POINTS(RH,M1(I,3),M2(2,1),M2(2,2),
     &                                     M1(I,1),M1(I,2),             
     &                                     M2(2,1),M2(2,2),X1_12,Y1_12,
     &                                     X2_12,Y2_12)
                  IPH(1,:) = [X1_12, Y1_12]
                  IPH(2,:) = [X2_12, Y2_12]
                  !PRO-HET INTERSECTION POINTS INSIDE ZOI: 1 FOR INSIDE, 0 FOR OUTSIDE
                  ALLOCATE(IPIZ(2,1))
                  CALL INSIDE_CIRCLE(M2(1,1),M2(1,2),M2(1,3),
     &                               IPH,IPI_1,IPI_2)
                  IPIZ(1,1) = IPI_1
                  IPIZ(2,1) = IPI_2
                  !DECIDE IF 3 OVERLAP OR 2 OVERLAP AREA CALCULATION
                  IPIP_O = 0
                  IPIH_O = 0
                  IPIZ_O = 0
                  DO J=1,SIZE(IPIP(:,1))
                      IF (IPIP(J,1).EQ.1) THEN
                          IPIP_O = J
                      END IF
                      IF (IPIH(J,1).EQ.1) THEN
                          IPIH_O = J
                      END IF
                      IF (IPIZ(J,1).EQ.1) THEN
                          IPIZ_O = J
                      END IF
                  ENDDO
                  IF ((IPIP_O.EQ.0).AND.(IPIH_O.EQ.0)
     &                .AND.(IPIZ_O.EQ.0)) THEN !2 OVERLAP AREA
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = 0.0
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)
                      DEALLOCATE(IZH)
                      DEALLOCATE(IPZ)
                      DEALLOCATE(IPH)
                      DEALLOCATE(IPIP)
                      DEALLOCATE(IPIH)
                      DEALLOCATE(IPIZ)
                  ELSE !3 OVERLAP AREA
                      !POINTS CORRESPONDING TO VERTICES OF POLYGON REQUIRED FOR 3 OVERLAP AREA CALCULATION
                      LOCATOR_IP = IPIP_O
                      LOCATOR_IH = IPIH_O
                      LOCATOR_IZ = IPIZ_O
                      !DECIDE IF POLYGON WITHIN 3 OVERLAP AREA IS FORMED BY 3 OR 4 POINTS
                      IF ((LOCATOR_IH.EQ.0).AND.(LOCATOR_IP.NE.0)
     &                    .AND.(LOCATOR_IZ.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 4 POINTS
                          ALLOCATE(POINTS_IP(2,2))
                          CALL INTERSECTION_POINTS(RZ,RH,
     &                                             M2(1,1),M2(1,2),
     &                                             M2(2,1),M2(2,2),     
     &                                             XP,YP,
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IP(1,:) = [X1_12, Y1_12]
                          POINTS_IP(2,:) = [X2_12, Y2_12]
                          ALLOCATE(POINTS_IZ(2,2))
                          CALL INTERSECTION_POINTS(RH,M1(I,3),
     &                                             M2(2,1),M2(2,2),
     &                                             M1(I,1),M1(I,2),     
     &                                             M2(2,1),M2(2,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IZ(1,:) = [X1_12, Y1_12]
                          POINTS_IZ(2,:) = [X2_12, Y2_12]
                          !3 OVERLAP AREA
                          CALL OVERLAP4(POINTS_IP,POINTS_IZ,
     &                                  RH,RZ,M1(I,3),Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IP)
                          DEALLOCATE(POINTS_IZ)
                      ELSEIF ((LOCATOR_IZ.EQ.0).AND.(LOCATOR_IP.NE.0)
     &                       .AND.(LOCATOR_IH.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 4 POINTS
                          ALLOCATE (POINTS_IP(2,2))
                          CALL INTERSECTION_POINTS(RZ,RH,
     &                                             M2(1,1),M2(1,2),
     &                                             M2(2,1),M2(2,2),     
     &                                             XP,YP,
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IP(1,:) = [X1_12, Y1_12]
                          POINTS_IP(2,:) = [X2_12, Y2_12]
                          ALLOCATE(POINTS_IH(2,2))
                          CALL INTERSECTION_POINTS(M1(I,3),RZ,
     &                                             M1(I,1),M1(I,2),
     &                                             M2(1,1),M2(1,2),     
     &                                             M1(I,1),M1(I,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IH(1,:) = [X1_12, Y1_12]
                          POINTS_IH(2,:) = [X2_12, Y2_12]
                          !3 OVERLAP AREA
                          CALL OVERLAP4(POINTS_IP,POINTS_IH,
     &                                  RZ,RH,M1(I,3),Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IP)
                          DEALLOCATE(POINTS_IH)
                      ELSEIF ((LOCATOR_IP.EQ.0).AND.(LOCATOR_IZ.NE.0)
     &                       .AND.(LOCATOR_IH.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 4 POINTS    
                          ALLOCATE (POINTS_IZ(2,2))
                          CALL INTERSECTION_POINTS(RH,M1(I,3),
     &                                             M2(2,1),M2(2,2),
     &                                             M1(I,1),M1(I,2),     
     &                                             M2(2,1),M2(2,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IZ(1,:) = [X1_12, Y1_12]
                          POINTS_IZ(2,:) = [X2_12, Y2_12]
                          ALLOCATE(POINTS_IH(2,2))
                          CALL INTERSECTION_POINTS(M1(I,3),RZ,
     &                                             M1(I,1),M1(I,2),
     &                                             M2(1,1),M2(1,2),     
     &                                             M1(I,1),M1(I,2),
     &                                             X1_12,Y1_12,
     &                                             X2_12,Y2_12)
                          POINTS_IH(1,:) = [X1_12, Y1_12]
                          POINTS_IH(2,:) = [X2_12, Y2_12]
                          !3 OVERLAP AREA
                          CALL OVERLAP4(POINTS_IZ,POINTS_IH,
     &                                  M1(I,3),RH,RZ,Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IH)
                          DEALLOCATE(POINTS_IZ)
                      ELSEIF ((LOCATOR_IP.EQ.0).AND.(LOCATOR_IH.EQ.0)
     &                       .AND.(LOCATOR_IZ.NE.0)) THEN !3 OVERLAP AREA CORRESPOND TO PRO-HET 2 OVERLAP AREA
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_1(I,2)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                      ELSEIF ((LOCATOR_IP.NE.0).AND.(LOCATOR_IH.NE.0)
     &                       .AND.(LOCATOR_IZ.NE.0)) THEN !3 OVERLAP AREA WITH POLYGON FORMED BY 3 POINTS
                          ALLOCATE (POINTS_IH(1,2))
                          ALLOCATE (POINTS_IZ(1,2))
                          ALLOCATE (POINTS_IP(1,2))
                          POINTS_IH(1,:) = IPZ(LOCATOR_IH,:)
                          POINTS_IZ(1,:) = IPH(LOCATOR_IZ,:)
                          POINTS_IP(1,:) = IZH(LOCATOR_IP,:)
                          !3 OVERLAP AREA
                          CALL OVERLAP3(POINTS_IH,POINTS_IP,POINTS_IZ,
     &                                  M1(I,3),RZ,RH,Ao3)
                          Ao3_F(I,1) = Ao3
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                          DEALLOCATE(POINTS_IP)
                          DEALLOCATE(POINTS_IH)
                          DEALLOCATE(POINTS_IZ)
                      ELSE
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = 0.0
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)
                          DEALLOCATE(IZH)
                          DEALLOCATE(IPZ)
                          DEALLOCATE(IPH)
                          DEALLOCATE(IPIP)
                          DEALLOCATE(IPIH)
                          DEALLOCATE(IPIZ)
                      ENDIF
                  ENDIF
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF (RZ.GE.RH) THEN ![4] ZOI >= HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (RH.GT.RZ) THEN ![4] HET > ZOI
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)      
                  ENDIF ![4] END
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.1).AND.(APH.EQ.-1)) THEN ![2] PRO-ZOI PARTIAL OVERLAP, PRO-HET COMPLETE OVERLAP
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0  
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  IF (RH.GE.M1(I,3)) THEN ![4] HET >= PRO
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (M1(I,3).GT.RH) THEN ![4] PRO > HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0      
                  ENDIF ![4] END
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF (RH.GE.M1(I,3)) THEN ![4] HET >= PRO
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (M1(I,3).GT.RH) THEN ![4] PRO > HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0     
                  ENDIF ![4] END
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.-1).AND.(APH.EQ.1)) THEN ![2] PRO-ZOI COMPLETE OVERLAP, PRO-HET PARTIAL OVERLAP   
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0   
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  IF (RZ.GE.M1(I,3)) THEN ![4] ZOI >= PRO
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (M1(I,3).GT.RZ) THEN ![4] PRO > ZOI
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0       
                  ENDIF![4] END
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF (RZ.GE.RH) THEN ![4] ZOI >= HET
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)
                  ELSEIF (RH.GT.RZ) THEN ![4] HET > ZOI
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0     
                  ENDIF ![4] END
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.-1).AND.(APH.EQ.-1)) THEN ![2] PRO-ZOI COMPLETE OVERLAP, PRO-HET COMPLETE OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)    
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  IF ((M1(I,3).GE.RZ).AND.(M1(I,3).GE.RH)) THEN ![4] 
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_2(1,1)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = 0.0    
                  ELSE ![4] 
                      !3 OVERLAP AREA
                      Ao3_F(I,1) = Ao2_1(I,2)
                      !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                      Ao2_PZ(I,1) = 0.0
                      Ao2_PH(I,1) = 0.0
                      Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1) 
                  ENDIF ![4] END
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  IF ((RZ.GE.RH).AND.(RZ.GE.M1(I,3))) THEN ![4]
                      IF (RH.GE.M1(I,3)) THEN ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_1(I,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)      
                      ELSEIF (M1(I,3).GT.RH) THEN  ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0  
                      ENDIF  ![5] END
                  ELSEIF ((RH.GE.RZ).AND.(RH.GE.M1(I,3))) THEN ![4]
                      IF (RZ.GE.M1(I,3)) THEN ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_1(I,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = Ao2_2(1,1)-Ao3_F(I,1)      
                      ELSEIF (M1(I,3).GT.RZ) THEN  ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0  
                      ENDIF  ![5] END
                  ELSEIF ((M1(I,3).GE.RZ).AND.(M1(I,3).GE.RH)) THEN ![4] 
                      IF (RZ.GE.RH) THEN ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = Ao2_1(I,1)-Ao3_F(I,1)
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0      
                      ELSEIF (RH.GT.RZ) THEN  ![5]
                          !3 OVERLAP AREA
                          Ao3_F(I,1) = Ao2_2(1,1)
                          !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                          Ao2_PZ(I,1) = 0.0
                          Ao2_PH(I,1) = 0.0
                          Ao2_ZH(I,1) = 0.0  
                      ENDIF ![5] END
                  ENDIF ![4] END    
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.1).AND.(APH.EQ.0)) THEN ![2] PRO-ZOI PARTIAL OVERLAP, PRO-HET NO OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.0).AND.(APH.EQ.1)) THEN ![2] PRO-ZOI NO OVERLAP, PRO-HET PARTIAL OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.-1).AND.(APH.EQ.0)) THEN ![2] PRO-ZOI COMPLETE OVERLAP, PRO-HET NO OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = Ao2_1(I,1)
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.0).AND.(APH.EQ.-1)) THEN ![2] PRO-ZOI NO OVERLAP, PRO-HET COMPLETE OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSEIF ((APZ.EQ.0).AND.(APH.EQ.0)) THEN ![2] PRO-ZOI NO OVERLAP, PRO-HET NO OVERLAP 
              IF (AZH.EQ.0) THEN ![3] ZOI-HET NO OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = 0.0
              ELSEIF (AZH.EQ.1) THEN ![3] ZOI-HET PARTIAL OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ELSEIF (AZH.EQ.-1) THEN ![3] ZOI-HET COMPLETE OVERLAP
                  !3 OVERLAP AREA
                  Ao3_F(I,1) = 0.0
                  !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
                  Ao2_PZ(I,1) = 0.0
                  Ao2_PH(I,1) = 0.0
                  Ao2_ZH(I,1) = Ao2_2(1,1)
              ENDIF ![3] END
          ELSE ![2] ANY OTHER CASES WHERE NO 3 OVERLAP OCCURS
              !3 OVERLAP AREA
              Ao3_F(I,1) = 0.0
              !2 OVERLAP AREA PRO-ZOI, PRO-HET, ZOI-HET
              Ao2_PZ(I,1) = 0.0
              Ao2_PH(I,1) = 0.0
              Ao2_ZH(I,1) = 0.0        
          ENDIF ![2] END
      ENDDO ![1] END OF: LOOP THROUGH EACH PRO
C     FINAL OVERLAPPING AREA
      !PRO-ZOI
      ALLOCATE(Ao2_PZF(S1,1))
      Ao2_PZF = Ao2_PZ
      !PRO-HET
      ALLOCATE(Ao2_PHF(S1,1))
      Ao2_PHF = Ao2_PH
      !ZOI-HET
      ALLOCATE(Ao2_ZHF(1,1))
      IF (SUM(Ao2_ZH).GT.0.0) THEN
          Ao2_ZHF = Ao2_2(1,1)
          DO I=1,S1
              Ao2_ZHF = Ao2_ZHF-Ao3_F(I,1)
          ENDDO
      ELSE
          Ao2_ZHF = 0.0
      ENDIF
C     CALCULATE ATTRACTIVE FRACTIONAL AREAS
      AF_PZ = SUM(Ao2_PZF)/(PI*RZ**2)
      AF_ZH = SUM(Ao2_ZHF)/(PI*RZ**2)
C     CALCULATE REPULSIVE FRACTIONAL AREAS
      AF_PZH = SUM(Ao3_F)/(PI*RZ**2)
      AF_Z = 1-AF_PZ-AF_ZH-AF_PZH
      END SUBROUTINE FRACTIONAL_AREA

C     SUBROUTINE TO DETERMINE INTERSECTION POINTS BETWEEN 2 OVERLAPPING CIRCLES      
      SUBROUTINE INTERSECTION_POINTS(R1,R2,X1,Y1,X2,Y2,X0,Y0,
     &                               X1_12,Y1_12,X2_12,Y2_12)

      DOUBLE PRECISION R1,R2,X1,Y1,X2,Y2,X0,Y0
      DOUBLE PRECISION R1_2,R2_2,DX12,DY12,D12,D12_2
      DOUBLE PRECISION PHI12,PSI12,OMEGA1_12,OMEGA2_12
      DOUBLE PRECISION X1_12,Y1_12,X2_12,Y2_12
      DATA PI/3.14159265359/

      R1_2 = R1**2
      R2_2 = R2**2 
      DX12 = X2-X1
      DY12 = Y2-Y1 
      D12 = (DX12**2+DY12**2)**0.5
      D12_2 = DX12**2+DY12**2
      IF (DY12.LT.0.0) THEN
          PHI12 = 2*PI-ACOS(DX12/D12)
      ELSE
          PHI12 = ACOS(DX12/D12)
      ENDIF
      PSI12 = ACOS((R1_2+D12_2-R2_2)/(2*R1*D12))
      ARG = (R1_2+D12_2-R2_2)/(2*R1*D12)
      IF (ARG.GE.1.0) THEN
          ARG = 1.0
          PSI12 = ACOS(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          PSI12 = ACOS(ARG)
      ENDIF
      OMEGA1_12 = PHI12 + PSI12
      OMEGA2_12 = PHI12 - PSI12
      X1_12 = DCOS(OMEGA1_12)*R1+X0
      Y1_12 = DSIN(OMEGA1_12)*R1+Y0
      X2_12 = DCOS(OMEGA2_12)*R1+X0
      Y2_12 = DSIN(OMEGA2_12)*R1+Y0  
      
      END SUBROUTINE INTERSECTION_POINTS

C     SUBROUTINE TO DETERMINE INTERSECTIONS POINTS INSIDE A CIRCLE  
      SUBROUTINE INSIDE_CIRCLE(X3,Y3,R3,IP,IPI_1,IPI_2)
      
      DOUBLE PRECISION X3,Y3,R3,DI
      DOUBLE PRECISION, DIMENSION(2,2) :: IP
      INTEGER, ALLOCATABLE :: IPI(:,:)
      INTEGER J,IPI_1,IPI_2
      
      ALLOCATE(IPI(2,1))
      IPI = 0
      DO J=1,SIZE(IP(:,1))
          DI = ((IP(J,1)-X3)**2+(IP(J,2)-Y3)**2)**0.5
          IF (DI.LE.R3) THEN
              IPI(J,1) = 1
          ENDIF
      ENDDO
      IPI_1 = IPI(1,1)
      IPI_2 = IPI(2,1)
      
      END SUBROUTINE INSIDE_CIRCLE

C     SUBROUTINE TO DETERMINE 3 OVERLAP AREA WITH 4 INTERECTION POINTS
      SUBROUTINE OVERLAP4(POINTS_AB,POINTS_CD,R1,R2,R3,Ao3)
      
      DOUBLE PRECISION XA,YA,XB,YB,XC,YC,XD,YD
      DOUBLE PRECISION DX_AB,DY_AB,DX_CD,DY_CD,DX_AC,DY_AC
      DOUBLE PRECISION DX_BD,DY_BD,DX_AD,DY_AD,DX_BC,DY_BC
      DOUBLE PRECISION D_AB,D_CD,D_AC,D_DB
      DOUBLE PRECISION D_AD,D_BC
      DOUBLE PRECISION THETA_AB,THETA_CD,THETA_AC,THETA_BD
      DOUBLE PRECISION AQ_ABCD,ACS_AB,ACS_CD,ACS_AC,ACS_DB
      DOUBLE PRECISION R1,R2,R3,Ao3
      DOUBLE PRECISION, DIMENSION(2,2) :: POINTS_AB,POINTS_CD
      
      !POLYGON COORDINATES
      XA = POINTS_AB(1,1)
      YA = POINTS_AB(1,2)
      XB = POINTS_AB(2,1)
      YB = POINTS_AB(2,2)
      XC = POINTS_CD(1,1)
      YC = POINTS_CD(1,2)
      XD = POINTS_CD(2,1)
      YD = POINTS_CD(2,2)
      !DISTANCE BETWEEN POINTS OF THE POLYGON
      DX_AB = XA-XB
      DY_AB = YA-YB
      DX_CD = XC-XD
      DY_CD = YC-YD
      DX_AC = XA-XC
      DY_AC = YA-YC
      DX_BD = XB-XD
      DY_BD = YB-YD
      DX_AD = XA-XD
      DY_AD = YA-YD
      DX_BC = XB-XC
      DY_BC = YB-YC
      !LONGITUDE OF POLYGON SIDES
      D_AB = (DX_AB**2+DY_AB**2)**0.5
      D_CD = (DX_CD**2+DY_CD**2)**0.5
      D_AC = (DX_AC**2+DY_AC**2)**0.5
      D_BD = (DX_BD**2+DY_BD**2)**0.5
      !LONGITUDE OF POLYGON DIAGONALS
      D_AD = (DX_AD**2+DY_AD**2)**0.5
      D_BC = (DX_BC**2+DY_BC**2)**0.5
      !AREA OF POLYGON (QUADRILATERAL)
      AQ_ABCD = 0.25*(4*D_AD**2*D_BC**2
     &          -(D_AB**2+D_CD**2-D_AC**2-D_BD**2)**2)**0.5
      !ANGLE OF CIRCULAR SEGMENT
      THETA_AB = 2*ASIN(D_AB/(2*R2))
      ARG = D_AB/(2*R2)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AB = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AB = 2*ASIN(ARG)
      ENDIF
      THETA_CD = 2*ASIN(D_CD/(2*R3))
      ARG = D_CD/(2*R3)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_CD = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_CD = 2*ASIN(ARG)
      ENDIF
      THETA_AC = 2*ASIN(D_AC/(2*R1))
      ARG = D_AC/(2*R1)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AC = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AC = 2*ASIN(ARG)
      ENDIF
      THETA_BD = 2*ASIN(D_BD/(2*R1))
      ARG = D_BD/(2*R1)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_BD = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_BD = 2*ASIN(ARG)
      ENDIF
      !AREA OF CIRCULAR SEGMENT
      ACS_AB = 0.5*R2**2*(THETA_AB-DSIN(THETA_AB))
      ACS_CD = 0.5*R3**2*(THETA_CD-DSIN(THETA_CD))
      ACS_AC = 0.5*R1**2*(THETA_AC-DSIN(THETA_AC))
      ACS_BD = 0.5*R1**2*(THETA_BD-DSIN(THETA_BD))
      !TOTAL 3 OVERLAP AREA
      Ao3 = ACS_AB+ACS_CD+ACS_AC+ACS_BD+AQ_ABCD
      
      END SUBROUTINE OVERLAP4
      
C     SUBROUTINE TO DETERMINE 3 OVERLAP AREA WITH 3 INTERECTION POINTS
      SUBROUTINE OVERLAP3(POINTS_A,POINTS_B,POINTS_C,R1,R2,R3,Ao3)
      
      DOUBLE PRECISION R1,R2,R3
      DOUBLE PRECISION R1_2,R2_2,R3_2
      DOUBLE PRECISION DX_AB,DY_AB,DX_BC,DY_BC,DX_AC,DY_AC
      DOUBLE PRECISION D_AB,D_BC,D_AC
      DOUBLE PRECISION THETA_AB,THETA_BC,THETA_AC
      DOUBLE PRECISION S,AT_ABC,ACS_AB,ACS_BC,ACS_ACM,Ao3
      DOUBLE PRECISION, DIMENSION(1,2) :: POINTS_A,POINTS_B,POINTS_C
      
      R1_2 = R1**2
      R2_2 = R2**2
      R3_2 = R3**2
      !DISTANCE BETWEEN POINTS OF THE TRIANGLE
      DX_AB = POINTS_A(1,1)-POINTS_B(1,1)
      DY_AB = POINTS_A(1,2)-POINTS_B(1,2)
      DX_BC = POINTS_C(1,1)-POINTS_B(1,1)
      DY_BC = POINTS_C(1,2)-POINTS_B(1,2)
      DX_AC = POINTS_C(1,1)-POINTS_A(1,1)
      DY_AC = POINTS_C(1,2)-POINTS_A(1,2)
      !LONGITUDE OF TRIANGLE SIDES 
      D_AB = (DX_AB**2+DY_AB**2)**0.5  
      D_BC = (DX_BC**2+DY_BC**2)**0.5
      D_AC = (DX_AC**2+DY_AC**2)**0.5
      ! AREA OF TRIANGLE
      S = 0.5*(D_AB+D_BC+D_AC)
      AT_ABC = (S*(S-D_AB)*(S-D_BC)*(S-D_AC))**0.5
      !ANGLES OF CIRCULAR SEGMENT
      THETA_AB = 2*ASIN(D_AB/(2*R2))
      ARG = D_AB/(2*R2)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AB = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AB = 2*ASIN(ARG)
      ENDIF
      THETA_BC = 2*ASIN(D_BC/(2*R3))
      ARG = D_BC/(2*R3)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_BC = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_BC = 2*ASIN(ARG)
      ENDIF
      THETA_AC = 2*ASIN(D_AC/(2*R1))
      ARG = D_AC/(2*R1)
      IF (ARG.GE.1.0) THEN
          ARG =1.0
          THETA_AC = 2*ASIN(ARG)
      ELSEIF (ARG.LE.-1.0) THEN
          ARG = -1.0
          THETA_AC = 2*ASIN(ARG)
      ENDIF
      !AREA OF CICULAR SEGMENT
      ACS_AB = 0.5*R2_2*(THETA_AB-DSIN(THETA_AB))
      ACS_BC = 0.5*R3_2*(THETA_BC-DSIN(THETA_BC))
      ACS_AC = 0.5*R1_2*(THETA_AC-DSIN(THETA_AC))
      !TOTAL 3 OVERLAP AREA
      Ao3 = AT_ABC+ACS_AB+ACS_BC+ACS_AC
      
      END SUBROUTINE OVERLAP3

!	SUBROUTINE FROM KIRK NELSON AND TIM GINN TO CONVERT UNIFORM DISTRIBUTION WITH RANGE 0 TO 1
!	TO GAUSSIAN DISTRIBUTION WITH ZERO MEAN AND UNIT VARIANCE	
!	Curve fitting of output from ni.f90 (or ni2.f90) which was
!	adapted from Cunningham (1969), Appl. Stat., vol. 18, no. 3
	subroutine calc_ni(bigni,ni)
	implicit none
	DOUBLE PRECISION off1,off2,off3,a,b,c
	DOUBLE PRECISION, intent(in)::bigni
	DOUBLE PRECISION, intent(out)::ni

	off1 = 1
	off2 = 1
	off3 = 1
	a = -1.0
	b = -1.0
	c = -1.0

	IF (bigni<=.001d0) THEN
		ni = -1.37855370200823D19*bigni**6 +
     *		  4.979009889572070D16*bigni**5 -
     *		  7.214759669310110D13*bigni**4 +
     *		  5.395500767177740D10*bigni**3 - 
     *          2.260106114986480D7*bigni**2 +
     *		  5.826517832043450D3*bigni - 4.129164575760240D0
	ELSE IF (bigni>=.001d0 .and. bigni<.01d0) THEN
	    ni = -6.18440506368D12*bigni**6 +
     *		  2.367655494581510D11*bigni**5 - 
     *          3.71327758909687D9*bigni**4 + 
     *		  3.098709790040470D7*bigni**3 - 
     *          1.51794899112573D5*bigni**2 +
     *		  4.96459221152939D2*bigni - 3.45983671935511D0
	ELSE IF (bigni>=.01d0 .and. bigni<.1d0) THEN
		ni = -6.63992198925781D6*bigni**6 + 
     *		  2.55090340507925D6*bigni**5 - 
     *          4.03094347079323D5*bigni**4 +
     *		  3.41189134002463D4*bigni**3 - 
     *          1.71427218447456D3*bigni**2 + 
     *		  5.95899557785023D1*bigni - 2.77770616554113D0
	ELSE IF (bigni>=.1d0 .and. bigni<.5d0) THEN
		ni = -2.07333319758618D1*bigni**4 +
     *		  3.32434759389286D1*bigni**3 - 
     *          2.07730620338030D1*bigni**2 + 
     *		  8.58215179655931D0*bigni - 1.95934743109075D0
	ELSE IF (bigni>=.5d0 .and. bigni<.9d0) THEN
		ni =  2.0720122918894D1*bigni**4 - 
     *		  4.96540631938802D1*bigni**3 +
     *		  4.54066630995313D1*bigni**2 -
     *		  1.61509902781561D1*bigni + 1.63751297685375D0
	ELSE IF (bigni>=.9d0 .and. bigni<.99d0) THEN
		ni = -1*(-6.63992198925781D6*(a*bigni+off1)**6 + 
     *		  2.55090340507925D6*(a*bigni+off1)**5 - 
     *          4.03094347079323D5*(a*bigni+off1)**4 +
     *		  3.41189134002463D4*(a*bigni+off1)**3 - 
     *          1.71427218447456D3*(a*bigni+off1)**2 + 
     *		  5.95899557785023D1*(a*bigni+off1) - 2.77770616554113D0)
	ELSE IF (bigni>=.99d0 .and. bigni<.9996d0) THEN
	    ni = -1*(-6.18440506368D12*(b*bigni+off2)**6 +
     *		  2.367655494581510D11*(b*bigni+off2)**5 - 
     *          3.71327758909687D9*(b*bigni+off2)**4 + 
     *		  3.098709790040470D7*(b*bigni+off2)**3 - 
     *          1.51794899112573D5*(b*bigni+off2)**2 +
     *		  4.96459221152939D2*(b*bigni+off2) - 3.45983671935511D0)
	ELSE
		ni = -1*(+1.37855370200823D19*(c*bigni+off3)**6 +
     *		  4.979009889572070D16*(c*bigni+off3)**5 -
     *		  7.214759669310110D13*(c*bigni+off3)**4 +
     *		  5.395500767177740D10*(c*bigni+off3)**3 - 
     *          2.260106114986480D7*(c*bigni+off3)**2 +
     *		  5.826517832043450D3*(c*bigni+off3) - 4.129164575760240D0)
	END IF
	RETURN
	end subroutine    

!***************************************************************
!            Pacific Northwest National Laboratory
!***************************************************************
!
! NAME:  Module file "random"
!
! VERSION and DATE: 1.0 8-06-98
!
! PURPOSE:  Random number generation
!
! RETURNS:
!
! REQUIRED:
!
! LOCAL VARIABLES:
!
! COMMENTS: 
!
! MOD HISTORY: 
!
!
!***************************************************************
!***************************************************************

      SUBROUTINE generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &nrand)
!	Generates three random numbers from UNIF[0,1]     
	INTEGER i,nrand
	DOUBLE PRECISION :: rnum1, rnum2, rnum3, rnumvec(6)
      DOUBLE PRECISION :: rsign1,rsign2,rsign3
      nrand = 6
!	Set the type of random number generator
!	intrinsinc Fortran r.n. generator for now
!	Call the uniform(0,1) random number generator
        DO i = 1, nrand
          CALL RANDOM_NUMBER(rnumvec(i))
        ENDDO
!	Fill the random number structure
      rsign1 = rnumvec(1) 
      rnum1 = rnumvec(2)
      rsign2  = rnumvec(3)
      rnum2 = rnumvec(4)
      rsign3 = rnumvec(5) 
      rnum3 = rnumvec(6)
!     Assign sign values to rsign variables depending center point of range of distribution 0 to 1
      IF (rsign1.GE.0.5) THEN
        rsign1 = 1.0
      ELSE
        rsign1 = -1.0
      ENDIF
      IF (rsign2.GE.0.5) THEN
        rsign2 = 1.0
      ELSE
        rsign2 = -1.0
      ENDIF
      IF (rsign3.GE.0.5) THEN
        rsign3 = 1.0
      ELSE
        rsign3 = -1.0
      ENDIF
	END SUBROUTINE generate_unif

********************************************************************
C     CLUSTER VERSION function and subroutines:

      character*(*) function chri(i)
c:  returns a character version of the integer i
c:  chri must be declared as character*n in calling routine

      implicit real*8(a-h,o-z)
      character*5 fmt
      character*40 hold
      character*755 cdum
      common/chrcm/fmt,hold,cdum
      fmt='(i40)'
      write(hold,fmt) i
      call chrpak(hold,40,l)
      chri=hold(1:l)
      return
      end

      subroutine chrpak(c,lmax,lc)
C     packs out blanks in a character string whose maximum length is lmax
C     lc is returned as the packed length.

      character*(*) c
      character*800 ct
      common/chrcm/ct
      k=0
      do 10 i=1,lmax
          if(c(i:i).ne.' ') then
            k=k+1
            if(k.gt.800) stop 'abort - maxed out in chrpak'
            ct(k:k)=c(i:i)
          end if
   10 continue
      lc=k
      c=ct(1:lc)
      return
      end
           
C   SUBROUTINE TO INITIALIZE RANDOM SEE DIFFERENT PER EACH IPART AND SYSTEM TIME
      subroutine init_random_seed()
        use iso_fortran_env, only: int64
        implicit none
        integer, allocatable :: seed(:)
        integer :: i, n, un, istat, dt(8), pid, getpid
        integer(int64) :: t
      
        call random_seed(size = n)
        allocate(seed(n))
        ! First try if the OS provides a random number generator
        open(newunit=un, file="/dev/urandom", access="stream", 
     &    form="unformatted", action="read", status="old", iostat=istat)
        if (istat == 0) then
           read(un) seed
           close(un)
        else
           ! Fallback to XOR:ing the current time and pid. The PID is
           ! useful in case one launches multiple instances of the same
           ! program in parallel.
           call system_clock(t)
           if (t == 0) then
              call date_and_time(values=dt)
              t = (dt(1) - 1970) * 365_int64 * 24 * 60 * 60 * 1000 
     &             + dt(2) * 31_int64 * 24 * 60 * 60 * 1000 
     &             + dt(3) * 24_int64 * 60 * 60 * 1000 
     &             + dt(5) * 60 * 60 * 1000 
     &             + dt(6) * 60 * 1000 + dt(7) * 1000 
     &             + dt(8)
           end if
           pid = getpid()
           t = ieor(t, int(pid, kind(t)))
           do i = 1, n
              seed(i) = lcg(t)
           end do
        end if
        call random_seed(put=seed)
      contains
        ! This simple PRNG might not be good enough for real work, but is
        ! sufficient for seeding a better PRNG.
        function lcg(s)
          integer :: lcg
          integer(int64) :: s
          if (s == 0) then
             s = 104729
          else
             s = mod(s, 4294967296_int64)
          end if
          s = mod(s * 279470273_int64, 4294967291_int64)
          lcg = int(mod(s, int(huge(0), int64)), kind(0))
        end function lcg
      end subroutine init_random_seed


	
C 	END CLUSTER FUNCIONS AND SUBROUTINES
**********************************************************************
