      PROGRAM DIFFTEST
C     PARTICLE2DJET-GSITORQUE.FOR
C     GSI upgrade to PARTICLE2DJET.FOR by the Particle Trajectory Simulation Class (Eddy Pazmino, Wenjie Huang, Mike Johnson, Huilian Ma, Ercument Avsar, William Johnson)
C     06/15/09
C     IF RLIM IS UNKNOWN RUN FAVORABLE CONDITIONS SIMULATIONS WITH MULTIPLE RLIM TO ACHIEVE CONSISTENT COLLECTOR EFFICIENCIES.
C     IF RLIM IS TOO SMALL, COLLECTOR FFICIENCIES WILL BE NEAR UNITY. IF RLIM IS TOO LARGE THEY WILL BE NEAR ZERO.
C     THEY SHOULD BE CONSISTENT FINITE VALUES WITHIN THE CORRECT RLIM, AND DROP SHARPLY OUTSIDE OF RLIM.
C
C
C     VARIABLES
C     Z = AXIAL DIMENSION
C	R = RADIAL DIMENSION
C     RJET = RADIUS OF JET (m)
C     dT = TIME STEP (seconds)
C     ARRAYMAX = MAXIMUM SIZE OF ARRAY FOR TRAJECTORY OUTPUT
C     ZMAX = DISTANCE THAT MODEL TOP BOUNDARY IS ABOVE THE IMPINGING PLANE (m)
C	AP = RADIUS OF PARTICLE (m)
C	RHOP = DENSITY OF PARTICLE (kg/m3)
C	RHOW = DENSITY OF FLUID (kg/m3)
C	G = GRAVITATIONAL CONSTANT (m/s2)
C	MP IS THE MASS OF THE PARTICLE (kg)
C	ERE0 = DIELECTRIC CONSTANT FOR WATER (C2/J-m)
C	ZETAP = ZETA POTENTIAL OF PARTICLE (V = J/C)
C	ZETAC = ZETA POTENTIAL OF COLLECTOR	(V = J/C)
C	ZETACST = IS THE NOMINAL ZETA POTENTIAL OF THE COLLECTOR (V = J/C)
C	HETDIM = DIMENSION OF DOMAINS OF OPPOSITE CHARGE TO BULK SUBSTRATUM (m)
C	NHET = NUMBER OF HETEROGENOUS DOMAINS PER TILE
C	ECHG = CHARGE ON ELECTRON (C)
C	IS = IONIC STRENGTH (MOL/m3)
C	NIO = NUMBER OF MOLECULES PER m3
C	ZI = VALENCE OF IONS
C	KB = BOLTZMANN CONSTANT (m2-kg/s2-k)
C	T = TEMPERATURE IN K
C	KAPPA = DEBYE LENGTH (1/m)
C	A132 = HAMAKER CONSTANT (J)
C	LAMBDA = CHARACTERISTIC WAVELENGTH OF VDW INTERACTION (m)
C	H = SEPARATION DISTANCE (Z-AP = m)
C	HBAR = DIMENSIONLESS SEPARATION DISTANCE ((Z-AP)/AP)
C	VJET = AVERAGE VELOCITY OF JET (m/s)
C	ALPHA = DIMENSIONLESS FLUID INTENSITY PARAMETER DESCRIBING FLOW FIELD
C	FUN = UNIVERSAL HYDRODYNAMIC FUNCTIONS
C	VISC = VISCOSITY (kg/m-s)
C	DSE = STOKES-EINSTEIN DIFFUSION COEFFICIENT
C	FG = GRAVITATIONAL FORCE
C	FVDW = VAN DER WAALS FORCE
C	FEDL = ELECTROSTATIC DOUBLE LAYER FORCE
C	FDRGZ = DRIVING HYDRODYNAMIC DRAG FORCE IN Z DIMENSION
C	FDRGR = DRIVING HYDRODYNAMIC DRAG IN R DIMENSION
C	FRESZ = RESISTING HYDRODYNAMIC DRAG IN Z DIRECTION
C	FRESR = RESISTING HYDRODYNAMIC DRAG IN R DIRECTION 
C	MP IS THE MASS OF THE PARTICLE (kg)
C	MASSVRT IS THE VIRTUAL MASS OF THE PARTICLE (1/2 MASS OF DISPLACED FLUID)(kg)
C	VZ = AXIAL FLUID VELOCITY (m/s)
C	VX = X COMPONENT FLUID VELOCITY (m/s)
C	VY = Y COMPONENT FLUID VELOCITY (m/s)
C	UZ = AXIAL PARTICLE VELOCITY (m/s)
C	UX = X COMPONENT PARTICLE VELOCITY (m/s)
C     UY = Y COMPONENT PARTICLE VELOCITY (m/s)
C	FRCTOL = THE TOLERATED FRACTIONAL CHANGE IN TOTAL FORCE BETWEEN TIME STEPS
C	UTOL = THE TOLERATED FRACTIONAL CHANGE IN VELOCITIES BETWEEN TIME STEPS
C	MULT = TIME STEP MULTIPLIER RELATIVE TO MOMENTUM RELAXATION TIME
C	TTIME = TOTAL TIME FOR FLUX CALCULATION (e.g. INJECTION DURATION) (s)
C	RLIM = LIMITING RADIUS BEYOND WHICH ATTACHMENT IS ZERO IN ABSENCE OF ENERGY BARRIER
C	rnum1 and rnum2 are the two generated random numbers
C	ACONT = AREA OF CONTACT BETWEEN COLLOID AND COLLECTOR
C	BETA = HYSTERESIS LOSS FACTOR
C	KINT = THE INTERACTION PARAMETER WHICH IS COMPRISED OF THE POISSON'S RATIOS AND YOUNG'S MODULI FOR COLLOID AND COLLECTOR
C	FBORN = THE BORN REPULSION FORCE (J/m)
C	SIGMAC = THE WAVELENGTH OF BORN REPULSION THAT SETS THE MINIMUM SEPARATION DISTANCE EQAUL TO 0.157 nm. 
C     PSTEP = NUMBER OF TRANSITIONS FOR DISPLAYING SIMULATION PROGRESS ON SCREEN
C     RMULT = MULTIPLIER FOR RANDOM SEED
C     NPARTSINGLE = THE NUMBER OF PARTICLES USED IN THE SIMULATION (single core version only) - sufficiently large to ensure attachment occurs if possible -cluster version uses separate script to set number of colloids simulated IN ipart VARIABLE
C     PERT = PERTURBATION FLAG, IF TRUE NPARTPERT NEED TO BE INPUT, SET IPART TO THIS VALUE IN CLUSTER VERSION
C     NPARTPER = NUMBER OF PARTICLES ALREADY ATTACHED TO BE SIMULATED FOR DIFFERENT CONDITIONS 
C      
C  
      DIMENSION ZOT(900000)
	DIMENSION ROT(900000)
	DIMENSION FVDWOT(900000),FEDLOT(900000),FCOLLOT(900000)
	DIMENSION FDRGZOT(900000),FDRGROT(900000)
	DIMENSION FDIFZOT(900000)
	DIMENSION AFRACTOT(900000),seed(8),SEEDR(8)
	DIMENSION UZOT(900000),UROT(900000),dTOT(900000)
	DIMENSION VZOT(900000),VROT(900000),rnumvec(2),PTIMEFOT(900000)
      DIMENSION FFRICTOT(900000)
	DIMENSION XOT(900000),YOT(900000),IOT(900000)
	DIMENSION XHET(10000),YHET(10000),RHET(10000)
	DIMENSION XOHET(200000),YOHET(200000),XATT(5000),YATT(5000)
      DIMENSION FDRGXOT(900000),FDRGYOT(900000),VXOT(900000)
      DIMENSION VYOT(900000),UXOT(900000),UYOT(900000)
      DIMENSION FDIFXOT(900000),FDIFYOT(900000)
      DOUBLE PRECISION RJET,ZMAX,AP,RHOP,RHOW,G,ERE0,ZETAP
	DOUBLE PRECISION ZETACST, ECHG,IS,NIO,KB,T,KAPPA,A132,KAPPAH
	DOUBLE PRECISION LAMBDA,VJET,ALPHA,VISC,DSE,MP
	DOUBLE PRECISION A1,B1,C1,D1,E1,A2,B2,C2,D2,E2,A3,B3,C3,D3,E3
	DOUBLE PRECISION A4,B4,C4,D4,E4,FUN1,FUN2,FUN3,FUN4
	DOUBLE PRECISION Z,R,dT,ZO,ZOT,ROT,dTOT,dTMAX,dTMIN
	DOUBLE PRECISION ZETAC
	DOUBLE PRECISION FG,FVDW,FVDWOT,VM
	DOUBLE PRECISION FEDL,FEDLOT,FCOLL,FCOLLO,FCOLLOT
	DOUBLE PRECISION FDRGZ,FDRGZOT,FDRGR,FDRGROT
	DOUBLE PRECISION VZCHK,VRCHK,VTCHK,VTOL,FRCCHK,FRCTOL,VOL
	DOUBLE PRECISION VZ,VZO,VZOT,VR,VRO,VROT,UZ,UX,UY
	DOUBLE PRECISION UZPRE,URPRE,STEP1,STEP2,STEP3,STEP4,HETDIM,TTIME
	DOUBLE PRECISION H,HO,HBAR,MRT,MULT,MULT2,dTMRT
	DOUBLE PRECISION HOUT,ROUT,PTIMEF,PTIMEFOT,PTIME,FLUX
	DOUBLE PRECISION X,Y,XO,YO,XOT,YOT,UXO,UYO,UZO,UR,URO
	DOUBLE PRECISION XHET,YHET,RLIM,XDIS,YDIS,XOUT,YOUT,RNEAR
	DOUBLE PRECISION RINIT,XINIT,YINIT,PTIMEF1,SEP,TIMEINT
	DOUBLE PRECISION XIHET,YIHET,XATT,YATT,XDIS2,YDIS2,FGSI
	DOUBLE PRECISION XOHET,YOHET,ZETAHET,FCOLLPRE
	DOUBLE PRECISION CORF,FSHRT,TSHRY,FTRT,FROT,TTRY,TROY
	DOUBLE PRECISION ACONT,BETA,KINT,FBORN,SIGMAC,M3,M4,FNORM
      DOUBLE PRECISION XOFF,YOFF,XGRIDR,YGRIDR
      DOUBLE PRECISION TSIZE,REXIT	
      DOUBLE PRECISION  rnum3,randm3,FDIDXO,FDIFYO
      DOUBLE PRECISION FDRGX,FDRGY,UNVJX,UNVJY
      DOUBLE PRECISION VX,VY,FDRGXOT,FDRGYOT,VXOT,VYOT,UXOT,UYOT
      DOUBLE PRECISION UZOT,FDIFXOT,FDIFYOT,EDL2,VDW2,FDIFX,FDIFY,FDIFZ
      DOUBLE PRECISION DIFFDECAY
      DOUBLE PRECISION RHET,RZOI,FLN,AREAHET,AFRACT,AFRACTOT
      DOUBLE PRECISION AFAC,AFMAX,AFAVG   
      DOUBLE PRECISION RNUMHET
	DOUBLE PRECISION rnum1, rnum2
	DOUBLE PRECISION bigni,ni,randm1,randm2
      DOUBLE PRECISION rsign1,rsign2,rsign3
      DOUBLE PRECISION FDIFZOT
      DOUBLE PRECISION FFRICT
      DOUBLE PRECISION HMIN,HFMIN,HMAX,FMAX,HFMAX,H2MIN,HF2MIN
      DOUBLE PRECISION F2MIN,MULT3
      DOUBLE PRECISION XCHK,YCHK,ZCHK
      DOUBLE PRECISION DISPMAX,TDISPMAX,DISP,TDISP,MULTDISP,MULTMAX
      DOUBLE PRECISION N1,F1,F2,M1,M2,P1,P2,EVDW,EEDL,EEDLMEAN,EEDLHET
      DOUBLE PRECISION ECOLL,ECOLLO,FFACTOR
      DOUBLE PRECISION FSTE,ESTE,WO,LO,DELTASEP
      DOUBLE PRECISION FMAXSTE,HFMAXSTE,HFRICT,TNEAR
      DOUBLE PRECISION XTEMP,YTEMP,RVEC,TMAX,TIMEOUT,TIMEOUT1,TIMEOUT2
      DOUBLE PRECISION TFACT
C
      INTEGER XGRID,YGRID,PSTEP,INJCHK,CLUSTER,NPARTSINGLE
      INTEGER RMULT
	INTEGER ZI,NHET,ZETAINDO
	INTEGER ARRAYMAX,NP,NPART,LOG
	INTEGER PI,PI1,SURFCHK,I,K,dTCHG,nrand
	INTEGER ATTACHK,JCHECK,JCOUNT,ICOUNT
	INTEGER AFINAL,HET,HETINT,ADJCHK
	INTEGER FATT,FEXIT,FLEFT,FREMAIN
	INTEGER ADJSTOP,IOT,ICOUNT2,ICOUNT3,SUBCOUNT,KCOUNT
	INTEGER NHET2
	INTEGER INEAR,seed,SEEDR
      INTEGER FFLAG
      INTEGER PERT,NPARTPERT
      
c
C
      CHARACTER DUMMY*20
      CHARACTER FILESINGLE*25

	
		!MC variables declaration, these are need for the cluster version dont delete
       character*40 argv
       character*40 filenam
       integer ipart,ilen
       character*6 chri
       character*10 date, time, zone
       integer iarray(8)
C
C	INPUT FILE INPUT.IN 
      OPEN(3,file="INPUT.IN",status="old")
	READ(3,*) VJET,RJET,REXIT,ZMAX,ALPHA
      READ(3,*)AP,RHOP,ZETAP,ZETACST
      READ(3,*)IS,ZI,A132,LAMBDA,T
      READ(3,*)TTIME,FRCTOL,VTOL,MULT,MULT2
      READ(3,*)HETDIM,NHET,TSIZE,ZETAHET,RLIM
      READ(3,*)SEP,PI1,NP
      READ(3,*)BETA,KINT
      READ(3,*)WO,LO,DELTASEP
      READ(3,*)MULTDISP,MULTMAX
      READ(3,*)NPARTSINGLE
      READ(3,*)PERT,NPARTPERT
      READ(3,*) DIFFDECAY
      
	CLOSE(3)

C     SET CLUSTER ZERO FOR SINGLE VERSION AND NUMBER OF PARTICLES HERE
C     SET CLUSTER  = 1 TO MAKE THE CODE ABLE TO COMPILE IN THE CLUSTERS
      CLUSTER = 1 !! 
C
C     OUTPUT TRAJECTORIE FOR A SINGLE PARTICLE FOR DIAGNOSIS IF RUNNING IN SINGLE CORE,
      IF (CLUSTER.EQ.0) THEN
       !! OPEN(66,file="TEMP.OUT",status="REPLACE")   
      END IF  

C     READ LOCATIONS AND RADII OF HETERODOMAINS IN TILE FILE
	IF (NHET.GT.0) THEN
        OPEN(4,file="TILE.DAT",status="old")
        DO 700 K=1,NHET
             READ(4,*) DUMMY,DUMMY,XHET(K),YHET(K),RHET(K)
              !PRINT *,K,XHET(K),YHET(K),RHET(K)
700     CONTINUE
        K=K-1     
        PRINT *,'TOTAL NUMBER OF HETDOMAINS PER TILE = ',K, NHET
C       READ *,DUMMY
        CLOSE (4)
        NHET2 = NHET
       ENDIF

C	IF BULK ZETAC AND ZETAP ARE OPPOSITE IN SIGN, THEN SET NHET = 0
	IF (((ZETACST.GE.0.0).AND.(ZETAP.LE.0.0)).OR.
     *((ZETACST.LE.0.0).AND.(ZETAP.GE.0.0))) THEN
		NHET = 0
	ENDIF
C
	DATA VISC/0.000998/,RHOW/998.0/,G/9.81/,ERE0/7.083E-10/
	DATA ECHG/1.60E-19/,KB/1.381E-23/,ARRAYMAX/800000/
	DATA SIGMAC/5.0E-10/
C
C     CALCULATE VIRTUAL MASS COEFFICIENT
      VM = 2.0/3.0*3.1416*(AP**3)*RHOW
C	
!MC read number of particles and ID of particle as a program argument for the cluster version
        IF (CLUSTER .EQ.1) THEN
            call getarg(1,argv)
            read(argv,*)npart
            call getarg(2,argv)
            read(argv,*)ipart
        END IF
        
C     CONDITION FOR SINGLE CORE VERSION       
        IF (CLUSTER.EQ.0) THEN
            npart = NPARTSINGLE
            IF (PERT.EQ.1) THEN
                npart = NPARTPERT
            ENDIF
        END IF
        
C	FIND ENERGY MINIMA AND MAXIMUM
	NIO = IS*2*6.023E23
	KAPPA = ((ECHG**2.0)*NIO*(ZI**2.0)/(ERE0*KB*T))**0.5
	ZETAC=ZETACST

C     CALCULATE RZOI: radius of zone of influence
        RZOI = 2.0*((1/KAPPA)*AP)**0.5  
C
		HMAX = 1.0E-09
        HFMIN = HMAX
        FMIN2 = -1.0
        HFRICT = 5.0e-10
C        READ *,DUMMY
6666   FORMAT (E14.4,2X,E14.4,2X,E14.4,2X,E14.4,2X,E14.4)
        ZETAC = ZETACST
! OPEN COMPILATION FILES ATTACH/EXIT/REMAIN FOR SINGLE CORE VERSION CLUSTER.EQ.0
      IF (CLUSTER.EQ.0) THEN
          OPEN(71,file="EXITPART.OUT",status="replace") 
          OPEN(72,file="ATTPART.OUT",status="replace")
          OPEN(73,file="REMPART.OUT",status="replace")  
          ! WRITE HEADERS
          WRITE (71,75) MULT,ZMAX,RJET,VJET,TTIME,NPARTSINGLE,AP,ALPHA,
     *ZETAP,HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,
     *REXIT
     		  WRITE (71,3078) RLIM,HMAX,H2MIN,HFMIN
          WRITE (71,*)'-PARTICLES EXIT THE SYSTEM VIA FLOW AT REXIT-'
     		  WRITE (71,3064) !WRITE LABELS

          WRITE (72,75) MULT,ZMAX,RJET,VJET,TTIME,NPARTSINGLE,AP,ALPHA,
     *ZETAP,HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,
     *REXIT
     		  WRITE (72,3078) RLIM,HMAX,H2MIN,HFMIN    
          WRITE (72,*)'-PARTICLES ATTACHED-'
          WRITE (72,3064) !WRITE LABELS  
          
          WRITE (73,75) MULT,ZMAX,RJET,VJET,TTIME,NPARTSINGLE,AP,ALPHA,
     *ZETAP,HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,
     *REXIT
     		  WRITE (73,3078) RLIM,HMAX,H2MIN,HFMIN    
          WRITE (73,*)'-PARTICLES REMAINING IN THE SYSTEM AFTER TTIME-'
          WRITE (73,3064) !WRITE LABELS
       ENDIF !(CLUSTER.EQ.0)
C
3064		FORMAT ('HOUT',14X,'RINIT',10X,'XINIT',10X,'YINIT',10X,'RNEAR',
     &  10X,'RFINAL',9X,'PTIMIN',9X,'PTMOUT',9X,'XOUT',11X,'YOUT'
     &  ,14X,'PARTICLE',5X,'ATTACHK',5X,'AFRACT',5X,'AFMAX'
     &  ,5X,'AFACC',5X,'AFAVG',5X,'PTIME',5X,'TNEAR',5X,'PARTCOUNT')    
C
C     INITIAL AND BOUNDARY CONDITIONS
C      
C	R=0 IS THE AXIS OF SYMMETRY, Z=ZMAX IS THE TOP BOUNDARY OF THE MODEL
C	RJET IS THE RIGHTHAND (DOWNSTREAM) BOUNDARY
C
	MP = (4.0/3.0)*(3.1416)*(AP**3)*RHOP
	VOL = VJET*3.1416*(RJET**2.0)*TTIME
	
C	*****************OPEN THE SIX OUTPUT FILES**** PARALLEL VERSION ****************************
C    REMOVE THE !! FROM THE LINES IN THE LINES IN THE SECTION BELOW FOR THE CLUSTER VERSION		
	IF (CLUSTER.EQ.1) THEN 
C	OPEN HETJETTRAJATT.OUT FOR OUTPUT
        filenam='HETJETTRAJATT.'//chri(ipart)//'.OUT'
        call chrpak(filenam,40,ilen)
        OPEN (UNIT=5,FILE=filenam,STATUS='REPLACE')
C
C	OPEN HETJETTRAJREM.OUT FOR OUTPUT
        filenam='HETJETTRAJREM.'//chri(ipart)//'.OUT'
        call chrpak(filenam,40,ilen)
        OPEN (UNIT=15,FILE=filenam,STATUS='REPLACE')
C
C	OPEN HETJETTRAJEX.OUT FOR OUTPUT
        filenam='HETJETTRAJEX.'//chri(ipart)//'.OUT'
        call chrpak(filenam,40,ilen)
        OPEN (UNIT=16,FILE=filenam,STATUS='REPLACE')
C
C	OPEN HETJETFLUXATT.OUT FOR OUTPUT
        filenam='HETJETFLUXATT.'//chri(ipart)//'.OUT'
        call chrpak(filenam,40,ilen)
        OPEN (UNIT=8,FILE=filenam,STATUS='REPLACE')
C
C	OPEN HETJETFLUXREM.OUT FOR OUTPUT
        filenam='HETJETFLUXREM.'//chri(ipart)//'.OUT'
        call chrpak(filenam,40,ilen)
        OPEN (UNIT=9,FILE=filenam,STATUS='REPLACE')
C
C	OPEN HETJETCFLUXEX.OUT FOR OUTPUT
        filenam='HETJETFLUXEX.'//chri(ipart)//'.OUT'
        call chrpak(filenam,40,ilen)
        OPEN (UNIT=10,FILE=filenam,STATUS='REPLACE')
      END IF
C *****************END OPEN THE SIX OUTPUT FILES****** PARALLEL VERSION **********************C
	
C	SET COEFFICIENTS FOR UNIVERSAL HYDRODYNAMIC FUNCTIONS -UPDATED- JAN 2012
	A1=-0.443
	B1=-1.299
	C1=-0.5568
	D1=-0.32
	E1=0.75
C
	A2=1.455
	B2=-1.259
	C2=0.7951
	D2=-0.56
	E2=0.50 
C
	A3=-0.5
	B3=-2.5
	C3=-0.3
	D3=-20.0
	E3=0.5
C
	A4=-0.42
	B4=-0.35
	C4=-0.40
	D4=-10.0
	E4=0.80

C	RESET J-LOOP PARAMETERS
	PEXIT = 0
	PATT = 0
	PLEFT = 0
	FEXIT = 0
	FATT = 0
	FREMAIN = 0
	ATTACHK = 0
	JCOUNT = 0
C

C	LOOP THROUGH PARTICLES
     
C	RETURN POINT FOR J-LOOP (PARTICLES) PARALLEL VERSION
	J=ipart !!
	
C	RETURN POINT FOR J-LOOP (PARTICLES) SINGLE CORE VERSION	
!!	DO 100 J=1,NPART !! comment out for cluster version !!

C       OPEN ATTACHED PARTICLES FLUX FILE TO OBTAIN ATTAHMENT LOCATIONS TO SET INITIAL POSITION OF PARTICLES
        IF (PERT.EQ.1) THEN  
            OPEN(99,file="HETJETFLUXATTO.IN",status="OLD")  
        ENDIF
	
	IF (CLUSTER.EQ.0) THEN	
C	*****************OPEN THE SIX OUTPUT FILES**** SINGLE CORE VERSION ****************************	
C	OPEN HETJETTRAJATT.OUT FOR OUTPUT
9005		FORMAT ('HETJETTRAJATT.',I0,'.OUT')
		WRITE(FILESINGLE,9005) J
		OPEN (UNIT=5,FILE=FILESINGLE,STATUS='REPLACE')
C	OPEN HETJETTRAJATT.OUT FOR OUTPUT
9015		FORMAT ('HETJETTRAJREM.',I0,'.OUT')
		WRITE(FILESINGLE,9015) J
		OPEN (UNIT=15,FILE=FILESINGLE,STATUS='REPLACE')
C	OPEN HETJETTRAJEX.OUT FOR OUTPUT
9016		FORMAT ('HETJETTRAJEX.',I0,'.OUT')
		WRITE(FILESINGLE,9016) J
		OPEN (UNIT=16,FILE=FILESINGLE,STATUS='REPLACE')
C	OPEN HETJETFLUXATT.OUT FOR OUTPUT		
9008		FORMAT ('HETJETFLUXATT.',I0,'.OUT')
		WRITE(FILESINGLE,9008) J
		OPEN (UNIT=8,FILE=FILESINGLE,STATUS='REPLACE')
C	OPEN HETJETFLUXREM.OUT FOR OUTPUT	
9009		FORMAT ('HETJETFLUXREM.',I0,'.OUT')
		WRITE(FILESINGLE,9009) J
		OPEN (UNIT=9,FILE=FILESINGLE,STATUS='REPLACE')
C	OPEN HETJETFLUXEX.OUT FOR OUTPUT		
9010		FORMAT ('HETJETFLUXEX.',I0,'.OUT')
		WRITE(FILESINGLE,9010) J
		OPEN (UNIT=10,FILE=FILESINGLE,STATUS='REPLACE')	
C	*****************OPEN THE SIX OUTPUT FILES**** SINGLE CORE VERSION  END **********************	
	END IF


	WRITE (5,75) MULT,ZMAX,RJET,VJET,TTIME,NPART,AP,ALPHA,ZETAP,
     *HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,REXIT
     &,LO,WO
        WRITE (15,75) MULT,ZMAX,RJET,VJET,TTIME,NPART,AP,ALPHA,ZETAP,
     *HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,REXIT
     &,LO,WO
        WRITE (16,75) MULT,ZMAX,RJET,VJET,TTIME,NPART,AP,ALPHA,ZETAP,
     *HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,REXIT
     &,LO,WO
        WRITE (8,75) MULT,ZMAX,RJET,VJET,TTIME,NPART,AP,ALPHA,ZETAP,
     *HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,REXIT
     &,LO,WO
        WRITE (9,75) MULT,ZMAX,RJET,VJET,TTIME,NPART,AP,ALPHA,ZETAP,
     *HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,REXIT
     &,LO,WO
        WRITE (10,75) MULT,ZMAX,RJET,VJET,TTIME,NPART,AP,ALPHA,ZETAP,
     *HETDIM,NHET,MULT2,FRCTOL,VTOL,IS,ZETACST,ZETAHET,BETA,KINT,REXIT
     &,LO,WO

75	FORMAT ('MULT = ',E11.4,2X,'ZMAX(m)= ',
     *E11.4,2X,'RJET(m)= ',E11.4,2X,'VJET(m/s)= ',E11.4,2X,
     *'TTIME(s)= ',E10.4,2X,'NPART= ',I6,2X,'AP= ',E10.4,/,
     *'ALPHA= ',E10.4,2X,'ZETAP(V)= ',E10.4,2X,
     *'HETDIM= ',E10.4,2X,'NHET= ',I10,2X,'MULT2 = ',E11.4,2X,
     *'FRCTOL = ',E10.4,2X,'VTOL = ',E10.4,/,
     *'IS = ',E10.4,2X,'ZETACST = ',E10.4,2X,'ZETAHET =', E10.4,2X,
     *'BETA= ',E10.4,2X,'KINT= ',E10.4,2X,'REXIT(m)= ',E10.4,2X,
     &'LAMBDA0(m)= 'E10.4,2X,'W0(J/m2)= ',E10.4)
C     
		WRITE (8,3078) RLIM,HMAX,H2MIN,HFMIN
3078		FORMAT ('RLIM= ',E10.4,2X,'HMAX= ',E10.4,2X,'H2MIN= ',E10.4,2X,
     &          'HFMIN= ',E10.4)
		WRITE (8,3450)
3450		FORMAT ('PARTICLES ATTACHED BEFORE TTIME EXCEEDED') 
		WRITE (8,3063) 
3063		FORMAT ('HOUT',14X,'RINIT',10X,'XINIT',10X,'YINIT',10X,'RNEAR',
     &  10X,'RFINAL',9X,'PTIMIN',9X,'PTMOUT',9X,'XOUT',11X,'YOUT'
     &  ,14X,'PARTICLE',5X,'ATTACHK',5X,'AFRACT',5X,'AFMAX',
     &  5X,'AFACC',5X,'AFAVG',5X,'PTIME',5X,'TNEAR')
		WRITE (10,3078) RLIM,HMAX,H2MIN,HFMIN
3079		FORMAT ('RLIM= ',E10.4)
		WRITE (10,3451)
3451		FORMAT ('PARTICLES EXITED BEFORE TTIME EXCEEDED') 
		WRITE (10,3063) 
        WRITE (9,3078) RLIM,HMAX,H2MIN,HFMIN
		WRITE (9,3452)
3452		FORMAT ('PARTICLES REMAINED AT THE END OF THE SIMULATION') 
		WRITE (9,3063) 

c     INITIALIZE SEED FRO RANDOM NUMBER GENERATOR DEPENDENT OF PARTICLE NUMBER AND SYSTEM TIME (check ipart and RMULT)
      RMULT = 123456
      call date_and_time(date,time,zone,iarray)
        do k = 1,8
           seed(k) = iarray(9-k)*(12+k*7) - 5*k
           SEEDR(k) = seed(k) * 3.0
             !write(49,*)'seed is',seed
        enddo
      CALL RANDOM_SEED(PUT = SEEDR(1:8))
C
C     RESET I-LOOP PARAMETERS
	DO 20 I=1,ARRAYMAX
		ZOT(I) = 0.0
		ROT(I) = 0.0
		XOT(I) = 0.0
		YOT(I) = 0.0
		FVDWOT(I) = 0.0
		FEDLOT(I) = 0.0
		FCOLLOT(I) = 0.0
        FFRICTOT(I)=0.0
		VZOT(I) = 0.0
		VROT(I) = 0.0
		VXOT(I) = 0.0
		VYOT(I) = 0.0
		UZOT(I) = 0.0
		UROT(I) = 0.0
		UXOT(I) = 0.0
		UYOT(I) = 0.0		
		PTIMEFOT(I) = 0.0
		dTOT(I) = 0.0
		FDIFZOT(I) = 0.0
		FDRGZOT(I) = 0.0
		FDRGROT(I) = 0.0		
		FDRGXOT(I) = 0.0
        FDRGYOT(I) = 0.0
		AFRACTOT(I) =0
		TORQCHK = 0.0
		FBORN = 0
		FNORM = 0
		INEAR = 0
		RNEAR = REXIT
20	CONTINUE
C
C	CALCULATE MOMEMTUM RELAXATION TIME 
	dTMRT = MP/(6*3.1416*VISC*AP)
C	MAINTAIN dT LESS THAN dTMAX
	dTMAX = MULT*dTMRT
C
C	MAINTAIN dT GREATER THAT MOMENTUM RELAXATION TIME
	dTMIN = MULT2*dTMRT

C      SET INITIAL TIME STEP
	dT = dTMAX
C     SET MAXIMUM DISPLACMENT AND TIME FOR PARTICLE RETENTION CRITERIA (ATTACHK = 4)
      DISPMAX = MULTDISP*AP
      TDISPMAX = MULTMAX*dTMRT
!        IF (TDISPMAX.LT.(10.0*dTMRT))THEN
!            PRINT *,'MULTMAX TOO SMALL, DEFAULT SET TO 1E6'
!            TDISPMAX = 1E6*dTMRT
!        ENDIF
C     RESET DISPLACEMENT AND DISPLACEMENT TIME USED FOR ATTACHK = 4 CONDITION
      DISP = 0.0
      TDISP = 0.0
C
C     CALCULATE TIMES FOR OUTPUTTING POSITION
C     CALCULATE FACOTR TO GEOMETRIC TIME INTERVALS FOR OUTPUT
      TIMEOUT1 = 0.1*TTIME !SET INITIAL TIME FOR OUTPUT AS A FRACTION OF TOTAL TIME
      TFACT = (TTIME/(TIMEOUT1))**(0.5)
      TIMEOUT2 = TIMEOUT1*TFACT
C     SET FIRST TIMEOUT
      TIMEOUT = TIMEOUT1
C	
C	SET INITIAL PARTICLE TIME (EVENLY DISTRIBUTED THROUGH TIME FOR FLUX) SET MAXIMUM INJECTION TIME HALF OF TOTAL SIMULATION TIME
	PTIMEF = 0.0
	PTIMEF1 = 0.0
      PTIME = 0.0
C
C     RESET NEAR SURFACE RESIDENCE TIME
      TNEAR = 0.0
C     RESET FRACTIONAL AREA METRICS ,AF ACCUMULATED AND AFMAX
      AFAC = 0.0
      AFMAX = 0.0
      AFAVG = 0.0
      AFMAX = 0.0
C     
C	SET TIME INTERVAL TO PRINT PROGRESS TO SCREEN
	TIMEINT = (TTIME-PTIMEF1)/10
C
C	SET TIME STEP ADJUSTMENT LOOP COUNTER
	ADJSTOP = 1
C
	ADJCHK = 0
C
C	RESET ATTACHMENT INDICATOR
	ATTACHK = 0
C
C	SET INITIAL POSITIONS
	Z = ZMAX
	H = Z - AP
	HOUT = 999
	ROUT = 999

C	SET INITIAL PARTICLE POSITIONS
C	SET SAME INITIAL POSITIOIN THE CENTER OF THE CELL
      X = 0.0
      Y = 0.0
      Z = 1.03E-3/2.0
      H = Z-AP
C
	RINIT = R
	XINIT = X
	YINIT = Y
      ZINIT = Z
c     SET CHECK LOCATIONS TO EVALUATE PARTICLE DISPLACEMENT
      XCHK = X
      YCHK = Y
      ZCHK = Z

C     FIND ATTACHED PARTICLE POSITION IN FLUX FILE , THIS ESTRUCTURE WORKS FOR BOTH CLUSTER AND SINGLE CORE VERSION (J= ipart set above)
      IF (PERT.EQ.1) THEN
        DO I=1,6 !REMOVE HEADER
            READ (99,*)DUMMY
        ENDDO
        DO I=1,J
           IF (I.EQ.J) THEN
           READ(99,*) H,DUMMY,DUMMY,DUMMY,DUMMY,DUMMY,
     &                DUMMY,DUMMY,XINIT,YINIT
            X = XINIT
            Y = YINIT
            Z = H+AP 
            RINIT = (XINIT*XINIT+YINIT*YINIT)**0.5 
            R = RINIT
           ELSE
            !SKIP PREVIOUS PARTICLES
            READ (99,*) DUMMY
           ENDIF  
        END DO


      ENDIF !(PERT.EQ.1)

      ! FOR TESTING ADHESION ONLY
!       XINIT = 1.0E-6
!       YINIT = 1.0E-6
!       Z = AP + 5.0E-9
!       H = Z - AP
       ! 
C
C	SET VARIOUS I-LOOP COUNTERS (TRANSLATIONS)  
	I = 1
C
C	COUNTER FOR OUTPUT TO ARRAY
	ICOUNT = 1
C
C	COUNTERS FOR OUTPUT OF PROGRESS TO SCREEN
	ICOUNT2 = 1
	ICOUNT3 = 1	
c     RESET FLAG THAT INDICATES FRICTION FORCE CALCULATION
      FFLAG = 0
C     RECORD INITIAL POSITONS TO TEST THE INJECTION POINTS
!	IF (I.EQ.1) THEN
!	WRITE (20,2020)J,RINIT,XINIT,YINIT
!	ELSE
!	END IF
2020  FORMAT ('J=',2X,I4,2X,'RINIT=',2X,E10.4,2X,'XINIT='
     &,2X,E10.4,2X, 'YINIT=',2X,E10.4)
	
	
C     SET NUMBER OF TRANLATIONS TO DISPLAY PROGRESS ON SCREEN
      PSTEP = 1000000
C	CALCULATE DISPLACEMENT BASED ON ESTIMATED UX, UY AND UZ
C	RETURN POINT FOR I-LOOP (TRANSLATIONS)
      DO WHILE (PTIME.LT.(1.01*TTIME))
C      
	IF (I.GT.1) THEN
		Z = ZO+(UZ*dT)
		X = XO+(UX*dT)
		Y = YO+(UY*dT)
		R = (X*X+Y*Y)**0.5
		H = Z - AP
C
		 IF (H.LT.0.0) THEN
			H = 2.0E-10
			Z = AP+H 
			!WRITE (*,*) 'SET NEGATIVE -H TO +H'
		 ENDIF
	ENDIF !(I.GT.1)
	
C	RESET ICOUNT3 TO PRINT PROGRESS ON SCREEN EVERY PSTEP TRANSLATIONS
      IF (ICOUNT3.GT.PSTEP)THEN
        ICOUNT3 = 1
      ENDIF
C
C	CALC FORCES
C
C	CALC G (OPERATES IN AXIAL DIMENSION ONLY)
	FG = 0.0
C
C     IF OUT OF THE FLINCO (LINEAR COMBINATION SUBROUTINE) NO HETDOMAINS ARE COUNTED (-1)
      AFRACT = -1

            
	KAPPAH=KAPPA*H
C	IF HETERODOMAINS PRESENT, AND IF WITHIN 100*KAPPA, THEN CALL GRID SURFACE INTEGRATION ROUTINES FOR HETEROGENEITY
C	THE HYPERBOLIC FUNCTIONS IN dFEDL (dFCONT SUBROUTINE) ARE NOT DEFINED FOR KAPPAH > 100
C	GO TO HETERODMAIN SUBROUTINE IF HETERO-DOMAINS EXIST, RLIM IS NOT BEING CHECKED, 
C     KAPPAH VALID FOR SUBROUTINE EXPRESSIONS, AND SEP DIST < 500 nm 
	IF ((NHET.NE.0).AND.(H.LT.5.0E-7)) THEN   
C     CALCULATE RZOI: radius of zone of influence
        RZOI = 2.0*((1/KAPPA)*AP)**0.5  
        IF (RZOI.GT.AP) THEN
            RZOI = AP
        END IF  
C      RESET FRACTIONAL AREA OCCUPIED BY HETERODOMAINS IN ZOI
       AFRACT = 0.0
        CALL FLINCO (X,Y,Z,XHET,YHET,RHET,RZOI,
     &  NHET2,ZETACST,AP,A132,IS,ECHG,ZI,ERE0,KB,T,ZETAP,
     &  ZETAHET,LAMBDA,NIO,KAPPA,TSIZE,AREAHET,
     &  AFRACT,FLN,FEDL,FVDW)   
C
		FCOLL = FLN 
	ELSE
C	
C		SET ZETAC = ZETACST
		ZETAC = ZETACST
C
C		CALC VDW (SPHERE-PLANE GEOMETRY)
		FVDW = 0.0
C		CALC EDL FORCES (SPHERE-PLANE GEOMETRY)
			FEDL = 0.0
			IF (ABS(FEDL).LT.1.0E-30) THEN
				FEDL = 0.0
			ENDIF
	ENDIF !((NHET.NE.0).AND.(H.LT.5.0E-7))
C 	ADD BORN REPULSION (FORCE DIFFERENTIATED FROM ENERGY GIVEN BY ELIMELECH ET AL. 1998)
	IF (H.LT.1.0E-8) THEN
		FBORN = 0.0
	ELSE
			FBORN = 0.0
	ENDIF
      IF (H.LT.2.0E-8)  THEN
        FSTE = 0.0
      ELSE
        FSTE = 0.0
      ENDIF
C		COMBINE VDW AND ELECTROSTATIC FORCES  AND ENERGIES
		FCOLL = FVDW+FEDL+FSTE
C
C	CALC FLUID VELOCITIES (AXIAL AND RADIAL)
	VZ=0.0
	VR=0.0
C
      IF (I.NE.0) THEN !! NEGATES dT ADJUSTMENT LOOP
        dT = dTMAX
C        !REDUCE dT ONLY WHEN PARTICLE IN CONTACT 
C        !(DIFFUSION IS ZERO SO DONT BIASED FORCE BALANCE WITH dt<dTMRT)
        IF (H.LE.HFRICT)THEN 
            dT = dTMIN
        ELSE
            dT = dTMAX
        ENDIF
        ADJSTOP = 1
      END IF !I.NE.0
C
C	IF dT VALID RECORD CRITICAL VALUES AS VALID "O" VALUES
	IF ((ADJSTOP.EQ.1).OR.(I.EQ.2)) THEN
		XO = X
		YO = Y
        ZO = Z
        HO = H
        FCOLLO = FCOLL
        ECOLLO = ECOLL
		VZO = VZ
		VRO = VR
        UZO = UZ
		UXO = UX
		UYO = UY
C       INCREMENT SIMULATION TIME
        PTIMEF=PTIMEF+dT
c       CURRENT SIMULATION TIME
        PTIME = PTIMEF-PTIMEF1
C       INCREMENT NEAR SURFACE RESIDENCE TIME IF APPLY
        IF (HO.LT.1E-7) THEN
            TNEAR =TNEAR+dT
               IF (AFRACT.GT.0.0) THEN
                    AFAC =AFAC+AFRACT
                    IF (AFRACT.GT.AFMAX) THEN
                        AFMAX = AFRACT
                    ENDIF
               END IF
               AFAVG = AFAC/PTIME
        ENDIF
C
C       EVALUATE DISPLACEMENT FOR RETENTION CONDITION VIA FRICTION
        DISP = ((XO-XCHK)**2.0+(YO-YCHK)**2.0+(ZO-ZCHK)**2.0)**0.5 
        TDISP = TDISP + dT
            IF ((TDISP.LT.TDISPMAX).AND.(DISP.GT.DISPMAX))THEN
                TDISP = 0.0
                DISP = 0.0
                XCHK = XO
                YCHK = YO
                ZCHK = ZO
            END IF   
C
C		RESET ADJUSTMENT COUNTER
		ADJCHK = 0
	ENDIF !ADJSTOP.EQ.1
C
C     IF dT WAS DECREASED ABOVE (ADJSTOP = 0) THEN
C	UX,UY,UZ (AND X,Y,Z) ARE CALCULATED FROM VALID "O" VALUES AND REDUCED dT 
C     ONCE VELOCITY AND FORCE TOLERANCES ARE ACHIEVED, THEN UX,UY,UZ (AND X,Y,Z) ARE ACCEPTED AS "O" VALUES
C
C
C     CALCULATE NON-COLLOIDAL FORCES ONLY WHEN dT IS VALID
	IF (ADJSTOP.EQ.1) THEN

C	    BOUNDARY EFFECTS ON DRAG FORCE
C	    UNIVERSAL HYDRODYNAMIC FUNCTIONS
	    HBAR = HO/AP
	    FUN1=1.0+A1*EXP(B1*HBAR)+C1*EXP(D1*HBAR**E1)
	    FUN2=1.0+A2*EXP(B2*HBAR)+C2*EXP(D2*HBAR**E2)
	    FUN3=1.0+A3*EXP(B3*HBAR)+C3*EXP(D3*HBAR**E3)
	    FUN4=1.0+A4*EXP(B4*HBAR)+C4*EXP(D4*HBAR**E4)
C
C   	    CALCULATE FLUID VELOCITY UNIT VECTORS 
          UNVJX = XO/R 
	    UNVJY = YO/R 
	    VX = VRO*UNVJX
	    VY = VRO*UNVJY
C
C	    CALCULATE DRAG FORCES (AXIAL AND RADIAL). 
	    FDRGZ = FUN2*6.0*3.1416*VISC*AP*VZO
	    FDRGR = FUN3*6.0*3.1416*VISC*AP*VRO
	    FDRGX = FDRGR*UNVJX
	    FDRGY = FDRGR*UNVJY
C
C	    DO NOT CHANGE randm1 OR randm2 IF ADJUSTING dT (AVOID BIASING DIFFUSION)
C   		    CALL SUBROUTINE generate_unif WHICH USES SEED TO GENERATE TWO RANDOM NUMBERS IN 
C    		    THE RANGE 0 TO 1 (UNIFORM DISTRIBUTION) AND WHICH GENERATES NEW SEED
            CALL generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &nrand)
C           USE VALUES FOR randm1 AND randm2 WITHIN 2ND STANDARD DEVIATION
C           ONLY POSITIVE DOMAIN LOWER LIMIT = 0.5 UPPER LIMIT FOR  + 2*STDEV= 0.9771 , SPAN = 0.4543
            rnum1 = rnum1 * 0.4543+ 0.5
            rnum2 = rnum2 * 0.4543+ 0.5
            rnum3 = rnum3 * 0.4543+ 0.5
C    		    CONVERT UNIFORM DISTRIBUTION TO GAUSSIAN DISTRIBUTION WITH ZERO MEAN AND VARIANCE OF UNITY   
		    bigni = rnum1
		    CALL calc_ni(bigni,ni)
		    randm1 = ni*rsign1
c
		    bigni = rnum2
		    CALL calc_ni(bigni,ni)
		    randm2 = ni*rsign2 
c
		    bigni = rnum3   
		    CALL calc_ni(bigni,ni)
		    randm3 = ni*rsign3   
C	
      ENDIF !ADJSTOP.EQ.1
C
C	CALCULATE DIFFUSION FORCE
C     DECAY DIFFUSION CONTRIBUTION IF LESS THAN ONE AP SEPARATION DISTANCE
!      IF (HO.LT.AP) THEN
!        DIFFDECAY = 1.0-(1.0-HO/AP)**0.5
!      ELSE	
!        DIFFDECAY = 1.0     
!      END IF
c     KIM AND ZYDNEY (2004) INDICATE FORMULAS USED ABOVE APPLY TO z AND r AND ARE ADDITIVE 
	FDIFZ = DIFFDECAY*(randm1)*((12.0*3.1416*AP*VISC*KB*T/dT)**0.5)
C     DIFFUSION APPLIED IN 3DIMENSIONS
	FDIFX = DIFFDECAY*(randm2)*((12.0*3.1416*AP*VISC*KB*T/dT)**0.5)
	FDIFY = DIFFDECAY*(randm3)*((12.0*3.1416*AP*VISC*KB*T/dT)**0.5)

C	CALCULATE PARTICLE VELOCITIES
C
C	IF I = 1 THEN ASSUME STEADY STATE FOR THIS STEP
	IF (I.EQ.1) THEN
		UZ = FUN1*(FG+FCOLLO+FBORN+FDRGZ+FDIFZ)/
     *	      (6.0*3.1416*VISC*AP)
		UX = ((FUN4*(FDIFX))+(FDRGX))/(6.0*3.1416*VISC*AP)
		UY = ((FUN4*(FDIFY))+(FDRGY))/(6.0*3.1416*VISC*AP)
        UXO = UX
        UYO = UY
        UZO = UZ
         !IF SIMULATING EPRTURBATIONS OF ATTACHED COLLOIDS MAKE VEELOCITIES ZERO
         IF((PERT.EQ.1).AND.(I.EQ.1)) THEN
            UXO = 0
            UYO = 0
            UZO = 0
         ENDIF
	ENDIF
C
C	IF I > 1 THEN DROP STEADY STATE FORMULATION
	IF (I.GT.1) THEN
		STEP1 = (MP+VM)/(MP+VM+6.0*3.1416*VISC*AP*dT/FUN1)
		STEP2 = dT/(MP+VM+6.0*3.1416*VISC*AP*dT/FUN1)
c
C       TUNR OFF DIFFUSION IF FRICTION IF IN CONTACT
        IF (HO.LE.HFRICT) THEN 
            FDIFZ = 0.0
            FDIFX = 0.0
            FDIFY = 0.0
        END IF
C   
  		UZ = (UZO*STEP1) + (FG+FCOLLO+FBORN+FDRGZ+FDIFZ)*STEP2

C      
        STEP3 = (MP+VM)/(MP+VM+6.0*3.1416*VISC*AP*dT/FUN4)
        STEP4 = dT/(MP+VM+6.0*3.1416*VISC*AP*dT/FUN4)
C
		UX = (UXO*STEP3) + (FDIFX+1.0/FUN4*FDRGX)*STEP4
		UY = (UYO*STEP3) + (FDIFY+1.0/FUN4*FDRGY)*STEP4
C       RESET FRICTION FORCE AND FLAG THAT COUNTS TRANSLATIONS INVOLVING SURFACE FRICTION
        FFLAG = 0
        FFRICT = 0.0
C	  NORMAL FORCE USED IN ROLLING FRICTION SET EQUAL TO NON-BORN FORCES, WHICH ARE THE ATTRACTIVE FORCES HOLDING THE COLLOID TO THE SURFACE (PROXY FOR ADHESION FORCE)       
        FNORM = FCOLLO 
C       ADJUST PARTICLE TANGENTIAL VELOCITIES WITH SURFACE FRICTION WHEN ATRACTIVE COLLOIDAL FORCE IS SIGNIFICANT OR CLOSER THAN HFMIN
C       WHILE SURFACE FRICTION UNIT VECTOR CORRESPONDS TO ANTICIPATED DISPLACEMENT VECTOR,
C       THE PARTICLE POSITION IS STILL HO  

C       IF ((FCOLLO.LE.FMIN).AND.(NHET.GT.0)) THEN
c       IF ((HO.LE.HFRICT).AND.(NHET.GT.0)) THEN
        IF (HO.LE.HFRICT) THEN
            FFLAG = 1
c          CALCULATE INTERACTION ENERGIES (VDW AND EDL) IN ORDER TO CALCULATE CONTACT AREA AND COEFFICIENT OF ROLLING FRICTION IF NEEDED
C          SET COEFFICIENTS AND CALCULATE INTERACTION ENERGY FUNCTIONS TO BE USED IN FRICTION ACONT CALCULATION
C          EVDW COEFFICIENTS:
            N1=(A132*AP/6.0)
            F1 = 22.23
            F2 = 11.116
C         VDW INTERACTION ENERGY     
            EVDW = - N1*(F1*LOG(2.0*LAMBDA + 2.0*F2*D) - 
     &      F2*LOG(2.0*LAMBDA + 2.0*F2*H) - F1*LOG(2.0) + F2*LOG(2.0) - 
     &      F1*LOG(F2) + F2*LOG(F2) - F1*LOG(H) + F2*LOG(H)) - 
     &        (LAMBDA*N1)/H
            EVDW = EVDW/(3.1416*AP*AP)   !! CHECK FOR UNIT AREA    

C           EEDL COEFFICIENTS:
            M1 = 16*ERE0*AP*(KB*T/ZI/ECHG)**2.0
C           EDL INTERACTION ENERGY    
            EEDLMEAN = M1*TANH(ZI*ECHG*ZETAC/4/KB/T)*
     &                TANH(ZI*ECHG*ZETAP/4/KB/T)*EXP(-1.0*KAPPA*H)
            EEDL = EEDLMEAN/(3.1416*AP*AP) !! CHECK FOR UNIT AREA 
            EMEAN = EVDW+EEDL

C           STERIC INTERACTION ENERGY    
            ESTE = WO*EXP(-H/LO)*3.1416*AP*AP      
C
C           CALCULATE CORRESPONDING EDL ENERGY CORRESPONFING TO LINEAL AREA COMBINATION IF HETERODOMAINS PRESENT
            IF (AFRACT.GT.0.0) THEN 
C               EDL INTERACTION ENERGY    
                EEDLHET = M1*TANH(ZI*ECHG*ZETAHET/4/KB/T)*
     &                TANH(ZI*ECHG*ZETAP/4/KB/T)*EXP(-1.0*KAPPA*H)
                EEDLHET = EEDLHET/(3.1416*AP*AP) !! CHECK FOR UNIT AREA 
C
                EEDL = EEDLMEAN*(1-AFRACT) + EEDLHET*AFRACT
            END IF
C           COMBINE INTERACTION ENERGIES PER UNIT AREA
            ECOLL = EEDL + EVDW + ESTE/(3.1416*AP*AP)
                   
C
	      ACONT = (6.0*3.1416*(AP**2.0)*ABS(ECOLL)/KINT)**(1.0/3.0) !! ECOLLO DENOTES INTERACTION ENERGY PER UNIT AREA
            CORF = BETA*ACONT*(2.0/(3.0*3.1416*AP))
            FFRICT = FNORM*CORF
            IF (FFRICT.GT.0.0) THEN !IF SURFACE BECOME REPULSIVE DUE TO PERTURBATION FRICTION DOESNT APPLY
                FFRICT = 0.0
            ENDIF
	      !M3 = MP+(2.0/3.0)*3.1416*(AP**3)*RHOW
            M3 = MP !IF VIRTUAL MASSS FORCE IS NOT CONSIDERED IN THE BALANCE
		    M4 = 6.0*3.1416*VISC*AP*dT

		    FSHRT = (1.70073337 + 1.0221606*HO/AP)/(1 + 1.0458291*HO/AP 
     *            - 0.0014884706*(HO/AP)**2)

		    TSHRY= 0.054651334 * (18.276952 - EXP(-1.422943*(HO/AP)))

		    FTRT= -1.0/(0.14116 + 0.5967*(HO/AP)**0.2984)

		    FROT=(0.05826 - 0.06126*(HO/AP)**0.557)/(0.0681 + (HO/AP)**0.557)
		
	    	TTRY=(0.04362 - 0.0459*(HO/AP)**0.557)/(0.06801 + (HO/AP)**0.557)
		
	    	TROY=(0.312373 + 0.739*(HO/AP)**0.4906)/(0.0954 + (HO/AP)**0.4906)
        
            URO=(UXO*UXO+UYO*UYO)**0.5

		    UR = ((URO*M3)+FFRICT*dT+FDRGR*dT*
     *		    (FSHRT+TSHRY*(2.0/3.0)*(AP/(AP+HO))))/
     *		    (M3-M4*(FTRT+FROT*AP+TTRY*(4.0/3.0)+TROY*(4.0/3.0)*AP))

            IF (UR.LE.0.0) THEN
               ! ATTACHK = 2
            END IF

C
            !DIFFUSION FORCE CONTRIBUTION IS ZERO WHEN TORQUE BALANCE IS APLIED (HO<HFRICT), ONLY DRAG ACTS ON PARTICLE THEN:
     		    UX = UR*UNVJX   	
     		    UY = UR*UNVJY 
C
            IF (CLUSTER.EQ.0) THEN !OUTPUT TO EVALUATE ADHESION MECHANISMS
                !! WRITE (66,6600) J,I,XO,YO,ZO,HO,AFRACT,URO !!!
            END IF
6600        FORMAT (I10,2X,I10,2X,E14.8,2X,E14.8,2X,E14.8,2X,E14.8,2X,
     &              E14.8,2X,E14.8)
c       
        END IF !(HO.LE.HMAX).AND.(NHET.GT.0) 		  
	ENDIF !(I.GT.1)
C
	
C
C	RECORD NEAR-SURFACE STEPS IN HETEROGENOUS DOMAINS
C	IF ((ADJSTOP.EQ.1).AND.(HO.LT.2.0E-8)) THEN    
C		WRITE (7,81) J,I,H,R,ZETAC
C81		FORMAT (I10,2X,I10,2X,E14.8,2X,E14.8,2X,E10.4) 
C	ENDIF
C
C	RECORD VALUES AS OLD FOR NEXT LOOP
	IF (ADJSTOP.EQ.1) THEN
C       PRINT PROGRESS TO SCREEN BASED ON PSTEP (NUMBER OF TRANSLATIONS) AND NEAR SURFACE
        IF ((ICOUNT3.EQ.PSTEP).AND.(CLUSTER.EQ.0))   THEN
		    PRINT *,'J = ',J,'H = ',HO,'R =',R,'ELAPSED TIME = ',PTIMEF
!		    PRINT *,'FDIFZ = ',FDIFZ
!		    PRINT *,'VZO = ',VZO,'VRO =',VRO
!            WRITE (66,6600) I,XO,YO,ZO,HO,AFRACT
!6600        FORMAT (I10,2X,E14.8,2X,E14.8,2X,E14.8,2X,E14.8,2X,E14.8)
		END IF
C		PRINT PROGRESS TO SCREEN BASED ON ICOUNT2
		IF((PTIMEF.GE.(PTIMEF1+((ICOUNT2-1)*TIMEINT))).AND.(CLUSTER.EQ.0))THEN
			WRITE (*,109) PTIMEF, TTIME, dT, J
109			FORMAT ('ELAPSED TIME = ',E10.4,2X,'MAX TIME =',E10.4,2X,
     *		'dT =',E10.4,2X,'J =',I6)
			ICOUNT2 = ICOUNT2 + 1
		ENDIF
C
C		OUTPUT ARRAY VALUES
		IF ((HO.LE.2.0E-07).AND.(INEAR.EQ.0)) THEN
			RNEAR = R
			INEAR = 1
		ENDIF
		IF (H.LE.SEP) THEN 
			IF ((I.GT.(ICOUNT-1)*PI1).AND.(ICOUNT.LE.ARRAYMAX)) THEN
				ROT(ICOUNT) = R
				ZOT(ICOUNT) = ZO
				FVDWOT(ICOUNT) = FVDW
				FEDLOT(ICOUNT) = FEDL
				FCOLLOT(ICOUNT) = FCOLLO
                FFRICTOT(ICOUNT) = FFRICT
				FDRGZOT(ICOUNT) = FDRGZ
				FDRGROT(ICOUNT) = FDRGR
				FDRGXOT(ICOUNT) = FDRGX
				FDRGYOT(ICOUNT) = FDRGY				
				FDIFZOT(ICOUNT) = FDIFZ
				FDIFXOT(ICOUNT) = FDIFX
				FDIFYOT(ICOUNT) = FDIFY				
				AFRACTOT(ICOUNT) = AFRACT
				VZOT(ICOUNT) = VZO
				VROT(ICOUNT) = VRO
				VXOT(ICOUNT) = VX
				VYOT(ICOUNT) = VY
				UZOT(ICOUNT) = UZO
				UXOT(ICOUNT) = UXO
                UYOT(ICOUNT) = UYO
				XOT(ICOUNT) = XO
				YOT(ICOUNT) = YO
				dTOT(ICOUNT) = dT
				PTIMEFOT(ICOUNT) = PTIMEF
				IOT(ICOUNT) = I
				ICOUNT = ICOUNT + 1
				!CHECK TO ALLOW OUTPUT IN SCREEN, DONT USE IN CLUSTER
				IF ((NHET.NE.0).AND.
     *			    (H.LE.5.0E-7).AND.(CLUSTER.EQ.0))THEN 
					WRITE (*,*) '   R= ',R,'     H= ',H,' FCOLLO= ', 
     *				FCOLLO,'AFRACT =',AFRACT,'FFRICT =',FFRICT,'DISP = ',DISP,
     &          'TDISP =',TDISP

				ENDIF
			ENDIF !((I.GT.(ICOUNT-1)*PI1).AND.(ICOUNT.LE.ARRAYMAX)) 
		ENDIF  !(H.LE.SEP)
 		I=I+1 !COUNT TRANSLATION STEP
	ENDIF  !(ADJSTOP.EQ.1)
C
C     CONDITION FOR ATTACHMENT	ATTACHK = 2
 	IF ((HO.LT.0.21E-9).AND.(ADJSTOP.EQ.1))	THEN
		ATTACHK = 2
	ENDIF
 	
C     CONDITION FOR RETENTION VIA FRICTION ATTACHK = 4
!      IF ((DISP.LE.DISPMAX).AND.(TDISP.GE.TDISPMAX).AND.
!     & (PTIMEF.LE.TTIME).AND.(ADJSTOP.EQ.1)) THEN
!C
!        ATTACHK = 4
!      END IF
C      
C     OUTPUT TIME INTERVAL FOR EVALUATING DIFFUSION DISPLACEMENT
      IF (PTIME.GE.TIMEOUT)THEN
            TIMEOUT =TIMEOUT2
            ATTACHK = 2
      ENDIF

      IF ((ATTACHK.EQ.2).OR.(ATTACHK.EQ.4)) THEN
		HOUT = HO
		ROUT = R
		XOUT = XO
		YOUT = YO
        ZO = HO+AP
        RVEC =((XO-XINIT)**2.0+(YO-YINIT)**2.0+(ZO-ZINIT)**2.0)**0.5
        ROUT = RVEC
        IF (PTIME.GT.TIMEOUT2) THEN
            TIMEOUT =TTIME
        ENDIF
        IF (PTIME.GT.TTIME) THEN
            TIMEOUT =100*TTIME
        ENDIF
		WRITE (8,3087) HOUT,RINIT,XINIT,YINIT,RNEAR,ROUT,PTIMEF1,PTIMEF,
     *	XOUT,YOUT,J,ATTACHK,AFRACT,AFAC,AFMAX,AFAVG,PTIME,TNEAR
3087		FORMAT (E10.4,5X,E10.4,5X,E10.4,5X,E10.4,5X E10.4,5X,E18.8,5X,
     &E10.4,5X,E10.4,5X,E14.8,5X,E14.8,5X,I10,5X,I5,5X,E10.4,5X,E10.4,
     &5X,E10.4,5X,E10.4,5X,E10.4,5X,E10.4)
	
c     WRITE COMPILED FILE IF CLUSTER.EQ.0 SINGLECORE VERSION
        IF(CLUSTER.EQ.0)THEN
            WRITE (72,3088) HOUT,RINIT,XINIT,YINIT,RNEAR,ROUT,PTIMEF1,
     *       PTIMEF,XOUT,YOUT,J,ATTACHK,AFRACT,AFAC,AFMAX,AFAVG,PTIME,
     &       TNEAR,FATT
3088			FORMAT (E10.4,5X,E10.4,5X,E10.4,5X,E10.4,5X E10.4,5X,E18.8,5X,
     &E10.4,5X,E10.4,5X,E14.8,5X,E14.8,5X,I5,5X,I5,5X,E10.4,5X,E10.4,
     &5X,E10.4,5X,E10.4,5X,E10.4,5X,E10.4,5X,I5)
		END IF
        ATTACHK = 0 !RESET FLAG TO OUTPUT SEVERAL TIMES
	ENDIF !((ATTACHK.EQ.2).OR.(ATTACHK.EQ.4))
C
C     CONDITION TO EXIT, ATTACHK = 1
C	IF NOT IN dT ADJUSTMENT LOOP COUNT PARTICLES THAT EXIT BEFORE TTIME
	IF ((R.GE.REXIT).AND.(PTIMEF.LE.TTIME).AND.(ADJSTOP.EQ.1)) THEN
		ATTACHK = 1
		HOUT = HO
		ROUT = R
		XOUT = XO
		YOUT = YO
     		WRITE (10,3087) HOUT,RINIT,XINIT,YINIT,RNEAR,ROUT,PTIMEF1,PTIMEF,
     *	XOUT,YOUT,J,ATTACHK,AFRACT,AFAC,AFMAX,AFAVG,PTIME,TNEAR
		FEXIT = FEXIT + 1
c     WRITE COMPILED FILE IF CLUSTER.EQ.0 SINGLECORE VERSION		
		IF(CLUSTER.EQ.0)THEN
             WRITE (71,3088) HOUT,RINIT,XINIT,YINIT,RNEAR,ROUT,PTIMEF1,
     *       PTIMEF,XOUT,YOUT,J,ATTACHK,AFRACT,AFAC,AFMAX,AFAVG,PTIME,
     &       TNEAR,FEXIT
        END IF
	ENDIF !((R.GE.REXIT).AND.(PTIMEF.LE.TTIME).AND.(ADJSTOP.EQ.1))
	 	
C	IF NOT IN dT ADJUSTMENT LOOP COUNT PARTICLES THAT REMAIN BEYOND END OF SIMULATION TTIME
	IF ((PTIMEF.GT.(100.0*TTIME)).AND.(ADJSTOP.EQ.1)) THEN !OVERRIDE REMAINING CONDITION
		FREMAIN = FREMAIN + 1
		ATTACHK = 3
				HOUT = HO
                ROUT = R
                XOUT = XO
                YOUT = YO
     		WRITE (9,3087) HOUT,RINIT,XINIT,YINIT,RNEAR,ROUT,PTIMEF1,PTIMEF,
     *	XOUT,YOUT,J,ATTACHK,AFRACT,AFAC,AFMAX,AFAVG,PTIME,TNEAR
C     
C     WRITE COMPILED FILE IF CLUSTER.EQ.0 SINGLECORE VERSION               
        IF(CLUSTER.EQ.0)THEN
             WRITE (73,3088) HOUT,RINIT,XINIT,YINIT,RNEAR,ROUT,PTIMEF1,
     *       PTIMEF,XOUT,YOUT,J,ATTACHK,AFRACT,AFAC,AFMAX,AFAVG,PTIME,
     &       TNEAR,FREMAIN
        ENDIF
	ENDIF !((PTIMEF.GT.TTIME).AND.(ADJSTOP.EQ.1))
C     COUNTER TO DISPLAY PROGRES ON SCREEN
      ICOUNT3 = ICOUNT3 + 1

	ENDDO !(PTIME.LT.(1.01*TTIME))  TRANSLATION LOOP ( I-LOOP BREAKOUT ) 
    	FATT = FATT + 1 !COUNT PARTICLE TO DISPLAY IN COMPILED FLUX FILE (SEVERAL TIMES PER PARTICLE)
C
	ICOUNT = ICOUNT - 1  !REMOVE EXCESS IN PARTICLE OUTPUT COUNTER ONE THE PARTICLE IS RESOLVED
C
	PTIMETOT = PTIMEF-PTIMEF1
	WRITE (*,99) J,RINIT,dTMRT,dT,ATTACHK,PTIMETOT
99	FORMAT ('J= ',I6,2X,'RINIT= ',
     *E8.3,2X,'dTMRT= ',E10.4,2X,'dT= ',E10.4,2X,
     *'ATTACHK =',I1,2X,'PTIMETOT =',E10.4,/)
C

******************************************************************************
*********************ATTCHK = 1 ***********************************************
	IF (ATTACHK.EQ.1) THEN
C	PRINT A PARTICULAR SET OF PARTICLES
C	IF ((J.EQ.26).OR.(J.EQ.28).OR.(J.EQ.83).OR.(J.EQ.86)) THEN
C	PRINT 100 FIRST PARTICLES REGARDLESS OF ATTACHMENT	
C	IF (JCOUNT.LE.100) THEN
!		JCOUNT=JCOUNT+1		
C
		IF (ATTACHK.EQ.1) THEN
 		WRITE(16,2200) 
2200			FORMAT (/,'PARTICLE LEFT SYSTEM VIA FLOW')
		ENDIF
C
		WRITE (16,2800) I,ICOUNT
2800		FORMAT ('# TRANSLATIONS= ',I10,4X,'# IN ARRAY',I10)
C
		WRITE (16,2450)

2450		FORMAT (/,3X,'R'14X,'H',14X,'X',14X,'Y',10X,'FCOLL',10X,'FFRICTT',
     &  10X,'FEDL',11X,'FVDW',11X,'FDIFZ',11X,'FDIFX',11X,'FDIFY',9X,
     &  'UZ',13X,'UX',13X,'UY',13X,'VZ',13X,'VX',13X,'VY',13X,'dT',13X,
     &  'FDRGZ',10X,'FDRGX',10X,'FDRGY',9X,'I',10X,'AFRACT')     
     
C
		IF (ICOUNT.LE.21) THEN
			WRITE(*,*) 'PI2 TOO BIG OR SEP TOO SMALL FOR SIGNIFICANT
     *		TRAJECTORY OUTPUT'
			SUBCOUNT = 0
		ELSEIF (ICOUNT.GT.21) THEN
			SUBCOUNT = 20
		ENDIF
		IPRINT = ICOUNT-SUBCOUNT
C		IPRINT = 5000
		PI = INT(IPRINT/NP)
		IF (PI.EQ.0) THEN
			PI = 1
		ENDIF
C		PI = 1

		DO 2000 I=1,IPRINT,PI
			H = ZOT(I)-AP
		WRITE (16,2500) ROT(I),H,XOT(I),YOT(I),FCOLLOT(I),FFRICTOT(I),
     &  FEDLOT(I),FVDWOT(I),FDIFZOT(I),FDIFXOT(I),FDIFYOT(I),UZOT(I),
     &  UXOT(I),UYOT(I),VZOT(I),VXOT(I),VYOT(I),dTOT(I),FDRGZOT(I),
     &  FDRGXOT(I),FDRGYOT(I),IOT(I),AFRACTOT(I)

2000		CONTINUE

		IF (ICOUNT.GT.21) THEN
			DO 1902 I=IPRINT+1,ICOUNT
				H = ZOT(I)-AP
				
		WRITE (16,2500) ROT(I),H,XOT(I),YOT(I),FCOLLOT(I),FFRICTOT(I),
     &  FEDLOT(I),FVDWOT(I),FDIFZOT(I),FDIFXOT(I),FDIFYOT(I),UZOT(I),
     &  UXOT(I),UYOT(I),VZOT(I),VXOT(I),VYOT(I),dTOT(I),FDRGZOT(I),
     &  FDRGXOT(I),FDRGYOT(I),IOT(I),AFRACTOT(I)

1902			CONTINUE
		ENDIF
	ENDIF
2500		FORMAT(E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4
     *	,2X,E13.4,2X,E13.3,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,
     &2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,E13.4,2X,
     &  I10,2X,E10.4)	
     	
******************************************************************************
******************************************************************************
******************************************************************************
*********************ATTCHK = 3 ***********************************************
	IF (ATTACHK.EQ.3) THEN
C	PRINT A PARTICULAR SET OF PARTICLES
C	IF ((J.EQ.26).OR.(J.EQ.28).OR.(J.EQ.83).OR.(J.EQ.86)) THEN
C	PRINT 100 FIRST PARTICLES REGARDLESS OF ATTACHMENT	
C	IF (JCOUNT.LE.100) THEN
!		JCOUNT=JCOUNT+1		
		IF (ATTACHK.EQ.3) THEN
			WRITE (15,2300) 
2300			FORMAT (/,'PARTICLE REMAINS WITHIN SYSTEM')
		ENDIF
		
		
C
		WRITE (15,2800) I,ICOUNT
C
		WRITE (15,2450)
C
		IF (ICOUNT.LE.21) THEN
			WRITE(*,*) 'PI2 TOO BIG OR SEP TOO SMALL FOR SIGNIFICANT
     *		TRAJECTORY OUTPUT'
			SUBCOUNT = 0
		ELSEIF (ICOUNT.GT.21) THEN
			SUBCOUNT = 20
		ENDIF
		IPRINT = ICOUNT-SUBCOUNT
C		IPRINT = 5000
		PI = INT(IPRINT/NP)
		IF (PI.EQ.0) THEN
			PI = 1
		ENDIF
C		PI = 1

		DO 2002 I=1,IPRINT,PI
			H = ZOT(I)-AP
		WRITE (15,2500) ROT(I),H,XOT(I),YOT(I),FCOLLOT(I),FFRICTOT(I),
     &  FEDLOT(I),FVDWOT(I),FDIFZOT(I),FDIFXOT(I),FDIFYOT(I),UZOT(I),
     &  UXOT(I),UYOT(I),VZOT(I),VXOT(I),VYOT(I),dTOT(I),FDRGZOT(I),
     &  FDRGXOT(I),FDRGYOT(I),IOT(I),AFRACTOT(I)		
			

2002		CONTINUE
		IF (ICOUNT.GT.21) THEN
			DO 1900 I=IPRINT+1,ICOUNT
				H = ZOT(I)-AP
		WRITE (15,2500) ROT(I),H,XOT(I),YOT(I),FCOLLOT(I),FFRICTOT(I),
     &  FEDLOT(I),FVDWOT(I),FDIFZOT(I),FDIFXOT(I),FDIFYOT(I),UZOT(I),
     &  UXOT(I),UYOT(I),VZOT(I),VXOT(I),VYOT(I),dTOT(I),FDRGZOT(I),
     &  FDRGXOT(I),FDRGYOT(I),IOT(I),AFRACTOT(I)
1900			CONTINUE
		ENDIF
	ENDIF
	
******************************************************************************
******************************************************************************
******************************************************************************
*********************ATTCHK = 2,4 *********************************************
	IF ((ATTACHK.EQ.2).OR.(ATTACHK.EQ.4)) THEN
C	PRINT A PARTICULAR SET OF PARTICLES
C	IF ((J.EQ.26).OR.(J.EQ.28).OR.(J.EQ.83).OR.(J.EQ.86)) THEN
C	PRINT 100 FIRST PARTICLES REGARDLESS OF ATTACHMENT	
C	IF (JCOUNT.LE.100) THEN
!		JCOUNT=JCOUNT+1		
		IF ((ATTACHK.EQ.2).OR.(ATTACHK.EQ.4)) THEN
			WRITE (5,2250) 
2250			FORMAT (/,'PARTICLE ATTACHED')
		ENDIF
		
		WRITE (5,2800) I,ICOUNT
		WRITE (5,2450)    	
C
		IF (ICOUNT.LE.21) THEN
			WRITE(*,*) 'PI2 TOO BIG OR SEP TOO SMALL FOR SIGNIFICANT
     *		TRAJECTORY OUTPUT'
			SUBCOUNT = 0
		ELSEIF (ICOUNT.GT.21) THEN
			SUBCOUNT = 20
		ENDIF
		IPRINT = ICOUNT-SUBCOUNT
C		IPRINT = 5000
		PI = INT(IPRINT/NP)
		IF (PI.EQ.0) THEN
			PI = 1
		ENDIF
C		PI = 1
		DO 2001 I=1,IPRINT,PI
			H = ZOT(I)-AP
		WRITE (5,2500) ROT(I),H,XOT(I),YOT(I),FCOLLOT(I),FFRICTOT(I),
     &  FEDLOT(I),FVDWOT(I),FDIFZOT(I),FDIFXOT(I),FDIFYOT(I),UZOT(I),
     &  UXOT(I),UYOT(I),VZOT(I),VXOT(I),VYOT(I),dTOT(I),FDRGZOT(I),
     &  FDRGXOT(I),FDRGYOT(I),IOT(I),AFRACTOT(I)		
			
     
2001		CONTINUE
		IF (ICOUNT.GT.21) THEN
			DO 1901 I=IPRINT+1,ICOUNT
				H = ZOT(I)-AP
		WRITE (5,2500) ROT(I),H,XOT(I),YOT(I),FCOLLOT(I),FFRICTOT(I),
     &  FEDLOT(I),FVDWOT(I),FDIFZOT(I),FDIFXOT(I),FDIFYOT(I),UZOT(I),
     &  UXOT(I),UYOT(I),VZOT(I),VXOT(I),VYOT(I),dTOT(I),FDRGZOT(I),
     &  FDRGXOT(I),FDRGYOT(I),IOT(I),AFRACTOT(I)

1901			CONTINUE
		ENDIF
	ENDIF
******************************************************************************
******************************************************************************

C       CLOSE ATTACHED PARTICLES FLUX FILES TO RELOAD FILE FOR NEXT PARTICLE LOOP
            IF (PERT.EQ.1) THEN  
             CLOSE(99)  
            ENDIF			
C     LOOP FOR SINGLE CORE VERSION (COMMENT OUT FOR PARALLEL VERSION)
!! 100 	CONTINUE  !! comment out for cluster version !!	
C
	END PROGRAM DIFFTEST


C     FOR CLUSTER VERSION REMOVE !! FROM FOLLOWING LINES TO ENABLESUBROUTINE AND FUNCTION TO TRANSFORM FILENAME FORMAT TO BE WRITEN USING CLUSTER FORMAT
      character*(*) function chri(i)
c:  returns a character version of the integer i
c:  chri must be declared as character*n in calling routine
c:
      implicit real*8(a-h,o-z)
      character*5 fmt
      character*40 hold
      character*755 cdum
      common/chrcm/fmt,hold,cdum
      fmt='(i40)'
      write(hold,fmt) i
      call chrpak(hold,40,l)
      chri=hold(1:l)
      return
      end

      subroutine chrpak(c,lmax,lc)
c: packs out blanks in a character string whose maximum length is lmax
c: lc is returned as the packed length.
c:
      character*(*) c
      character*800 ct
      common/chrcm/ct
      k=0
      do 10 i=1,lmax
      if(c(i:i).ne.' ') then
        k=k+1
        if(k.gt.800) stop 'abort - maxed out in chrpak'
        ct(k:k)=c(i:i)
      end if
   10 continue
      lc=k
      c=ct(1:lc)

      return

      end
      
      
!   SUBROUTINE TO INITIALIZE RANDOM SEE DIFFERENT PER EACH IPART AND SYSTEM TIME
      
      SUBROUTINE init_random_seed(ipart,RMULT)
            INTEGER :: i, n, clock,ipart,RMULT
            INTEGER, DIMENSION(:), ALLOCATABLE :: seed

            CALL RANDOM_SEED(size = n)
            ALLOCATE(seed(n))
            CALL SYSTEM_CLOCK(COUNT=clock)
           ! seed = clock + 37 * (/ (i - 1, i = 1, n) /) +ipart*RMULT ! seed dependent of time and particle number
           !seed = clock + 37 * (/ (i - 1, i = 1, n) /)   !   seed dependent of time only  
            seed = ipart*RMULT + (1000000-ipart)*789456   ! seed dependent only of particle number (same time for parallel version)
            WRITE(*,*) seed
            CALL RANDOM_SEED(PUT = seed)
            DEALLOCATE(seed)
            RETURN
          END SUBROUTINE init_random_seed

	
C 	END OF SUBROUTINE AND FUNCTION TO TRANSFORM FILENAME FORMAT TO BE WRITEN USING CLUSTER FORMAT
	

!***************************************************************
!            Pacific Northwest National Laboratory
!***************************************************************
!
! NAME:  Module file "random"
!
! VERSION and DATE: 1.0 8-06-98
!
! PURPOSE:  Random number generation
!
! RETURNS:
!
! REQUIRED:
!
! LOCAL VARIABLES:
!
! COMMENTS: 
!
! MOD HISTORY: 
!
!
!***************************************************************
!***************************************************************
!
      SUBROUTINE generate_unif(rsign1,rnum1,rsign2,rnum2,rsign3,rnum3,
     &nrand)
!	Generates three random numbers from UNIF[0,1]     
	INTEGER i
	DOUBLE PRECISION :: rnum1, rnum2, rnum3, rnumvec(6)
      DOUBLE PRECISION :: rsign1,rsign2,rsign3
      nrand = 6
!	Set the type of random number generator
!	intrinsinc Fortran r.n. generator for now
!	Call the uniform(0,1) random number generator
        DO i = 1, nrand
          CALL RANDOM_NUMBER(rnumvec(i))
        ENDDO
!	Fill the random number structure
      rsign1 = rnumvec(1)  
      rnum1  = rnumvec(2)
      rsign2 = rnumvec(3)  
	rnum2  = rnumvec(4)
      rsign3 = rnumvec(5)  
	rnum3  = rnumvec(6)
!     Assing sing values to rsing variables depending center point of rang of distribution 0 to 1
      IF (rsign1.GE.0.5) THEN
        rsign1 = 1.0
      ELSE
        rsign1 = -1.0
      ENDIF
      IF (rsign2.GE.0.5) THEN
        rsign2 = 1.0
      ELSE
        rsign2 = -1.0
      ENDIF
      IF (rsign3.GE.0.5) THEN
        rsign3 = 1.0
      ELSE
        rsign3 = -1.0
      ENDIF
	END SUBROUTINE generate_unif
	
!	SUBROUTINE FROM KIRK NELSON AND TIM GINN TO CONVERT UNIFORM DISTRIBUTION WITH RANGE 0 TO 1
!	TO GAUSSIAN DISTRIBUTION WITH ZERO MEAN AND UNIT VARIANCE	
!	Curve fitting of output from ni.f90 (or ni2.f90) which was
!	adapted from Cunningham (1969), Appl. Stat., vol. 18, no. 3
	subroutine calc_ni(bigni,ni)
	implicit none
	DOUBLE PRECISION off1,off2,off3,a,b,c
	DOUBLE PRECISION, intent(in)::bigni
	DOUBLE PRECISION, intent(out)::ni

	off1 = 1
	off2 = 1
	off3 = 1
	a = -1.0
	b = -1.0
	c = -1.0

	IF (bigni<=.001d0) THEN
		ni = -1.37855370200823D19*bigni**6 +
     *		  4.979009889572070D16*bigni**5 -
     *		  7.214759669310110D13*bigni**4 +
     *		  5.395500767177740D10*bigni**3 - 
     *          2.260106114986480D7*bigni**2 +
     *		  5.826517832043450D3*bigni - 4.129164575760240D0
	ELSE IF (bigni>=.001d0 .and. bigni<.01d0) THEN
	    ni = -6.18440506368D12*bigni**6 +
     *		  2.367655494581510D11*bigni**5 - 
     *          3.71327758909687D9*bigni**4 + 
     *		  3.098709790040470D7*bigni**3 - 
     *          1.51794899112573D5*bigni**2 +
     *		  4.96459221152939D2*bigni - 3.45983671935511D0
	ELSE IF (bigni>=.01d0 .and. bigni<.1d0) THEN
		ni = -6.63992198925781D6*bigni**6 + 
     *		  2.55090340507925D6*bigni**5 - 
     *          4.03094347079323D5*bigni**4 +
     *		  3.41189134002463D4*bigni**3 - 
     *          1.71427218447456D3*bigni**2 + 
     *		  5.95899557785023D1*bigni - 2.77770616554113D0
	ELSE IF (bigni>=.1d0 .and. bigni<.5d0) THEN
		ni = -2.07333319758618D1*bigni**4 +
     *		  3.32434759389286D1*bigni**3 - 
     *          2.07730620338030D1*bigni**2 + 
     *		  8.58215179655931D0*bigni - 1.95934743109075D0
	ELSE IF (bigni>=.5d0 .and. bigni<.9d0) THEN
		ni =  2.0720122918894D1*bigni**4 - 
     *		  4.96540631938802D1*bigni**3 +
     *		  4.54066630995313D1*bigni**2 -
     *		  1.61509902781561D1*bigni + 1.63751297685375D0
	ELSE IF (bigni>=.9d0 .and. bigni<.99d0) THEN
		ni = -1*(-6.63992198925781D6*(a*bigni+off1)**6 + 
     *		  2.55090340507925D6*(a*bigni+off1)**5 - 
     *          4.03094347079323D5*(a*bigni+off1)**4 +
     *		  3.41189134002463D4*(a*bigni+off1)**3 - 
     *          1.71427218447456D3*(a*bigni+off1)**2 + 
     *		  5.95899557785023D1*(a*bigni+off1) - 2.77770616554113D0)
	ELSE IF (bigni>=.99d0 .and. bigni<.9996d0) THEN
	    ni = -1*(-6.18440506368D12*(b*bigni+off2)**6 +
     *		  2.367655494581510D11*(b*bigni+off2)**5 - 
     *          3.71327758909687D9*(b*bigni+off2)**4 + 
     *		  3.098709790040470D7*(b*bigni+off2)**3 - 
     *          1.51794899112573D5*(b*bigni+off2)**2 +
     *		  4.96459221152939D2*(b*bigni+off2) - 3.45983671935511D0)
	ELSE
		ni = -1*(+1.37855370200823D19*(c*bigni+off3)**6 +
     *		  4.979009889572070D16*(c*bigni+off3)**5 -
     *		  7.214759669310110D13*(c*bigni+off3)**4 +
     *		  5.395500767177740D10*(c*bigni+off3)**3 - 
     *          2.260106114986480D7*(c*bigni+off3)**2 +
     *		  5.826517832043450D3*(c*bigni+off3) - 4.129164575760240D0)
	END IF
	RETURN
	end subroutine
	
      SUBROUTINE FLINCO (X,Y,Z,XHET,YHET,RHET,RZOI,
     &NHET2,ZETACST,AP,A132,IS,ECHG,ZI,ERE0,KB,T,ZETAP,
     &ZETAHET,LAMBDA,NIO,KAPPA,TSIZE,AREAHET,
     &AFRACT,FLN,FEDL,FVDW)  
     
      DOUBLE PRECISION X,Y,Z,XHET,YHET,RHET,RZOI,ZETACST,AP,A132,IS,ECHG
      DOUBLE PRECISION ERE0,KB,T,ZETAP,ZETAHET,FLN,FEDL,FVDW,KAPPAHLIM
      DOUBLE PRECISION AFRACT,AF,XHET1,YHET1,RHET1,EDLHET,EDLBULK,TSIZE
      DOUBLE PRECISION XGRID,YGRID,XGRIDR,YGRIDR,NIO,LAMBDA,KAPPA
      DOUBLE PRECISION AREAHET,H
      INTEGER NHET2,ZI,I  
      DIMENSION XHET(10000),YHET(10000),RHET(10000)
c     CALCULATE SEPARATION DISTANCE      
      H = Z-AP

C     LOCATE TILE IN GRID  
      XNS = X
      YNS = Y
  	XGRIDR= XNS/TSIZE
      YGRIDR= YNS/TSIZE	
      XGRID= INT(XGRIDR)
      YGRID= INT(YGRIDR)
C     DETERMINE THE OFFSET DISTANCE IN X AND Y TO MAP THE HETDOMAIN TILE 	
C     IF THE ELEMENT IS IN THE POSITIVE SECTION OF THE GRID >1
          IF (XGRID.GE.1) THEN
            XOFF = XGRID*TSIZE
          END IF
          IF (YGRID.GE.1) THEN
            YOFF = YGRID*TSIZE
          END IF
c      IF  THE ELEMENT IS OVER THE FIRST GRID ELEMENT [O 1[
	    IF ((XGRIDR.LT.1.0).AND.(XGRIDR.GE.0.0)) THEN
	      XOFF=0.0
          END IF
	    IF ((YGRIDR.LT.1.0).AND.(YGRIDR.GE.0.0)) THEN
            YOFF=0.0
	    END IF  
C	IF THE ELEMENTS IN THE NEGATIVE SECTION OF THE GRID ]-1 0[  
          IF ((XGRIDR.LT.0.0).AND.(XGRIDR.GE.-1.0)) THEN  
            XOFF = -1.0*TSIZE
          END IF
          IF ((YGRIDR.LT.0.0).AND.(YGRIDR.GE.-1.0)) THEN  
            YOFF = -1.0*TSIZE
          END IF
C	IF THE ELEMENT IS IN THE NEGATIVE SECTION OF THE GRID LT -1.0
          IF (XGRIDR.LT.-1.0) THEN  
            XOFF = (XGRID-1.0)*TSIZE
          END IF
          IF (YGRIDR.LT.-1.0) THEN  
           YOFF = (YGRID-1)*TSIZE
          END IF      
      
C     DETERMINE FRACTIONAL AREA OF ZOI OCCUPIED BY HETDOMAINS
      AF = 0.0
      AFRACT = 0.0   
	DO 900 I =1,NHET2
	  !CORNERS
	  IF ((X.GT.(XOFF+TSIZE-RZOI)).AND.(Y.GT.(YOFF+TSIZE-RZOI))) THEN !TOP RIGHT CORNER
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF+TSIZE !RIGHT TILE 1
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)	      
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF+TSIZE !TOP RIGHT TILE 2
	      YHET1=YHET(I)+YOFF+TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF !TOP TILE 3
	      YHET1=YHET(I)+YOFF+TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	  END IF  !TOP RIGHT CORNER	
	  IF ((X.GE.XOFF).AND.(X.LT.(XOFF+RZOI)).AND.
     &      (Y.GT.YOFF+TSIZE-RZOI))THEN !TOP LEFT CORNER 4
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF !TOP TILE 3
	      YHET1=YHET(I)+YOFF+TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF-TSIZE !TOP LEFT TILE 4
	      YHET1=YHET(I)+YOFF+TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF-TSIZE !LEFT TILE 5
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	  END IF  !TOP LEFT CORNER
        IF ((X.GE.XOFF).AND.(X.LT.(XOFF+RZOI)).AND.
     &      (Y.LT.YOFF+RZOI))THEN !BOTTOM LEFT CORNER
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF-TSIZE !LEFT TILE 5
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF-TSIZE !BOTTOM LEFT TILE 6
	      YHET1=YHET(I)+YOFF-TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF !BOTTOM TILE 7
	      YHET1=YHET(I)+YOFF-TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	  END IF  !BOTTOM LEFT CORNER	 
        IF ((X.GT.(XOFF+TSIZE-RZOI)).AND.(Y.LT.(YOFF+RZOI)))THEN !BOTTOM RIGHT CORNER
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF !BOTTOM TILE 7
	      YHET1=YHET(I)+YOFF-TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF+TSIZE !BOTTOM RIGHT TILE 8
	      YHET1=YHET(I)+YOFF-TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF+TSIZE !RIGHT TILE 1
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	  END IF  !BOTTOM RIGHT CORNER	 
	  !SIDES
	  IF((X.GT.(XOFF+TSIZE-RZOI)).AND.(Y.GE.YOFF+(RZOI)).AND.
     &     (Y.LE.(YOFF+TSIZE-RZOI))) THEN  !RIGHT SIDE
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF+TSIZE !RIGHT SIDE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION     
	  END IF !RIGHT SIDE	   
	  IF((X.LT.(XOFF+RZOI)).AND.(Y.GE.(YOFF+RZOI)).AND.
     &     (Y.LE.(YOFF+TSIZE-RZOI))) THEN  !LEFT SIDE
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF-TSIZE !LEFT SIDE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION     
	  END IF !LEFT SIDE
	  IF((X.GE.(XOFF+RZOI)).AND.(X.LE.(XOFF+TSIZE-RZOI)).AND.
     &      (Y.GT.(YOFF+TSIZE-RZOI)))THEN  !TOP SIDE
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF !TOP SIDE
	      YHET1=YHET(I)+YOFF+TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION     
	  END IF !BOTTOM SIDE
	  IF((X.GE.(XOFF+RZOI)).AND.(X.LE.(XOFF+TSIZE-RZOI)).AND.
     &      (Y.LT.(YOFF+RZOI)))THEN  !BOTTOM SIDE
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION
	      XHET1=XHET(I)+XOFF !BOTTOM SIDE
	      YHET1=YHET(I)+YOFF-TSIZE
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION     
	  END IF !BOTTOM SIDE	 
	  IF ((X.GE.(XOFF+RZOI)).AND.(X.LE.(XOFF+TSIZE-RZOI)).AND.
     &      (Y.GE.(YOFF+RZOI)).AND.(Y.LE.(YOFF+TSIZE-RZOI)))THEN !CENTER
	      XHET1=XHET(I)+XOFF !INITIAL TILE
	      YHET1=YHET(I)+YOFF
	      RHET1=RHET(I)
	      CALL AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	      AFRACT = AF + AFRACT !ADD HETDOMAIN AREAL CONTRIBUTION	  
	  END IF 	  	    	  	    	  	  	  	    	  	    
900   CONTINUE 
      !CALCULATE COLLOIDAL FORCE BASED IN PLATE SPHERE GEOMETRY 
		FVDW = -(A132*AP/(6.0*H**2))*
     *	(LAMBDA*(LAMBDA+22.23*H)/((LAMBDA+11.116*H)**2))

C		CALC EDL FORCES (SPHERE-PLANE GEOMETRY) BULK
      ZETAC= ZETACST !CALCULATE TOTALY REPULSIVE CONTRIBUTION
		EDL = 4.0*3.141*ERE0*KAPPA*AP*ZETAP*ZETAC*
     *		((EXP(-KAPPA*H)/(1.0+EXP(-KAPPA*H)))-
     *		((ZETAP-ZETAC)**2.0/(2.0*ZETAP*ZETAC))*
     *		(EXP(-2.0*KAPPA*H)/(1.0-EXP(-2*KAPPA*H))))
		IF (ABS(EDL).LT.1.0E-30) THEN
			EDL = 0.0
		ENDIF     
      EDLBULK = EDL
      ZETAC= ZETAHET !CALCULATE TOTALY ATRACTIVE CONTRIBUTION
		EDL = 4.0*3.141*ERE0*KAPPA*AP*ZETAP*ZETAC*
     *		((EXP(-KAPPA*H)/(1.0+EXP(-KAPPA*H)))-
     *		((ZETAP-ZETAC)**2.0/(2.0*ZETAP*ZETAC))*
     *		(EXP(-2.0*KAPPA*H)/(1.0-EXP(-2*KAPPA*H))))
		IF (ABS(EDL).LT.1.0E-30) THEN
			EDL = 0.0
		ENDIF 
	EDLHET = EDL	 
	!CALCULATE COMBINED EDL CONTRIBUTION BASED IN LINEAR COMBINATION
	FEDL = EDLHET*AFRACT+EDLBULK*(1-AFRACT)  
	!CALCULATE TOTAL FORCE
	FLN = FEDL + FVDW
	END SUBROUTINE FLINCO


	SUBROUTINE AREAFRACT(X,Y,RZOI,XHET1,YHET1,RHET1,AF)
	DOUBLE PRECISION X,Y,RZOI,XHET1,YHET1,RHET1,AF,AL
      DOUBLE PRECISION DIST,D1,D2,PI,DUMMY,DHET,DZOI,AHETF
      DATA PI/3.14159265359/ 
      !RESET FRACTIONAL AREA CONTRIBUTION
      AF = 0.0
      !CALCULATE DISTANCE BETWEEN CENTER OF ZOI AND CENTER OF HETERODOMAIN
      DIST = ((X-XHET1)**2.0+(Y-YHET1)**2.0)**0.5
      !PRINT *,'DIST =',DIST
      IF (DIST.GE.(RHET1+RZOI)) THEN !HETDOMAIN OUT OF ZOI, NO OVERLAPPING
        AF = 0.0
        !PRINT *,'HETDOMAIN OUT OF ZOI, NO OVERLAPPING'
      ELSEIF (DIST.LT.(RHET1+RZOI)) THEN  !OVERLAPPING CONDITIONS
        IF ((DIST.GT.ABS(RHET1-RZOI)).AND.(DIST.GE.1.0E-9)) THEN !PARTIAL OVERLAPPING
            IF (RZOI.GT.RHET1) THEN
                DZOI = RZOI
                DHET = RHET1
                !PRINT *,'!PARTIAL OVERLAPPING RZOI.GT.RHET1'
            ELSE
                DZOI = RHET1
                DHET = RZOI 
                !PRINT *,'!PARTIAL OVERLAPPING RZOI.LE.RHET1'            
            END IF
c           CALCULATE OVERLAPPING AREA 
            AL=DHET*DHET*DACOS((DIST*DIST+DHET*DHET-DZOI*DZOI)/
     &      (2*DIST*DHET))+DZOI*DZOI*DACOS((DIST*DIST+DZOI*DZOI-
     &      DHET*DHET)/(2*DIST*DZOI))-0.5*((-1.0*DIST+DHET+DZOI)*
     &      (DIST+DHET-DZOI)*(DIST-DHET+DZOI)*(DIST+DHET+DZOI))**0.5     
C           CALCULATE FRACTIONAL OVERLAPPING AREA RELATIVE TO ZOI   
            AF=AL/(PI*RZOI*RZOI) 
        ELSE IF (DIST.LE.ABS(RHET1-RZOI)) THEN !COMPLETE OVERLAPPING
            IF (RZOI.GT.RHET1) THEN
                AF=RHET1*RHET1/(RZOI*RZOI)
                !PRINT *,'!COMPLETE OVERLAPPING RZOI.GT.RHET1'
            ELSE
                AF = 1.0
                !PRINT *,'!COMPLETE OVERLAPPING RZOI.LE.RHET1'
            END IF
        END IF
      END IF 
      AHETF = (AF*RZOI*RZOI)/(RHET1*RHET1) !FRACTIONAL AREA OF HETDOMAIN OVERLAPED WITH ZOI
      
C     COUNT NUMBER OF HETERODOMAINS FOUND IN ZOI      
      IF (AF.GT.0.0) THEN 
        !WRITE (1,*) XHET1,YHET1,AF
      END IF      
	END SUBROUTINE AREAFRACT

	
	